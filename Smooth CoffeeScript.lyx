#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
\definecolor{darkgreen}{cmyk}{0.5, 0, 1, 0.5}
\definecolor{darkred}{rgb}{0.6, 0.25, 0.15}
\definecolor{darkblue}{rgb}{0.24, 0.165, 0.6}
\definecolor{codebackground}{RGB}{236,253,255}
\definecolor{codestring}{RGB}{121, 103, 99}

\newcounter{ExNum}

\KOMAoptions{index=totoc}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman Times
\font_sans Arcitectura
\font_typewriter Consolas
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 94
\font_tt_scale 96

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Smooth CoffeeScript"
\pdf_author "E. Hoigaard"
\pdf_subject "Introduction to functional programming in CoffeeScript"
\pdf_keywords "CoffeeScript, Functional Programming, Declarative Testing"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 0
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "citecolor=darkblue,linkcolor=darkblue,urlcolor=darkblue"
\papersize b5paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\branch Solutions
\selected 1
\filename_suffix 0
\color #d4f2fa
\end_branch
\branch WithoutSolutions
\selected 0
\filename_suffix 0
\color #c2fac3
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\topmargin 2.2cm
\bottommargin 3.3cm
\secnumdepth -2
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "backgroundcolor={\color{codebackground}},basicstyle={\small\ttfamily\color{black}},comment={[l]{\#}},frame=none,identifierstyle={\color{darkblue}},keywords={true,false,null,this,new,delete,typeof,in,instanceof,return,throw,break,continue,debugger,if,else,switch,for,while,do,try,catch,finally,class,extends,super,undefined,then,unless,until,loop,of,by,when,and,or,is,isnt,not,yes,no,on,off},keywordstyle={\itshape\color{darkgreen}},morecomment={[s]{\#\#\#}{\#\#\#}},morekeywords={each,map,reduceRight,reduce,detect,filter,reject,every,some,include,invoke,pluck,max,min,sortBy,sortedIndex,toArray,size,first,rest,last,compact,flatten,without,uniq,intersect,zip,indexOf,lastIndexOf,range,bind,bindAll,delay,memoize,defer,wrap,compose,keys,values,functions,extend,clone,tap,isEqual,isEmpty,isElement,isArray,isArguments,isFunction,isString,isNumber,isBoolean,isDate,isRegExp,isNaN,isNull,isUndefined,noConflict,identity,times,breakLoop,mixin,uniqueId,templateSettings,template,forEach,foldl,inject,foldr,select,all,any,contains,head,tail,methods,show},morestring={[b]\&quot;},sensitive=true,showstringspaces=false,string={[b]\'},stringstyle={\color{codestring}},tab=true,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename cover/SmoothCoverWithSolutions.pdf
	lyxscale 25
	extra LaTeX "pages=-"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch WithoutSolutions
status open

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename cover/SmoothCoverWithoutSolutions.pdf
	lyxscale 25
	extra LaTeX "pages=-"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title

\size huge
Smooth CoffeeScript
\end_layout

\begin_layout Author

\family sans
\size large
E.
\begin_inset space \space{}
\end_inset

Hoigaard
\end_layout

\begin_layout Publishers

\size large
\begin_inset CommandInset href
LatexCommand href
target "http://autotelicum.github.com/Smooth-CoffeeScript"

\end_inset


\end_layout

\begin_layout Dedication

\size normal
An introduction to CoffeeScript programming with
\begin_inset Newline newline
\end_inset

an emphasis on clarity, abstraction and verification.
\size large

\begin_inset Newline newline
\end_inset


\begin_inset VSpace 25pheight%
\end_inset


\size normal
The book is 
\begin_inset CommandInset href
LatexCommand href
name "freely"
target "http://creativecommons.org/licenses/by/3.0/"

\end_inset

 available, and may be used (as a whole or in parts)
\begin_inset Newline newline
\end_inset

in any way you see fit, as long as credit is given to the original author.
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Based on Eloquent JavaScript by Marijn Haverbeke"
target "http://eloquentjavascript.net/"

\end_inset

.
\size large

\begin_inset Newline newline
\end_inset


\begin_inset VSpace 25pheight%
\end_inset


\size normal
Typeset in LyX / XeTeX with 
\family sans
Arcitectura
\family default
.
\begin_inset Newline newline
\end_inset

1
\begin_inset script superscript

\begin_layout Plain Layout

\size normal
st
\end_layout

\end_inset

 edition, 3
\begin_inset script superscript

\begin_layout Plain Layout

\size normal
rd
\end_layout

\end_inset

 revision & illustrations © 2554 
\begin_inset CommandInset href
LatexCommand href
name "BE"
target "http://www.accesstoinsight.org/history.html#fn-1"

\end_inset

 / 2011 
\begin_inset CommandInset href
LatexCommand href
name "CE"
target "http://www.accesstoinsight.org/history.html#fn-2"

\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Public domain cover photo"
target "http://www.publicdomainpictures.net/view-image.php?image=11133&picture=ostriches-look"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Preface
\end_layout

\begin_layout Addchap
Foreword
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Foreword
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Foreword"

\end_inset


\end_layout

\begin_layout Standard
Coffee\SpecialChar \-
Script is a lucid evolution of Java\SpecialChar \-
Script created by Jeremy Ashkenas.
 This book attempts to be an evolution of 
\begin_inset Quotes eld
\end_inset

Eloquent Java\SpecialChar \-
Script
\begin_inset Quotes erd
\end_inset

 by Marijn Haverbeke.
 Apart from the major change in explaining Coffee\SpecialChar \-
Script instead of Java\SpecialChar \-
Script,
 numerous other changes have been made and sections have been added, edited
 or removed.
\end_layout

\begin_layout Standard
Everything that is expressed in this book is therefore solely the responsibility
 of the editor.
 In the sense of open source software, this book is a 
\begin_inset CommandInset href
LatexCommand href
name "fork"
target "http://en.wikipedia.org/wiki/Fork_(software_development)"

\end_inset

.
 To read the excellent original Java\SpecialChar \-
Script work as it was intended by its
 author refer to 
\begin_inset CommandInset href
LatexCommand href
name "Eloquent JavaScript by Marijn Haverbeke"
target "http://eloquentjavascript.net/"

\end_inset

.
\end_layout

\begin_layout Standard
You do not need to know Java\SpecialChar \-
Script but after reading 
\family sans
Smooth Coffee\SpecialChar \-
Script
\family default
 you can in 
\begin_inset CommandInset href
LatexCommand href
name "JavaScript Basics"
target "http://autotelicum.github.com/Smooth-CoffeeScript/literate/js-intro.html"

\end_inset

 by Rebecca Murphey find an overview that can be helpful when debugging
 or using Java\SpecialChar \-
Script libraries.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The program examples in this book use a prelude file in addition to the
 Coffee\SpecialChar \-
Script environment.
 It includes the Underscore functional library, the Coffeekup 
\shape smallcaps
\size small
HTML
\shape default
\size default
 markup, 
\family typewriter
ws
\family default
 server-side WebSockets and 
\family typewriter
qc
\family default
, a Quick\SpecialChar \-
Check based testing library.
 These libraries extend Coffee\SpecialChar \-
Script with useful abstractions and testing
 tools to keep focus on the task at hand instead of distracting boilerplate
 code.
\end_layout

\begin_layout Standard
While it is possible to express programs from a very small set of language
 primitives, it quickly becomes tedious and error prone to do so.
 The approach taken here is to include a broader set of functional building
 blocks as if they were a native part of the programming language.
 By thinking in terms of these higher level constructs more complex problems
 can be handled with less effort.
\end_layout

\begin_layout Standard
To ensure correctness testing is required.
 This is especially true when developing reusable algorithms in a dynamic
 and untyped language.
 By integrating Quick\SpecialChar \-
Check style test cases as soon as functions are introduced,
 it is intended that writing tests and declaring assumptions become a seamless
 part of writing software.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
Coffee\SpecialChar \-
Script is available in browsers and environments where Java\SpecialChar \-
Script
 is available.
 The screenshots below show Coffee\SpecialChar \-
Script running the same web server and
 client application on Mac OS X, Windows and iOS.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/TadaOnMacOSX.png
	lyxscale 40
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/TadaOnWin7.png
	lyxscale 40
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/TadaOnIOS.png
	lyxscale 40
	width 70text%

\end_inset


\end_layout

\begin_layout Standard
The Coffee\SpecialChar \-
Script below shows the brevity of the self-contained application
 from the screenshots.
 It contains an 
\shape smallcaps
\size small
HTML
\shape default
\size default
 5 web page in Coffeekup markup and its own 
\shape smallcaps
\size small
HTTP
\shape default
\size default
 web server.
 The page has a Canvas element with a drawing of the 
\begin_inset Quotes els
\end_inset

Seed of Life
\begin_inset Quotes ers
\end_inset

.
 Coffeekup is a few hundred lines of Coffee\SpecialChar \-
Script.
 No frameworks.
 No JavaScript.
 Pure and smooth.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},tabsize=2"
inline false
status open

\begin_layout Plain Layout

require './prelude'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

webpage = kup.render -> 
\end_layout

\begin_layout Plain Layout

  doctype 5
\end_layout

\begin_layout Plain Layout

  html ->
\end_layout

\begin_layout Plain Layout

    head ->
\end_layout

\begin_layout Plain Layout

      meta charset: 'utf-8'
\end_layout

\begin_layout Plain Layout

      title 'My drawing | My awesome website'
\end_layout

\begin_layout Plain Layout

      style '''
\end_layout

\begin_layout Plain Layout

        body {font-family: sans-serif}
\end_layout

\begin_layout Plain Layout

        header, nav, section, footer {display: block}
\end_layout

\begin_layout Plain Layout

      '''
\end_layout

\begin_layout Plain Layout

      coffeescript ->
\end_layout

\begin_layout Plain Layout

        draw = (ctx, x, y) ->
\end_layout

\begin_layout Plain Layout

          circle = (ctx, x, y) ->
\end_layout

\begin_layout Plain Layout

            ctx.beginPath()
\end_layout

\begin_layout Plain Layout

            ctx.arc x, y, 100, 0, 2*Math.PI, false
\end_layout

\begin_layout Plain Layout

            ctx.stroke()
\end_layout

\begin_layout Plain Layout

          ctx.strokeStyle = 'rgba(255,40,20,0.7)'
\end_layout

\begin_layout Plain Layout

          circle ctx, x, y
\end_layout

\begin_layout Plain Layout

          for angle in [0...2*Math.PI] by 1/3*Math.PI
\end_layout

\begin_layout Plain Layout

            circle ctx, x+100*Math.cos(angle),
\end_layout

\begin_layout Plain Layout

                        y+100*Math.sin(angle)
\end_layout

\begin_layout Plain Layout

        window.onload = ->
\end_layout

\begin_layout Plain Layout

          canvas = document.getElementById 'drawCanvas'
\end_layout

\begin_layout Plain Layout

          context = canvas.getContext '2d'
\end_layout

\begin_layout Plain Layout

          draw context, 300, 200
\end_layout

\begin_layout Plain Layout

    body ->
\end_layout

\begin_layout Plain Layout

      header -> h1 'Seed of Life'
\end_layout

\begin_layout Plain Layout

      canvas id: 'drawCanvas', width: 600, height: 400
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

http = require 'http'
\end_layout

\begin_layout Plain Layout

server = http.createServer (req, res) ->
\end_layout

\begin_layout Plain Layout

  show "#{req.client.remoteAddress} #{req.method} #{req.url}"
\end_layout

\begin_layout Plain Layout

  res.writeHead 200, 'Content-Type': 'text/html'
\end_layout

\begin_layout Plain Layout

  res.write webpage
\end_layout

\begin_layout Plain Layout

  res.end()
\end_layout

\begin_layout Plain Layout

server.listen 3389
\end_layout

\begin_layout Plain Layout

show 'Server running at'
\end_layout

\begin_layout Plain Layout

show  server.address()
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Software
\end_layout

\begin_layout Standard

\family sans
Smooth Coffee\SpecialChar \-
Script
\family default
 is about the Coffee\SpecialChar \-
Script language, see 
\begin_inset CommandInset href
LatexCommand href
name "Quick CoffeeScript Install"
target "http://autotelicum.github.com/Smooth-CoffeeScript/literate/install-notes.html"

\end_inset

 or refer to the websites for further installation information.
 This should get you started:
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Itemize
The Coffee\SpecialChar \-
Script language (1.1.3 / MIT) from 
\begin_inset CommandInset href
LatexCommand href
name "Jeremy Ashkenas"
target "http://www.coffeescript.org"

\end_inset


\end_layout

\begin_layout Itemize
The Underscore library (1.1.0.FIX / MIT) included in 
\begin_inset CommandInset href
LatexCommand href
name "CoffeeScript"
target "http://jashkenas.github.com/coffee-script/documentation/docs/underscore.html"

\end_inset


\end_layout

\begin_layout Itemize
The Coffeekup library (0.3.1 / MIT) from 
\begin_inset CommandInset href
LatexCommand href
name "Maurice Machado"
target "http://coffeekup.org/"

\end_inset


\end_layout

\begin_layout Itemize
Translated 
\family typewriter
ws
\family default
 WebSockets (MIT) from 
\begin_inset CommandInset href
LatexCommand href
name "Jacek Becela"
target "https://github.com/ncr/node.ws.js"

\end_inset


\end_layout

\begin_layout Itemize
The 
\family typewriter
qc
\family default
 testing library
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This library is only used to test functionality.
 The Coffee\SpecialChar \-
Script applications in 
\family sans
Smooth Coffee\SpecialChar \-
Script
\family default
 do not depend on it.
 Coffee\SpecialChar \-
Script is a new language and tools like 
\family typewriter
qc
\family default
 and docco depend on legacy code written respectively in JavaScript and
 Python.
\end_layout

\end_inset

 (2009 / BSD) from 
\begin_inset CommandInset href
LatexCommand href
name "Darrin Thompson"
target "https://bitbucket.org/darrint/qc.js/"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
The required libraries have been adapted for standard Coffee\SpecialChar \-
Script and are
 included in the 
\begin_inset listings
lstparams "language=bash"
inline true
status open

\begin_layout Plain Layout

src/prelude
\end_layout

\end_inset

 directory.
 Underscore, 
\family typewriter
ws
\family default
 and Coffeekup are written in Coffee\SpecialChar \-
Script and they are small enough to
 read and understand in a short time — at least after you have read this
 book.
 Literate documentation made with docco is in 
\begin_inset listings
lstparams "language=bash,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

src/docs
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
To set up your own working environment follow the steps described 
\begin_inset CommandInset href
LatexCommand href
name "here"
target "http://autotelicum.github.com/Smooth-CoffeeScript/literate/install-notes.html"

\end_inset

 or at 
\begin_inset CommandInset href
LatexCommand href
name "coffeescript.org"
target "http://jashkenas.github.com/coffee-script/#installation"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The CoffeeScript examples have been tested on Mac OS X 10.6 and on Windows
 7 with the prebuilt node installers.
\end_layout

\end_inset

.
 If you use Windows then you can adapt the prelude to default to your preferred
 web browser.
 You can also find instructions there for how to enable WebSockets if your
 browser requires it.
\end_layout

\begin_layout Standard
Then set up your text editor to support Coffee\SpecialChar \-
Script, you can find several
 on the 
\begin_inset CommandInset href
LatexCommand href
name "CoffeeScript wiki"
target "https://github.com/jashkenas/coffee-script/wiki/Text-editor-plugins"

\end_inset

.
 For example to use the 
\begin_inset CommandInset href
LatexCommand href
name "TextMate bundle"
target "https://github.com/jashkenas/coffee-script-tmbundle"

\end_inset

 with the cross-platform 
\begin_inset CommandInset href
LatexCommand href
name "Sublime Text 2 editor"
target "http://www.sublimetext.com/2"

\end_inset

, unpack the bundle in a Coffee\SpecialChar \-
Script directory under Packages.
 This setup gives you syntax highlighting, code snippets, and code completion.
\end_layout

\begin_layout Standard
You can add a build file to get execution of Coffee\SpecialChar \-
Script with the press
 of a button.
 Name the file CoffeeScript.sublime-build and change the path according to
 you operating system and install location.
 Something like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	"cmd": ["/Users/username/bin/coffee", "$file"],
\end_layout

\begin_layout Plain Layout

	"file_regex": "^Error: In (...*?),
\end_layout

\begin_layout Plain Layout

                  Parse error on line ([0-9]*):?",
\end_layout

\begin_layout Plain Layout

	"selector": "source.coffee"
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Fix error location regex when it works in Sublime Text 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally open a command-line in a terminal and type (again adjust for your
 platform)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

cd path-to-smooth-coffeescript/src
\end_layout

\begin_layout Plain Layout

coffee -r ./prelude
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then you have a Coffee\SpecialChar \-
Script Read-Eval-Print-Loop (REPL) at your disposal.
 Read the 
\begin_inset CommandInset href
LatexCommand href
name "usage section"
target "http://jashkenas.github.com/coffee-script/#installation"

\end_inset

 for more information on the Coffee\SpecialChar \-
Script compiler.
 You can run samples with 
\begin_inset listings
lstparams "language=bash"
inline true
status open

\begin_layout Plain Layout

coffee filename.coffee
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard

\family sans
Smooth Coffee\SpecialChar \-
Script
\family default
 comes in two editions; with and without solutions.
 Complete by chapter source code files are in the src directory.
 A copy of all files are in src-no-solutions, these files have stops where
 you can insert your own solutions.
\end_layout

\begin_layout Standard
To get the most out of the book: Start your text editor and in src-no-solutions
 open the source code file for the chapter you are reading.
 If you have a wide-screen display then arrange your windows so the book
 is on one side and the text editor on the other.
 Then you can read and run the samples, see the results, experiment with
 the code and solve the exercises.
\end_layout

\begin_layout Standard
If you make copies of the files you work on then you can easily undo experiments.
 If you get stuck with an exercise then copy my solution from the file in
 the src directory and study it a bit before moving on.
 Note that in some of the source files you have to indent your solutions
 to match the surrounding code.
\end_layout

\begin_layout Standard
Both editions and accompanying source files can be downloaded from: 
\begin_inset CommandInset href
LatexCommand href
target "http://autotelicum.github.com/Smooth-CoffeeScript/"

\end_inset


\end_layout

\begin_layout Part
Language
\end_layout

\begin_layout Chapter
Introduction 
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Introduction
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Introduction"

\end_inset


\end_layout

\begin_layout Standard
When personal computers were first introduced, most of them came equip\SpecialChar \-
ped
 with a simple programming language, usually a variant of 
\shape smallcaps
BASIC
\shape default
.
 Interacting with the computer was closely integrated with this language,
 and thus every computer-user, whether he wanted to or not, would get a
 taste of it.
 Now that computers have become plentiful and cheap, typical users do not
 get much further than clicking things with a mouse.
 For most people, this works very well.
 But for those of us with a natural inclination towards technological tinkering,
 the removal of programming from every-day computer use presents something
 of a barrier.
\end_layout

\begin_layout Standard
Fortunately, as an effect of developments in the World Wide Web, it so happens
 that every computer equipped with a modern web-browser also has an environment
 for programming Java\SpecialChar \-
Script which can easily be adap\SpecialChar \-
ted to an environment
 for Coffee\SpecialChar \-
Script.
 In today
\begin_inset Quotes ers
\end_inset

s spirit of not bothering the user with technical details, it is kept well
 hidden, but a web-page can make it accessible, and use it as a platform
 for learning to program.
 You can find such an environment in the menu on 
\begin_inset CommandInset href
LatexCommand href
target "coffeescript.org"

\end_inset

 select 
\begin_inset Quotes els
\end_inset

Try Coffee\SpecialChar \-
Script
\begin_inset Quotes ers
\end_inset

 or use the 
\begin_inset Quotes els
\end_inset

load
\begin_inset Quotes ers
\end_inset

 button below the examples.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace -3pt
\end_inset


\end_layout

\begin_layout Quote

\emph on
I do not enlighten those who are not eager to learn, nor arouse those who
 are not anxious to give an explanation themselves.
 If I have presented one corner of the square and they cannot come back
 to me with the other three, I should not go over the points again.
\end_layout

\begin_layout Dictum
\noindent

\family sans
\size footnotesize
Confucius
\end_layout

\begin_layout Standard

\lang english
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Besides explaining Coffee\SpecialChar \-
Script, this book tries to be an introduction to
 the basic principles of programming.
 Programming, it turns out, is hard.
 The fundamental rules are, most of the time, simple and clear.
 But programs, while built on top of these basic rules, tend to become complex
 enough to introduce their own rules, their own complexity.
 Because of this, programming is rarely simple or predictable.
 As Donald Knuth, who is something of a founding father of the field, says,
 it is an 
\emph on
art
\emph default
.
\end_layout

\begin_layout Standard
To get something out of this book, more than just passive reading is required.
 Try to stay sharp, make an effort to solve the exercises, and only continue
 on when you are reasonably sure you understand the material that came before.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace -3pt
\end_inset


\end_layout

\begin_layout Quote

\emph on
The computer programmer is a creator of universes for which he alone is
 responsible.
 Universes of virtually unlimited complexity can be created in the form
 of computer programs.
\end_layout

\begin_layout Dictum

\family sans
\size footnotesize
Joseph Weizenbaum, 
\emph on
Computer Power and Human Reason
\end_layout

\begin_layout Standard

\lang english
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
A program is many things.
 It is a piece of text typed by a programmer, it is the directing force
 that makes the computer do what it does, it is data in the computer
\begin_inset Quotes ers
\end_inset

s memory, yet it controls the actions performed on this same memory.
 Analogies that try to compare programs to objects we are familiar with
 tend to fall short, but a superficially fitting one is that of a machine.
 The gears of a mechanical watch fit together ingeniously, and if the watchmaker
 was any good, it will accurately show the time for many years.
 The elements of a program fit together in a similar way, and if the programmer
 knows what he is doing, the program will run without crashing.
\end_layout

\begin_layout Standard
A computer is a machine built to act as a host for these immaterial machines.
 Computers themselves can only do stupidly straightforward things.
 The reason they are so useful is that they do these things at an incredibly
 high speed.
 A program can, by ingeniously combining many of these simple actions, do
 very complicated things.
\end_layout

\begin_layout Standard
To some of us, writing computer programs is a fascinating game.
 A program is a building of thought.
 It is costless to build, weightless, growing easily under our typing hands.
 If we get carried away, its size and complexity will grow out of control,
 confusing even the one who created it.
 This is the main problem of programming.
 It is why so much of today
\begin_inset Quotes ers
\end_inset

s software tends to crash, fail, screw up.
\end_layout

\begin_layout Standard
When a program works, it is beautiful.
 The art of programming is the skill of controlling complexity.
 The great program is subdued, made simple in its complexity.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Today, many programmers believe that this complexity is best managed by
 using only a small set of well-understood techniques in their programs.
 They have composed strict rules about the form programs should have, and
 the more zealous among them will denounce those who break these rules as
 
\emph on
bad
\emph default
 programmers.
\end_layout

\begin_layout Standard
What hostility to the richness of programming! To try to reduce it to something
 straightforward and predictable, to place a taboo on all the weird and
 beautiful programs.
 The landscape of programming techniques is enormous, fascinating in its
 diversity, still largely unexplored.
\end_layout

\begin_layout Standard
It is certainly littered with traps and snares, luring the inexperienced
 programmer into all kinds of horrible mistakes, but that only means you
 should proceed with caution, keep your wits about you.
 As you learn, there will always be new challenges, new territory to explore.
 The programmer who refuses to keep exploring will surely stagnate, forget
 his joy, lose the will to program (and become a manager).
\end_layout

\begin_layout Standard
As far as I am concerned, the definite criterion for a program is whether
 it is correct.
 Efficiency, clarity, and size are also important, but how to balance these
 against each other is always a matter of judgement, a judgement that each
 programmer must make for himself.
 Rules of thumb are useful, but one should never be afraid to break them.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
In the beginning, at the birth of computing, there were no programming languages.
 Programs looked something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

00110001 00000000 00000000 00110001 00000001 00000001
\end_layout

\begin_layout Plain Layout

00110011 00000001 00000010 01010001 00001011 00000010
\end_layout

\begin_layout Plain Layout

00100010 00000010 00001000 01000011 00000001 00000000
\end_layout

\begin_layout Plain Layout

01000001 00000001 00000001 00010000 00000010 00000000
\end_layout

\begin_layout Plain Layout

01100010 00000000 00000000
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is a program to add the numbers from one to ten together, and print
 out the result (1 + 2 + \SpecialChar \ldots{}
 + 10 = 55).
 It could run on a very simple kind of computer.
 To program early computers, it was necessary to set large arrays of switches
 in the right position, or punch holes in strips of cardboard and feed them
 to the computer.
 You can imagine how this was a tedious, error-prone procedure.
 Even the writing of simple programs required much cleverness and discipline,
 complex ones were nearly inconceivable.
\end_layout

\begin_layout Standard
Of course, manually entering these arcane patterns of bits (which is what
 the 1s and 0s above are generally called) did give the programmer a profound
 sense of being a mighty wizard.
 And that has to be worth something, in terms of job satisfaction.
\end_layout

\begin_layout Standard
Each line of the program contains a single instruction.
 It could be written in English like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,language=HTML,numbers=left"
inline false
status open

\begin_layout Plain Layout

Store the number 0 in memory location 0
\end_layout

\begin_layout Plain Layout

Store the number 1 in memory location 1
\end_layout

\begin_layout Plain Layout

Store the value of memory location 1 in location 2
\end_layout

\begin_layout Plain Layout

Subtract the number 11 from the value in location 2
\end_layout

\begin_layout Plain Layout

If the value in memory location 2 is the number 0, continue with instruction
 9
\end_layout

\begin_layout Plain Layout

Add the value of memory location 1 to location 0
\end_layout

\begin_layout Plain Layout

Add the number 1 to the value of memory location 1
\end_layout

\begin_layout Plain Layout

Continue with instruction 3
\end_layout

\begin_layout Plain Layout

Output the value of memory location 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While that is more readable than the binary soup, it is still rather unpleasant.
 It might help to use names instead of numbers for the instructions and
 memory locations:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=HTML"
inline false
status open

\begin_layout Plain Layout

Set 'total' to 0
\end_layout

\begin_layout Plain Layout

Set 'count' to 1
\end_layout

\begin_layout Plain Layout

[loop]
\end_layout

\begin_layout Plain Layout

Set 'compare' to 'count'
\end_layout

\begin_layout Plain Layout

Subtract 11 from 'compare'
\end_layout

\begin_layout Plain Layout

If 'compare' is zero, continue at [end]
\end_layout

\begin_layout Plain Layout

Add 'count' to 'total'
\end_layout

\begin_layout Plain Layout

Add 1 to 'count'
\end_layout

\begin_layout Plain Layout

Continue at [loop]
\end_layout

\begin_layout Plain Layout

[end]
\end_layout

\begin_layout Plain Layout

Output 'total'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At this point it is not too hard to see how the program works.
 Can you? The first two lines give two memory locations their starting values:
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

total
\end_layout

\end_inset

 will be used to build up the result of the program, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 keeps track of the number that we are currently looking at.
 The lines using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compare
\end_layout

\end_inset

 are probably the weirdest ones.
 What the program wants to do is see if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 is equal to 11, in order to decide whether it can stop yet.
 Because the machine is so primitive, it can only test whether a number
 is zero, and make a decision (jump) based on that.
 So it uses the memory location labelled 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compare
\end_layout

\end_inset

 to compute the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count - 11
\end_layout

\end_inset

, and makes a decision based on that value.
 The next two lines add the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 to the result, and increment 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 by one every time the program has decided that it is not 11 yet.
 Here is the same program in Coffee\SpecialChar \-
Script:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

total = 0
\end_layout

\begin_layout Plain Layout

count = 1
\end_layout

\begin_layout Plain Layout

while count <= 10
\end_layout

\begin_layout Plain Layout

  total += count
\end_layout

\begin_layout Plain Layout

  count += 1
\end_layout

\begin_layout Plain Layout

show total
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This gives us a few more improvements.
 Most importantly, there is no need to specify the way we want the program
 to jump back and forth anymore.
 The magic word 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 takes care of that.
 It continues executing the lines indented below it as long as the condition
 it was given holds: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count <= 10
\end_layout

\end_inset

, which means 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 is less than or equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

.
 Apparently, there is no need anymore to create a temporary value and compare
 that to zero.
 This was a stupid little detail, and the power of programming languages
 is that they take care of stupid little details for us.
\end_layout

\begin_layout Standard
This can also be expressed in a shorter form in Coffee\SpecialChar \-
Script:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

total = 0
\end_layout

\begin_layout Plain Layout

total += count for count in [1..10]
\end_layout

\begin_layout Plain Layout

show total
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

in
\end_layout

\end_inset

 words goes through the range of numbers from 1 to 10 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[1..10]
\end_layout

\end_inset

, assigning each number in turn to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

.
 Each value in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 is then added to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

total
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Finally, here is what the program could look like if we happened to have
 the convenient operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 available, which computes the sum of a collection of numbers similar to
 the mathematical notation 
\begin_inset Formula $\sum_{n=1}^{10}n$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show sum [1..10]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another possibility is to have functions attached to datatypes.
 Here a sum function is attached to an array, giving the sum of the elements
 in the array.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show [1..10].sum()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The moral of this story, then, is that the same program can be expressed
 in long and short, unreadable and readable ways.
 The first version of the program was extremely obscure, while the last
 ones are almost English: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 of the numbers from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

.
 (We will see in later chapters how to build things like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

.)
\end_layout

\begin_layout Standard
A good programming language helps the programmer by providing a more abstract
 way to express himself.
 It hides uninteresting details, provides convenient building blocks (such
 as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 construct), and, most of the time, allows the programmer to add building
 blocks himself (such as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 operation).
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Java\SpecialChar \-
Script is the language that is, at the moment, mostly being used to
 do all kinds of clever and horrible things with pages on the World Wide
 Web.
 Java\SpecialChar \-
Script is also used for scripting in 
\begin_inset CommandInset href
LatexCommand href
name "a variety of applications and operating systems"
target "http://en.wikipedia.org/wiki/JavaScript#Uses_outside_web_pages"

\end_inset

.
 Of special note is server-side Java\SpecialChar \-
Script (SSJS), where the server portion
 of a web application is written in Java\SpecialChar \-
Script, so a full application can
 be expressed in one programming language.
 Coffee\SpecialChar \-
Script generates standard Java\SpecialChar \-
Script code and can therefore be used
 in environments where standard Java\SpecialChar \-
Script is accepted.
 It means that both browser portions and server portions can be written
 in Coffee\SpecialChar \-
Script.
\end_layout

\begin_layout Standard
Coffee\SpecialChar \-
Script is a new language so it remains to be seen how popular it becomes
 for general application development, but if you are interested in programming,
 Coffee\SpecialChar \-
Script is definitely a useful language to learn.
 Even if you do not end up doing much web programming, the mind-bending
 programs in this book will always stay with you, haunt you, and influence
 the programs you write in other languages.
\end_layout

\begin_layout Standard
There are those who will say 
\emph on
terrible
\emph default
 things about Java\SpecialChar \-
Script.
 Many of these things are true.
 When I was for the first time required to write something in Java\SpecialChar \-
Script,
 I quickly came to despise the language.
 It would accept almost anything I typed, but interpret it in a way that
 was completely different from what I meant.
 This had a lot to do with the fact that I did not have a clue what I was
 doing, but there is also a real issue here: Java\SpecialChar \-
Script is ridiculously
 liberal in what it allows.
 The idea behind this design was that it would make programming in Java\SpecialChar \-
Script
 easier for beginners.
 In actuality, it mostly makes finding problems in your programs harder,
 because the system will not point them out to you.
\end_layout

\begin_layout Standard
However, the flexibility of the language is also an advantage.
 It leaves space for a lot of techniques that are impossible in more rigid
 languages, and it can be used to overcome some of Java\SpecialChar \-
Script
\begin_inset Quotes ers
\end_inset

s shortcomings.
 After learning it properly, and working with it for a while, I have really
 learned to 
\emph on
like
\emph default
 this language.
 Coffee\SpecialChar \-
Script repairs many of the confusing and cumbersome aspects of Java\SpecialChar \-
Script
, while keeping its underlying flexibility and beauty.
 It is 
\emph on
doubleplusgood
\emph default
.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Most chapters in this book contain quite a lot of code
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Quotes els
\end_inset

Code
\begin_inset Quotes ers
\end_inset

 is the substance that programs are made of.
 Every piece of a program, whether it is a single line or the whole thing,
 can be referred to as 
\begin_inset Quotes els
\end_inset

code
\begin_inset Quotes ers
\end_inset

.
\end_layout

\end_inset

.
 In my experience, reading and writing code is an important part of learning
 to program.
 Try to not just glance over these examples, but read them attentively and
 understand them.
 This can be slow and confusing at first, but you will quickly get the hang
 of it.
 The same goes for the exercises.
 Do not assume you understand them until you have actually written a working
 solution.
\end_layout

\begin_layout Standard
Because of the way the web works, it is always possible to look at the Java\SpecialChar \-
Scrip
t programs that people put in their web-pages.
 This can be a good way to learn how some things are done.
 Because most web programmers are not 
\begin_inset Quotes els
\end_inset

professional
\begin_inset Quotes ers
\end_inset

 programmers, or consider Java\SpecialChar \-
Script programming so uninteresting that they
 never properly learned it, a lot of the code you can find like this is
 of a 
\emph on
very
\emph default
 bad quality.
 When learning from ugly or incorrect code, the ugliness and confusion will
 propagate into your own code, so be careful who you learn from.
 Another source of programs are Coffee\SpecialChar \-
Script projects hosted on open source
 services such as 
\begin_inset CommandInset href
LatexCommand href
name "github"
target "https://github.com"

\end_inset

.
\end_layout

\begin_layout Chapter
Basic CoffeeScript:
\begin_inset Newline newline
\end_inset

values, variables, and control flow
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Basic CoffeeScript
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Basic-CoffeeScript"

\end_inset


\end_layout

\begin_layout Standard
Inside the computer
\begin_inset Quotes ers
\end_inset

s world, there is only data.
 That which is not data, does not exist.
 Although all data is in essence just a sequence of bits
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Bits are any kinds of two-valued things, usually described as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

s and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

s.
 Inside the computer, they take forms like a high or low electrical charge,
 a strong or weak signal, a shiny or dull spot on the surface of a CD.
\end_layout

\end_inset

, and is thus fundamentally alike, every piece of data plays its own role.
 In Coffee\SpecialChar \-
Script
\begin_inset Quotes ers
\end_inset

s system, most of this data is neatly separated into things called value
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
value
\end_layout

\end_inset

s.
 Every value has a type, which determines the kind of role it can play.
 There are six basic types of values: Numbers, strings, booleans, objects,
 functions, and undefined values.
\end_layout

\begin_layout Standard
To create a value, one must merely invoke its name.
 This is very convenient.
 You do not have to gather building material for your values, or pay for
 them, you just call for one and 
\emph on
woosh
\emph default
, you have it.
 They are not created from thin air, of course.
 Every value has to be stored somewhere, and if you want to use a gigantic
 amount of them at the same time you might run out of computer memory.
 Fortunately, this is only a problem if you need them all simultaneously.
 As soon as you no longer use a value, it will dissipate, leaving behind
 only a few bits.
 These bits are recycled to make the next generation of values.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Values of the type number
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
number
\end_layout

\end_inset

 are, as you might have deduced, numeric values.
 They are written the way numbers are usually written:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

144
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Enter that in the console, and the same thing is printed in the output window.
 The text you typed in gave rise to a number value, and the console took
 this number and wrote it out to the screen again.
 In a case like this, that was a rather pointless exercise, but soon we
 will be producing values in less straightforward ways, and it can be useful
 to 
\begin_inset Quotes els
\end_inset

try them out
\begin_inset Quotes ers
\end_inset

 on the console to see what they produce.
\end_layout

\begin_layout Standard
This is what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

144
\end_layout

\end_inset

 looks like in bits
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
If you were expecting something like 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

10010000
\end_layout

\end_inset

 here — good call, but read on.
 Coffee\SpecialChar \-
Script
\begin_inset Quotes ers
\end_inset

s numbers are not stored as integers.
\end_layout

\end_inset

: 
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

01000000 01100010 00000000 00000000 00000000 00000000 00000000 00000000
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The number above has 64 bits.
 Numbers in Coffee\SpecialChar \-
Script always do.
 This has one important repercussion: There is a limited amount of different
 numbers that can be expressed.
 With three decimal digits, only the numbers 0 to 999 can be written, which
 is 10
\begin_inset script superscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

 = 1000 different numbers.
 With 64 binary digits, 2
\begin_inset script superscript

\begin_layout Plain Layout
64
\end_layout

\end_inset

 different numbers can be written.
 This is a lot, more than 10
\begin_inset script superscript

\begin_layout Plain Layout
19
\end_layout

\end_inset

 (a one with nineteen zeroes).
\end_layout

\begin_layout Standard
Not all whole numbers below 10
\begin_inset script superscript

\begin_layout Plain Layout
19
\end_layout

\end_inset

 fit in a Coffee\SpecialChar \-
Script number though.
 For one, there are also negative numbers, so one of the bits has to be
 used to store the sign of the number.
 A bigger issue is that non-whole numbers must also be represented.
 To do this, 11 bits are used to store the position of the decimal dot within
 the number.
\end_layout

\begin_layout Standard
That leaves 52 bits
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Actually, 53, because of a trick that can be used to get one bit for free.
 Look up the 
\begin_inset Quotes els
\end_inset

IEEE 754
\begin_inset Quotes ers
\end_inset

 format if you are curious about the details.
\end_layout

\end_inset

.
 Any whole number less than 2
\begin_inset script superscript

\begin_layout Plain Layout
52
\end_layout

\end_inset

, which is over 10
\begin_inset script superscript

\begin_layout Plain Layout
15
\end_layout

\end_inset

, will safely fit in a Coffee\SpecialChar \-
Script number.
 In most cases, the numbers we are using stay well below that, so we do
 not have to concern ourselves with bits at all.
 Which is good.
 I have nothing in particular against bits, but you 
\emph on
do
\emph default
 need a terrible lot of them to get anything done.
 When at all possible, it is more pleasant to deal with bigger things.
\end_layout

\begin_layout Standard
Fractional numbers are written by using a dot.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

9.81
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For very big or very small numbers, one can also use 
\begin_inset Quotes els
\end_inset

scientific
\begin_inset Quotes ers
\end_inset

 notation by adding an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

e
\end_layout

\end_inset

, followed by the exponent of the number:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

2.998e8
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which is 2.998
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang english

\begin_inset space \thinspace{}
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang british

\begin_inset Formula $\cdot$
\end_inset

10
\begin_inset script superscript

\begin_layout Plain Layout
8
\end_layout

\end_inset

 = 299
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang english

\begin_inset space \thinspace{}
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang british
800
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang english

\begin_inset space \thinspace{}
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang british
000.
 
\end_layout

\begin_layout Standard
Calculations with whole numbers (also called integers) that fit in 52 bits
 are guaranteed to always be precise.
 Unfortunately, calculations with fractional numbers are generally not.
 Like 
\begin_inset Formula $\pi$
\end_inset

 (pi) can not be precisely expressed by a finite amount of decimal digits,
 many numbers lose some precision when only 64 bits are available to store
 them.
 This is a shame, but it only causes practical problems in very specific
 situations
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
An example of this, if 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

p = 1/3
\end_layout

\end_inset

 then 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

6*p
\end_layout

\end_inset

 is equal to 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

.
 However 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

p+p+p+p+p+p
\end_layout

\end_inset

 is not equal to 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

 because the minute rounding errors increase for every addition.
 This happens in the 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 loop shown in the 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Foreword"

\end_inset

.
 It is a general issue with floating point approximations and not a bug
 in Coffee\SpecialChar \-
Script.
 A way of dealing with it is to test if a number is inside a narrow interval
 instead of testing for an exact match.
\end_layout

\end_inset

.
 The important thing is to be aware of it, and treat fractional digital
 numbers as approximations, not as precise values.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
The main thing to do with numbers is arithmetic.
 Arithmetic operations such as addition or multiplication take two number
 values and produce a new number from them.
 Here is what they look like in Coffee\SpecialChar \-
Script: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

100 + 4 * 11
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

 symbols are called operators.
 The first stands for addition, and the second for multiplication.
 Putting an operator between two values will apply
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
applying
\end_layout

\end_inset

 it to those values, and produce a new value.
\end_layout

\begin_layout Standard
Does the example mean 
\begin_inset Quotes els
\end_inset

add 4 and 100, and multiply the result by 11
\begin_inset Quotes ers
\end_inset

, or is the multiplication done before the adding? As you might have guessed,
 the multiplication happens first.
 But, as in mathematics, this can be changed by wrapping the addition in
 parentheses
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
()
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(100 + 4) * 11
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For subtraction, there is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-
\end_layout

\end_inset

 operator, and division can be done with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/
\end_layout

\end_inset

.
 When operators appear together without parentheses, the order in which
 they are applied is determined by the precedence
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
precedence
\end_layout

\end_inset

 of the operators.
 The first example shows that multiplication has a higher precedence than
 addition.
 Division and multiplication always come before subtraction and addition.
 When multiple operators with the same precedence appear next to each other
 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 - 1 + 1
\end_layout

\end_inset

) they are applied left-to-right.
\end_layout

\begin_layout Standard
Try to figure out what value this produces, and then run it to see if you
 were correct\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

115 * 4 - 4 + 88 / 2
\end_layout

\end_inset

These rules of precedence are not something you should worry about.
 When in doubt, just add parentheses.
\end_layout

\begin_layout Standard
There is one more arithmetic operator which is probably less familiar to
 you.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

%
\end_layout

\end_inset

 symbol is used to represent the modulo
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
modulo
\end_layout

\end_inset

 operation.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 modulo 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

 is the remainder of dividing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

.
 For example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

314 % 100
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

14
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10 % 3
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

144 % 12
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 Modulo has the same precedence as multiplication and division.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The next data type is the string
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
string
\end_layout

\end_inset

.
 Its use is not as evident from its name as with numbers, but it also fulfills
 a very basic role.
 Strings are used to represent text, the name supposedly derives from the
 fact that it strings together a bunch of characters.
 Strings are written by enclosing their content in quotes:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'Patch my boat with chewing gum.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Almost anything can be put between quotes, and Coffee\SpecialChar \-
Script will make a
 string value out of it.
 But a few characters are tricky.
 You can imagine how putting quotes between quotes might be hard.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'The programmer pondered: "0x2b or not 0x2b"'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Coffee\SpecialChar \-
Script implements both single quoted and double quoted strings, which
 can be handy when you have only one kind of quote in a string.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

"Aha! It's 43 if I'm not a bit off"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Circumvent apparent bug in syntax highlighting by redefining string delimiter.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Double quoted strings can contain interpolated values, small snippets of
 Coffee\SpecialChar \-
Script code between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

#{
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 The code is evaluated and inserted into the string.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

"2 + 2 gives #{2 + 2}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Newlines, the things you get when you press enter, can not be put between
 quotes in the normal form of strings.
 A string can span multiple lines to help avoid overly long lines in the
 program but the line breaks are not shown in the output.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'Imagine if this was a
\end_layout

\begin_layout Plain Layout

 very long line of text'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Coffee\SpecialChar \-
Script has triple-quoted strings aka heredocs
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
heredocs
\end_layout

\end_inset

 to make it easy to have strings that span multiple lines where the line
 breaks are preserved in the output.
 Indentation before the quotes are ignored so the following lines can be
 aligned nicely.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'''First comes A
\end_layout

\begin_layout Plain Layout

   then comes B'''
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The triple double quoted variant allows for interpolated values.
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

"""  1
\end_layout

\begin_layout Plain Layout

   + 1
\end_layout

\begin_layout Plain Layout

   ---
\end_layout

\begin_layout Plain Layout

     #{1 + 1}"""
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Still to be able to have special characters in a string, the following trick
 is used: Whenever a backslash (
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash

\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

) is found inside quoted text, it indicates that the character after it
 has a special meaning.
 A quote that is preceded by a backslash will not end the string, but be
 part of it.
 When an 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 character occurs after a backslash, it is interpreted as a newline
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
newline
\end_layout

\end_inset

.
 Similarly, a 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 after a backslash means a tab character.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'This is the first line
\backslash
nAnd this is the second'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are of course situations where you want a backslash in a string to
 be just a backslash, not a special code.
 If two backslashes follow each other, they will collapse right into each
 other, and only one will be left in the resulting string value:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'A newline character is written like 
\backslash
"
\backslash

\backslash
n
\backslash
".'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Strings can not be divided, multiplied, or subtracted.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

 operator 
\emph on
can
\emph default
 be used on them.
 It does not add, but it concatenates, it glues two strings together.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'con' + 'cat' + 'e' + 'nate'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are more ways of manipulating strings, but these are discussed later.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Not all operators are symbols, some are written as words.
 For example, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

typeof
\end_layout

\end_inset

 operator, which produces a string value naming the type of the value you
 give it.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typeof 4.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The other operators we saw all operated on two values, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

typeof
\end_layout

\end_inset

 takes only one.
 Operators that use two values are called binary operators
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
binary operator
\end_layout

\end_inset

, while those that take one are called unary operators
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
unary operator
\end_layout

\end_inset

.
 The minus
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

 operator can be used both as a binary and a unary operator
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that there is no space between the unary minus and the value.
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-(10 - 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Then there are values of the boolean
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
boolean
\end_layout

\end_inset

 type.
 There are two of these: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 Coffee\SpecialChar \-
Script has some aliases for them: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 can be written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yes
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

on
\end_layout

\end_inset

.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

no
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

off
\end_layout

\end_inset

.
 These alternatives can in some cases make a program easier to read.
 Here is one way to produce a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 value:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

3 > 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 can be produced like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

3 < 2
\end_layout

\end_inset

I hope you have seen the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<
\end_layout

\end_inset

 signs before.
 They mean, respectively, 
\begin_inset Quotes els
\end_inset

is greater than
\begin_inset Quotes ers
\end_inset

 and 
\begin_inset Quotes els
\end_inset

is less than
\begin_inset Quotes ers
\end_inset

.
 They are binary operators, and the result of applying them is a boolean
 value that indicates whether they hold in this case.
 You can chain comparisons
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
chained comparison
\end_layout

\end_inset

 to test if something is within an interval.
 These comparisons give respectively 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

100 < 115 < 200
\end_layout

\begin_layout Plain Layout

100 < 315 < 200
\end_layout

\end_inset

Strings can be compared in the same way:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'Aardvark' < 'Zoroaster'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The way strings are ordered is more or less alphabetic.
 More or less\SpecialChar \ldots{}
 Uppercase letters are always 
\begin_inset Quotes els
\end_inset

less
\begin_inset Quotes ers
\end_inset

 than lowercase ones, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'Z' < 'a'
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, and non-alphabetic characters (
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

, 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

, etc) are also included in the ordering.
 The actual way in which the comparison is done is based on the Unicode
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Unicode
\end_layout

\end_inset

 standard.
 This standard assigns a number to virtually every character one would ever
 need, including characters from Greek, Arabic, Japanese, Tamil, and so
 on.
 Having such numbers is practical for storing strings inside a computer
 — you can represent them as a list of numbers.
 When comparing strings, Coffee\SpecialChar \-
Script just compares the numbers of the character
s inside the string, from left to right.
\end_layout

\begin_layout Standard
Other similar operators are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>=
\end_layout

\end_inset

 (
\begin_inset Quotes els
\end_inset

is greater than or equal to
\begin_inset Quotes ers
\end_inset

), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<=
\end_layout

\end_inset

 (
\begin_inset Quotes els
\end_inset

is less than or equal to
\begin_inset Quotes ers
\end_inset

), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 (
\begin_inset Quotes els
\end_inset

is equal to
\begin_inset Quotes ers
\end_inset

), and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!=
\end_layout

\end_inset

 (
\begin_inset Quotes els
\end_inset

is not equal to
\begin_inset Quotes ers
\end_inset

).
 Equal to can also be written in text as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is
\end_layout

\end_inset

 and not equal to as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isnt
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'Itchy' isnt 'Scratchy'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
There are also some useful operations that can be applied to boolean values
 themselves.
 Coffee\SpecialChar \-
Script supports three logical operators: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

and
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

or
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

not
\end_layout

\end_inset

.
 These can be used to 
\begin_inset Quotes els
\end_inset

reason
\begin_inset Quotes ers
\end_inset

 about booleans.
\end_layout

\begin_layout Standard
The logical 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

and
\end_layout

\end_inset

 operator can also be written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&&
\end_layout

\end_inset

.
 It is a binary operator, and its result is only 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 if both of the values given to it are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

true and false
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Logical 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

or
\end_layout

\end_inset

 with alias 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||
\end_layout

\end_inset

, is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 if either of the values given to it is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

true or false
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

not
\end_layout

\end_inset

 can be written as an exclamation mark, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!
\end_layout

\end_inset

, it is a unary operator that flips the value given to it, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!true
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

not false
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\family default
\size default
\emph default

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

((4 >= 6) || ('grass' != 'green')) &&
\end_layout

\begin_layout Plain Layout

!(((12 * 2) == 144) && true)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Is this true? For readability, there are a lot of unnecessary parentheses
 in there.
 This simple version means the same thing:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(4 >= 6 or 'grass' isnt 'green') and
\end_layout

\begin_layout Plain Layout

not(12 * 2 is 144 and true)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
Yes, it is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 You can reduce it step by step like this:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(false or true) and not(false and true)
\end_layout

\begin_layout Plain Layout

true and not false
\end_layout

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
I hope you noticed that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'grass'  != 'green'
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 Grass may be green, but it is not equal to green.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is not always obvious when parentheses are needed.
 In practice, one can usually get by with knowing that of the operators
 we have seen so far, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

or
\end_layout

\end_inset

 has the lowest precedence, then comes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

and
\end_layout

\end_inset

, then the comparison operators (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

, etcetera), and then the rest.
 This has been chosen in such a way that, in simple cases, as few parentheses
 as possible are necessary.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
All the examples so far have used the language like you would use a pocket
 calculator.
 Make some values and apply operators to them to get new values.
 Creating values like this is an essential part of every Coffee\SpecialChar \-
Script program,
 but it is only a part.
 A piece of code that produces a value is called an expression
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
expression
\end_layout

\end_inset

.
 Every value that is written directly (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

22
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'psychoanalysis'
\end_layout

\end_inset

) is an expression.
 An expression between parentheses is also an expression.
 And a binary operator applied to two expressions, or a unary operator applied
 to one, is also an expression.
\end_layout

\begin_layout Standard
There are a few more ways of building expressions, which will be revealed
 when the time is ripe.
\end_layout

\begin_layout Standard
There exists a unit that is bigger than an expression.
 It is called a statement
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
statement
\end_layout

\end_inset

.
 A program is built as a list of statements.
 Most statements end with a newline, although a statement can stretch over
 many lines.
 Statements can also end with a semicolon
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
semicolon
\end_layout

\end_inset

 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

;
\end_layout

\end_inset

).
 In CoffeeScript semicolon is mostly used if you want to place multiple
 statements on the same line.
 The simplest kind of statement is an expression with a semicolon after
 it.
 This is a program:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1; !false
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is a useless program.
 An expression can be content to just produce a value, but a statement only
 amounts to something if it somehow changes the world.
 It could print something to the screen — that counts as changing the world
 — or it could change the internal state of the program in a way that will
 affect the statements that come after it.
 These changes are called 
\begin_inset Quotes els
\end_inset

side effects
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
side effect
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

.
 The statements in the example above just produce the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, and then immediately throw them into the bit bucket
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The bit bucket is supposedly the place where old bits are kept.
 On some systems, the programmer has to manually empty it now and then.
 Fortunately, Coffee\SpecialChar \-
Script comes with a fully-automatic bit-recycling system.
\end_layout

\end_inset

.
 This leaves no impression on the world at all, and is not a side effect.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
How does a program keep an internal state? How does it remember things?
 We have seen how to produce new values from old values, but this does not
 change the old values, and the new value has to be immediately used or
 it will dissipate again.
 To catch and hold values, Coffee\SpecialChar \-
Script provides a thing called a variable
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
variable
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

caught = 5 * 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A variable always has a name, and it can point at a value, holding on to
 it.
 The statement above creates a variable called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

caught
\end_layout

\end_inset

 and uses it to grab hold of the number that is produced by multiplying
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

5
\end_layout

\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

5
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
After running the above program, you can type the word 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

caught
\end_layout

\end_inset

 into the console, and it will retrieve the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

25
\end_layout

\end_inset

 for you.
 The name of a variable is used to fetch its value.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

caught + 1
\end_layout

\end_inset

 also works.
 A variable name can be used as an expression, and thus can be part of bigger
 expressions.
\end_layout

\begin_layout Standard
Assigning a value to a new variable name with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=
\end_layout

\end_inset

 operator, creates the new variable.
 Variable names can be almost every word, but they may not include spaces.
 Digits can be part of variable names, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch22
\end_layout

\end_inset

 is a valid name, but the name must not start with one.
 The characters 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 and 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 can be used in names as if they were letters, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$_$
\end_layout

\end_inset

 is a correct variable name.
\end_layout

\begin_layout Standard
When a variable points at a value, that does not mean it is tied to that
 value forever.
 At any time, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=
\end_layout

\end_inset

 operator can be used on existing variables to yank them away from their
 current value and make them point to a new one.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

caught = 4 * 4
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
You should imagine variables as tentacles, rather than boxes.
 They do not 
\emph on
contain
\emph default
 values, they 
\emph on
grasp
\emph default
 them — two variables can refer to the same value.
 Only the values that the program still has a hold on can be accessed by
 it.
 When you need to remember something, you grow a tentacle to hold on to
 it, or re-attach one of your existing tentacles to a new value: To remember
 the amount of dollars that Luigi still owes you, you could do\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

luigiDebt = 140
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, every time Luigi pays something back, this amount can be decremented
 by giving the variable a new number:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

luigiDebt = luigiDebt - 35
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The collection of variables and their values that exist at a given time
 is called the environment
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
environment
\end_layout

\end_inset

.
 When a program starts up, this environment is not empty.
 It always contains a number of standard variables.
 When you use 
\begin_inset listings
lstparams "language=bash,showstringspaces=false"
inline true
status open

\begin_layout Plain Layout

coffee
\end_layout

\end_inset

 to execute a Coffee\SpecialChar \-
Script program or run the interactive environment with
 
\begin_inset listings
lstparams "language=bash,showstringspaces=false"
inline true
status open

\begin_layout Plain Layout

coffee -r ./prelude
\end_layout

\end_inset

 then the environment is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

global
\end_layout

\end_inset

.
 You can view it by typing: 
\begin_inset Formula $\rightarrow\!\mid$
\end_inset

 / 
\begin_inset Quotes els
\end_inset

Tab
\begin_inset Quotes ers
\end_inset

.
 When your browser loads a page, it creates a new environment called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

window
\end_layout

\end_inset

 and attaches these standard values to it.
 The variables created and modified by programs on that page survive until
 the browser goes to a new page.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
A lot of the values provided by the standard environment have the type 
\begin_inset Quotes els
\end_inset

function
\begin_inset Quotes ers
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
function
\end_layout

\end_inset

.
 A function is a piece of program wrapped in a value.
 Generally, this piece of program does something useful, which can be evoked
 using the function value that contains it.
 In the development environment, the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
show
\end_layout

\end_inset

 holds a function that shows a message in the terminal or command line window.
 You can use it like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show 'Also, your hair is on fire.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
()
\end_layout

\end_inset

Executing the code in a function is called invoking
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
invoking
\end_layout

\end_inset

 or applying
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
applying
\end_layout

\end_inset

 it.
 The notation for doing this is the function name followed by parentheses
 or a comma separated list of values.
 Every expression that produces a function value can be invoked by putting
 parentheses after it.
 The parentheses can be left out when values are passed.
 The string value is given to the function, which uses it as the text to
 show in the console window.
 Values given to functions are called parameters
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
parameter
\end_layout

\end_inset

 or arguments
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
argument
\end_layout

\end_inset

.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 needs only one of them, but other functions might need a different number.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Showing a message is a side effect.
 A lot of functions are useful because of the side effects they produce.
 It is also possible for a function to produce a value, in which case it
 does not need to have a side effect to be useful.
 For example, there is a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.max
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Math.max
\end_layout

\end_inset

, which takes two arguments and gives back the biggest of the two:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show Math.max 2, 4
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Math.max
\end_layout

\end_inset

When a function produces a value, it is said to return
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
return
\end_layout

\end_inset

 it.
 Because things that produce values are always expressions in Coffee\SpecialChar \-
Script,
 function calls can be used as a part of bigger expressions:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show 100 + Math.max 7, 4
\end_layout

\begin_layout Plain Layout

show Math.max(7, 4) + 100
\end_layout

\begin_layout Plain Layout

show Math.max(7, 4 + 100)
\end_layout

\begin_layout Plain Layout

show Math.max 7, 4 + 100
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When parentheses are left out from a function call then Coffee\SpecialChar \-
Script implicitly
 inserts them stretching to the end of the line.
 In the example above it means that the first two lines gives the answer
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

107
\end_layout

\end_inset

 and the last two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

104
\end_layout

\end_inset

.
 So depending on your intention you may have to use parentheses to get the
 result you want.
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functions"

\end_inset

 discusses writing your own functions.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
As the previous examples illustrated, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 can be useful for showing the result of an expression.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 is not a standard Coffee\SpecialChar \-
Script function, browsers do not provide it for
 you, it is made available by the 
\family sans
Smooth Coffee\SpecialChar \-
Script
\family default
 prelude.
 When you are working in a web browser, you have a different environment
 and can instead use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

alert
\end_layout

\end_inset

 to pop up a dialog with a message.
\end_layout

\begin_layout Standard
We will continue in the Coffee\SpecialChar \-
Script environment.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
show
\end_layout

\end_inset

 tries to display its argument the way it would look in a program, which
 can give more information about the type of a value.
 In an interactive console, started with 
\begin_inset listings
lstparams "language=bash,showstringspaces=false"
inline true
status open

\begin_layout Plain Layout

coffee -r ./prelude
\end_layout

\end_inset

, you can explore the environment:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show process
\end_layout

\begin_layout Plain Layout

show console
\end_layout

\begin_layout Plain Layout

show _
\end_layout

\begin_layout Plain Layout

show show
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What the output means is not so important for now.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 is a tool that can give you details on the things in your programs, which
 can be handy later, if something does not behave the way you had expected.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The environment provided by browsers contains a few more functions for popping
 up windows.
 You can ask the user an OK/Cancel question using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

confirm
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
confirm
\end_layout

\end_inset

.
 This returns a boolean, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 if the user presses 
\begin_inset Quotes els
\end_inset

OK
\begin_inset Quotes ers
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 if he presses 
\begin_inset Quotes els
\end_inset

Cancel
\begin_inset Quotes ers
\end_inset

.
 The prelude has a similar 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

confirm
\end_layout

\end_inset

 function where the user is asked yes or no to the question.
\end_layout

\begin_layout Standard
Since the Coffee\SpecialChar \-
Script environment is optimized to run as a server, it does
 not wait for the user to reply.
 Instead it continues running the code following the function call.
 Eventually when the user has answered the question, then a function given
 as an argument is called with the answer.
 This piece of code involves a bit of magic, that will be explained in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functions"

\end_inset

.
 While it is more complicated for this use, we will in later chapters see
 that it makes perfect sense for a web application with many users.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

confirm 'Shall we, then?', (answer) -> show answer
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prompt
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
prompt
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prompt"

\end_inset

 can be used to ask an 
\begin_inset Quotes els
\end_inset

open
\begin_inset Quotes ers
\end_inset

 question.
 The first argument is the question, the second one is the text that the
 user starts with.
 A line of text can be typed into the window, and the function will — in
 a browser — return this as a string.
 As with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

confirm
\end_layout

\end_inset

 the prelude offers a similar function, that takes a third argument which
 will receive the answer.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

prompt 'Tell us everything you know.', '...',
\end_layout

\begin_layout Plain Layout

  (answer) -> show 'So you know: ' + answer
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
It is possible to give almost every variable in the environment a new value.
 This can be useful, but also dangerous.
 If you give 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

8
\end_layout

\end_inset

, you will not be able to show things anymore.
 Some functions like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

confirm
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prompt
\end_layout

\end_inset

 works when you run your program from a file, but interact poorly with the
 interactive environment.
 Fortunately, you can stop a program with 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false"
inline true
status open

\begin_layout Plain Layout

CTRL-C
\end_layout

\end_inset

 and pick up where you left off.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
One-line programs are not very interesting.
 When you put more than one statement into a program, the statements are,
 predictably, executed one at a time, from top to bottom.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

prompt 'Pick a number', '', (answer) ->
\end_layout

\begin_layout Plain Layout

  theNumber = Number answer
\end_layout

\begin_layout Plain Layout

  show 'Your number is the square root of ' +
\end_layout

\begin_layout Plain Layout

    (theNumber * theNumber)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Number
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Number
\end_layout

\end_inset

 converts a value to a number, which is needed in this case because the
 answer from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prompt
\end_layout

\end_inset

 is a string value.
 There are similar functions called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
String
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Boolean
\end_layout

\end_inset

 which convert values to those types.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Consider a program that prints out all even numbers from 0 to 12.
 One way to write this is:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

show 0
\end_layout

\begin_layout Plain Layout

show 2
\end_layout

\begin_layout Plain Layout

show 4
\end_layout

\begin_layout Plain Layout

show 6
\end_layout

\begin_layout Plain Layout

show 8
\end_layout

\begin_layout Plain Layout

show 10
\end_layout

\begin_layout Plain Layout

show 12
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That works, but the idea of writing a program is to make something 
\emph on
less
\emph default
 work, not more.
 If we needed all even numbers below 1000, the above would be unworkable.
 What we need is a way to automatically repeat some code.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

currentNumber = 0
\end_layout

\begin_layout Plain Layout

while currentNumber <= 12
\end_layout

\begin_layout Plain Layout

  show currentNumber
\end_layout

\begin_layout Plain Layout

  currentNumber = currentNumber + 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may have seen 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
while
\end_layout

\end_inset

 in the 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Introduction"

\end_inset

 chapter.
 A statement starting with the word 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 creates a loop
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
loop
\end_layout

\end_inset

.
 A loop is a disturbance in the sequence of statements, it may cause the
 program to repeat some statements multiple times.
 In this case, the word 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 is followed by an expression, which is used to determine whether the loop
 will loop or finish.
 As long as the boolean value produced by this expression is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, the code in the loop is repeated.
 As soon as it is false, the program goes to the bottom of the loop and
 continues as normal.
\end_layout

\begin_layout Standard
The variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

currentNumber
\end_layout

\end_inset

 demonstrates the way a variable can track the progress of a program.
 Every time the loop repeats, it is incremented by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

, and at the beginning of every repetition, it is compared with the number
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

12
\end_layout

\end_inset

 to decide whether to keep on looping.
\end_layout

\begin_layout Standard
The third part of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 statement is another statement.
 This is the body
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
body
\end_layout

\end_inset

 of the loop, the action or actions that must take place multiple times.
 Indentation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
indentation
\end_layout

\end_inset

 is used to group statements into blocks
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
block
\end_layout

\end_inset

.
 To the world outside the block, a block counts as a single statement.
 In the example, this is used to include in the loop both the call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 and the statement that updates 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

currentNumber
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If we did not have to print the numbers, the program could have been:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

counter = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while counter <= 12 then counter = counter + 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter = counter + 2
\end_layout

\end_inset

 is the statement that forms the body of the loop.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

then
\end_layout

\end_inset

 keyword separates the boolean from the body, so both can be on the same
 line.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\family default
\size default
\emph default

\begin_inset CommandInset label
LatexCommand label
name "sub:Exercisepower2"

\end_inset


\end_layout

\begin_layout Plain Layout
Use the techniques shown so far to write a program that calculates and shows
 the value of 2
\begin_inset script superscript

\begin_layout Plain Layout
10
\end_layout

\end_inset

 (2 to the 10th power).
 You are, obviously, not allowed to use a cheap trick like just writing
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2 * 2 * ...
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
If you are having trouble with this, try to see it in terms of the even-numbers
 example.
 The program must perform an action a certain amount of times.
 A counter variable with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 loop can be used for that.
 Instead of printing the counter, the program must multiply something by
 2.
 This something should be another variable, in which the result value is
 built up.
\end_layout

\begin_layout Plain Layout
Do not worry if you do not quite see how this would work yet.
 Even if you perfectly understand all the techniques this chapter covers,
 it can be hard to apply them to a specific problem.
 Reading and writing code will help develop a feeling for this, so study
 the solution, and try the next exercise.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\family default
\size default
\emph default

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

result = 1
\end_layout

\begin_layout Plain Layout

counter = 0
\end_layout

\begin_layout Plain Layout

while counter < 10
\end_layout

\begin_layout Plain Layout

  result = result * 2
\end_layout

\begin_layout Plain Layout

  counter = counter + 1
\end_layout

\begin_layout Plain Layout

show result
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The counter could also start at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 and check for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<= 10
\end_layout

\end_inset

, but, for reasons that will become apparent later on, it is a good idea
 to get used to counting from 0.
\end_layout

\begin_layout Plain Layout
Obviously, your own solutions are not required to be precisely the same
 as mine.
 They should work.
 And if they are very different, make sure you also understand my solution.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
With some slight modifications, the solution to the previous exercise can
 be made to draw a triangle.
 And when I say 
\begin_inset Quotes els
\end_inset

draw a triangle
\begin_inset Quotes ers
\end_inset

 I mean 
\begin_inset Quotes els
\end_inset

print out some text that almost looks like a triangle when you squint
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Plain Layout
Print out ten lines.
 On the first line there is one 
\begin_inset Quotes els
\end_inset

#
\begin_inset Quotes ers
\end_inset

 character.
 On the second there are two.
 And so on.
\end_layout

\begin_layout Plain Layout
How does one get a string with X 
\begin_inset Quotes els
\end_inset

#
\begin_inset Quotes ers
\end_inset

 characters in it? One way is to build it every time it is needed with an
 
\begin_inset Quotes els
\end_inset

inner loop
\begin_inset Quotes ers
\end_inset

 — a loop inside a loop.
 A simpler way is to reuse the string that the previous iteration of the
 loop used, and add one character to it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\family default
\size default
\emph default

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

line = ''
\end_layout

\begin_layout Plain Layout

counter = 0
\end_layout

\begin_layout Plain Layout

while counter < 10
\end_layout

\begin_layout Plain Layout

  line = line + '#'
\end_layout

\begin_layout Plain Layout

  show line
\end_layout

\begin_layout Plain Layout

  counter = counter + 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You will have noticed the spaces I put in front of some statements.
 These are required: The level of indentation decides which block a line
 belongs to.
 The role of the indentation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
indentation
\end_layout

\end_inset

 inside blocks is to make the structure of the code clearer to a reader.
 Because new blocks can be opened inside other blocks, it can become hard
 to see where one block ends and another begins if they were not indented.
 When lines are indented, the visual shape of a program corresponds to the
 shape of the blocks inside it.
 I like to use two spaces for every open block, but tastes differ.
 If a line becomes too long, then you can split it between two words or
 place a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash

\end_layout

\end_inset

 at the end of the line and continue on the next.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The uses of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 we have seen so far all show the same pattern.
 First, a 
\begin_inset Quotes els
\end_inset

counter
\begin_inset Quotes ers
\end_inset

 variable is created.
 This variable tracks the progress of the loop.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 itself contains a check, usually to see whether the counter has reached
 some boundary yet.
 Then, at the end of the loop body, the counter is updated.
\end_layout

\begin_layout Standard
A lot of loops fall into this pattern.
 For this reason, Coffee\SpecialChar \-
Script, and similar languages, also provide a slightly
 shorter and more comprehensive form:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for number in [0..12] by 2 then show number
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This program is exactly equivalent to the earlier even-number-printing example.
 The only change is that all the statements that are related to the 
\begin_inset Quotes els
\end_inset

state
\begin_inset Quotes ers
\end_inset

 of the loop are now on one line.
 The numbers in square brackets are a range
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
range
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[4..7]
\end_layout

\end_inset

, a list of numbers starting from the first number and going up one by one
 to the last.
 A range with two dots includes the last number in the list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(4,5,6,7)
\end_layout

\end_inset

, with three dots 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[4...7]
\end_layout

\end_inset

 the last number is excluded 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(4,5,6)
\end_layout

\end_inset

.
 The amount of each step can be changed with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

by
\end_layout

\end_inset

 keyword.
 So 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[2..6] by 2
\end_layout

\end_inset

 gives the list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(2,4,6)
\end_layout

\end_inset

.
 Ranges can also decrement if the first number is largest, or involve negative
 numbers or floating point numbers.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

number
\end_layout

\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
for
\end_layout

\end_inset

 comprehension take on each successive value from the range during each
 turn through the loop.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

number
\end_layout

\end_inset

 value is then available in the loop body where it can be used in computations
 or as here in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show number
\end_layout

\end_inset

.
 In most cases this is shorter and clearer than a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 construction.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 comprehension can take on other forms as well.
 One is that the body of the loop can be given before the for statement.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# For with indented body
\end_layout

\begin_layout Plain Layout

for number in [0..12] by 2
\end_layout

\begin_layout Plain Layout

  show number
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# For with prepended body
\end_layout

\begin_layout Plain Layout

show number for number in [0..12] by 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The lines that starts with 
\begin_inset Quotes els
\end_inset

#
\begin_inset Quotes ers
\end_inset

 in the previous example might have looked a bit suspicious to you.
 It is often useful to include extra text in a program.
 The most common use for this is adding some explanations in human language
 to a program.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# The variable counter, which is about to be defined,
\end_layout

\begin_layout Plain Layout

# is going to start with a value of 0, which is zero.
\end_layout

\begin_layout Plain Layout

counter = 0
\end_layout

\begin_layout Plain Layout

# Now, we are going to loop, hold on to your hat.
\end_layout

\begin_layout Plain Layout

while  counter < 100 # counter is less than one hundred
\end_layout

\begin_layout Plain Layout

  ###
\end_layout

\begin_layout Plain Layout

  Every time we loop, we INCREMENT the value of counter
\end_layout

\begin_layout Plain Layout

  Seriously, we just add one to it.
\end_layout

\begin_layout Plain Layout

  ###
\end_layout

\begin_layout Plain Layout

  counter++
\end_layout

\begin_layout Plain Layout

# And then, we are done.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This kind of text is called a comment
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
comment
\end_layout

\end_inset

.
 The rules are like this: 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

#
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 starts a comment, which goes on until the end of the line.
 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

###
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 starts another kind of comment that goes on until a 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

###
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 is found so it can stretch over multiple lines.
\end_layout

\begin_layout Standard
As you can see, even the simplest programs can be made to look big, ugly,
 and complicated by simply adding a lot of comments to them.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
I have been using some rather odd capitalisation
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
capitalisation
\end_layout

\end_inset

 in some variable names.
 Because you can not have spaces in these names — the computer would read
 them as two separate variables — your choices for a name that is made of
 several words are more or less limited to the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  fuzzylittleturtle                 FuzzyLittleTurtle
\end_layout

\begin_layout Plain Layout

  fuzzy_little_turtle               fuzzyLittleTurtle
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first one is hard to read.
 Personally, I like the one with the underscores, though it is a little
 painful to type.
 However, since Coffee\SpecialChar \-
Script evolved from Java\SpecialChar \-
Script, most Coffee\SpecialChar \-
Script
 programmers follow the Java\SpecialChar \-
Script convention with the last one.
 Its the one used by the standard Java\SpecialChar \-
Script functions.
 It is not hard to get used to little things like that, so I will just follow
 the crowd and capitalise the first letter of every word after the first.
\end_layout

\begin_layout Standard
In a few cases, such as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Number
\end_layout

\end_inset

 function, the first letter of a variable is also capitalised.
 This was done to mark this function as a constructor.
 What a constructor is will become clear in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

.
 For now, the important thing is not to be bothered by this apparent lack
 of consistency.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Note that names that have a special meaning, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 may not be used as variable names.
 These are called keywords
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
keyword
\end_layout

\end_inset

.
 There are also a number of 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
reserved words
\end_layout

\end_inset

words which are 
\begin_inset Quotes els
\end_inset

reserved for use
\begin_inset Quotes ers
\end_inset

 in future versions of Java\SpecialChar \-
Script and Coffee\SpecialChar \-
Script.
 These are also officially not allowed to be used as variable names, though
 some environments do allow them.
 The full list in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Reserved-Words"

\end_inset

 is rather long.
\end_layout

\begin_layout Standard
Do not worry about memorising these for now, but remember that this might
 be the problem when something does not work as expected.
 In my experience, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

char
\end_layout

\end_inset

 (to store a one-character string) and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
class
\end_layout

\end_inset

 are the most common names to accidentally use.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Rewrite the solutions of the previous two exercises to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

result = 1
\end_layout

\begin_layout Plain Layout

for counter in [0...10]
\end_layout

\begin_layout Plain Layout

  result = result * 2
\end_layout

\begin_layout Plain Layout

show result
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Note the use of the exclusive range and that — as required by Coffee\SpecialChar \-
Script
 — the statement in the loop is indented two spaces which make it clear
 that it 
\begin_inset Quotes els
\end_inset

belongs
\begin_inset Quotes ers
\end_inset

 to the line above it.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

line = ''
\end_layout

\begin_layout Plain Layout

for counter in [0...10]
\end_layout

\begin_layout Plain Layout

  line = line + '#'
\end_layout

\begin_layout Plain Layout

  show line
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
+=
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
-=
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
/=
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
*=
\end_layout

\end_inset

A program often needs to 
\begin_inset Quotes els
\end_inset

update
\begin_inset Quotes ers
\end_inset

 a variable with a value that is based on its previous value.
 For example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter = counter + 1
\end_layout

\end_inset

.
 Coffee\SpecialChar \-
Script provides a shortcut for this: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter += 1
\end_layout

\end_inset

.
 This also works for many other operators, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result *= 2
\end_layout

\end_inset

 to double the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter -= 1
\end_layout

\end_inset

 to count downwards.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter++
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter--
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
++
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
--
\end_layout

\end_inset

 are shorter versions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter += 1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter -= 1
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Loops are said to affect the control flow
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
control flow
\end_layout

\end_inset

 of a program.
 They change the order in which statements are executed.
 In many cases, another kind of flow is useful: skipping statements.
\end_layout

\begin_layout Standard
We want to show all numbers between 0 and 20 which are divisible both by
 3 and by 4.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for counter in [0..20]
\end_layout

\begin_layout Plain Layout

  if counter % 3 == 0 and counter % 4 == 0
\end_layout

\begin_layout Plain Layout

    show counter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The keyword 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
if
\end_layout

\end_inset

 is not too different from the keyword 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

: It checks the condition it is given, and executes the statement after
 it based on this condition.
 But it does this only once, so that the statement is executed zero or one
 time.
\end_layout

\begin_layout Standard
The trick with the modulo (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

%
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
%
\end_layout

\end_inset

) operator is an easy way to test whether a number is divisible by another
 number.
 If it is, the remainder of their division, which is what modulo gives you,
 is zero.
\end_layout

\begin_layout Standard
If we wanted to print all of the numbers between 0 and 20, but put parentheses
 around the ones that are not divisible by 4, we can do it like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for counter in [0..20]
\end_layout

\begin_layout Plain Layout

  if counter % 4 == 0
\end_layout

\begin_layout Plain Layout

    show counter
\end_layout

\begin_layout Plain Layout

  if counter % 4 != 0
\end_layout

\begin_layout Plain Layout

    show '(' + counter + ')'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But now the program has to determine whether 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter
\end_layout

\end_inset

 is divisible by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

4
\end_layout

\end_inset

 two times.
 The same effect can be gotten by appending an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 part after an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statement.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
else
\end_layout

\end_inset

 statement is executed only when the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

s condition is false.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for counter in [0..20]
\end_layout

\begin_layout Plain Layout

  if counter % 4 == 0
\end_layout

\begin_layout Plain Layout

    show counter
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    show '(' + counter + ')'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To stretch this trivial example a bit further, we now want to print these
 same numbers, but add two stars after them when they are greater than 15,
 one star when they are greater than 10 (but not greater than 15), and no
 stars otherwise.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for counter in [0..20]
\end_layout

\begin_layout Plain Layout

  if counter > 15
\end_layout

\begin_layout Plain Layout

    show counter + '**'
\end_layout

\begin_layout Plain Layout

  else if counter > 10
\end_layout

\begin_layout Plain Layout

    show counter + '*'
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    show counter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This demonstrates that you can chain 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statements together.
 In this case, the program first looks if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter
\end_layout

\end_inset

 is greater than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

15
\end_layout

\end_inset

.
 If it is, the two stars are printed and the other tests are skipped.
 If it is not, we continue to check if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter
\end_layout

\end_inset

 is greater than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

.
 Only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter
\end_layout

\end_inset

 is also not greater than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

 does it arrive at the last 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 statement.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a program to ask yourself, using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prompt
\end_layout

\end_inset

, what the value of 2 + 2 is.
 If the answer is 
\begin_inset Quotes els
\end_inset

4
\begin_inset Quotes ers
\end_inset

, use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 to say something praising.
 If it is 
\begin_inset Quotes els
\end_inset

3
\begin_inset Quotes ers
\end_inset

 or 
\begin_inset Quotes els
\end_inset

5
\begin_inset Quotes ers
\end_inset

, say 
\begin_inset Quotes els
\end_inset

Almost!
\begin_inset Quotes ers
\end_inset

.
 In other cases, say something mean.
 Refer back to page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "prompt"

\end_inset

 for the little bit of magic needed with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prompt
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

prompt 'You! What is the value of 2 + 2?', '',
\end_layout

\begin_layout Plain Layout

  (answer) ->
\end_layout

\begin_layout Plain Layout

    if answer == '4'
\end_layout

\begin_layout Plain Layout

      show 'You must be a genius or something.'
\end_layout

\begin_layout Plain Layout

    else if answer == '3' || answer == '5'
\end_layout

\begin_layout Plain Layout

      show 'Almost!'
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      show 'You are an embarrassment.'
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The logic tests in a program can become complicated.
 To help write conditions clearly Coffee\SpecialChar \-
Script provides a couple of variations
 on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statement: The body of an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statement can be placed before the condition.
 And an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if not
\end_layout

\end_inset

 can be written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unless
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
unless
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fun = on
\end_layout

\begin_layout Plain Layout

show 'The show is on!' unless fun is off
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
When a loop does not always have to go all the way through to its end, the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
break
\end_layout

\end_inset

 keyword can be useful.
 It immediately jumps out of the current loop, continuing after it.
 This program finds the first number that is greater than 20 and divisible
 by 7:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

current = 20
\end_layout

\begin_layout Plain Layout

loop
\end_layout

\begin_layout Plain Layout

  if current % 7 == 0
\end_layout

\begin_layout Plain Layout

    break
\end_layout

\begin_layout Plain Layout

  current++
\end_layout

\begin_layout Plain Layout

show current
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

loop
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
loop
\end_layout

\end_inset

 construct does not have a part that checks for the end of the loop.
 It is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while true
\end_layout

\end_inset

.
 This means that it is dependant on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 statement inside it to ever stop.
 The same program could also have been written as simply\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

current = 20
\end_layout

\begin_layout Plain Layout

current++ until current % 7 == 0
\end_layout

\begin_layout Plain Layout

show current
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, the body of the loop comes before the loop test.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

until
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
until
\end_layout

\end_inset

 keyword is similar to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unless
\end_layout

\end_inset

 keyword, but translates into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while not
\end_layout

\end_inset

.
 The only effect of the loop is to increment the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

current
\end_layout

\end_inset

 to its desired value.
 But I needed an example that uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

, so pay attention to the first version too.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Pick a lucky number from 1 to 6 then keep rolling a simulated die, until
 your lucky number comes up.
 Count the number of rolls.
 Use a loop and optionally a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

.
 Casting a die can be simulated with: 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

roll = Math.floor Math.random() * 6 + 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

loop
\end_layout

\end_inset

 is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while true
\end_layout

\end_inset

 and both can be used to create a loop that does not end on its own account.
 Writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while true
\end_layout

\end_inset

 is a useful trick but a bit silly, you ask the program to loop as long
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, so the preferred way is to write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

loop
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

luckyNumber = 5 # Choose from 1 to 6
\end_layout

\begin_layout Plain Layout

show "Your lucky number is #{luckyNumber}"
\end_layout

\begin_layout Plain Layout

count = 0
\end_layout

\begin_layout Plain Layout

loop
\end_layout

\begin_layout Plain Layout

  show roll = Math.floor Math.random() * 6 + 1
\end_layout

\begin_layout Plain Layout

  count++
\end_layout

\begin_layout Plain Layout

  if roll is luckyNumber then break
\end_layout

\begin_layout Plain Layout

show "Luck took #{count} roll(s)"
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Another solution, arguably nicer, without 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 but abusing statistics:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

luckyNumber = 3 # Choose from 1 to 6
\end_layout

\begin_layout Plain Layout

show 'Your lucky number is ' + luckyNumber
\end_layout

\begin_layout Plain Layout

count = 0
\end_layout

\begin_layout Plain Layout

until roll is luckyNumber
\end_layout

\begin_layout Plain Layout

  show roll = Math.floor Math.random() * 6 + 1
\end_layout

\begin_layout Plain Layout

  count++
\end_layout

\begin_layout Plain Layout

show 'You are lucky ' +
\end_layout

\begin_layout Plain Layout

    Math.floor(100/count) + '% of the time'
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the second solution to the previous exercise 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

roll
\end_layout

\end_inset

 has not been set to a value the first time through the loop.
 It is only assigned a value in the next statement.
 What happens when you take the value of this variable?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show mysteryVariable
\end_layout

\begin_layout Plain Layout

mysteryVariable = 'nothing'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In terms of tentacles, this variable ends in thin air, it has nothing to
 grasp.
 When you ask for the value of an empty place, you get a special value named
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
undefined
\end_layout

\end_inset

.
 Functions which do not return an interesting value, such as the built-in
 function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

console.log
\end_layout

\end_inset

 also return an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 value.
 Most things in Coffee\SpecialChar \-
Script return a value, even most statements.
 The prelude function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 return the value it is given, so it can be used within expressions.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show console.log 'I am a side effect.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is also a similar value, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
null
\end_layout

\end_inset

, whose meaning is 
\begin_inset Quotes els
\end_inset

this variable is defined, but it does not have a value
\begin_inset Quotes ers
\end_inset

.
 The difference in meaning between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 is mostly academic, and usually not very interesting.
 In practical programs, it is often necessary to check whether something
 
\begin_inset Quotes els
\end_inset

has a value
\begin_inset Quotes ers
\end_inset

.
 In these cases, the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

something?
\end_layout

\end_inset

 may be used, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
?
\end_layout

\end_inset

 is called the existential operator
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
existential operator
\end_layout

\end_inset

.
 It returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 unless something is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

.
 It also comes in an existential assignment form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?=
\end_layout

\end_inset

 which will only assign to a variable that is either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show iam ? undefined
\end_layout

\begin_layout Plain Layout

iam ?= 'I want to be'
\end_layout

\begin_layout Plain Layout

show iam
\end_layout

\begin_layout Plain Layout

iam ?= 'I am already'
\end_layout

\begin_layout Plain Layout

show iam if iam?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Which brings us to another subject\SpecialChar \ldots{}
 If you have been exposed to Java\SpecialChar \-
Script
 then you know that comparisons of different types can be tricky.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show false == 0
\end_layout

\begin_layout Plain Layout

show '' == 0
\end_layout

\begin_layout Plain Layout

show '5' == 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type conversion
\end_layout

\end_inset

In Java\SpecialChar \-
Script all these give the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 — not so in Coffee\SpecialChar \-
Script where they are all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 When comparing values that have different types, you have to convert them
 into compatible types first.
 We saw this earlier with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Number
\end_layout

\end_inset

 so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Number('5') == 5
\end_layout

\end_inset

 gives 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 The behaviour of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 in Coffee\SpecialChar \-
Script is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

===
\end_layout

\end_inset

 in Java\SpecialChar \-
Script.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show `null === undefined`
\end_layout

\begin_layout Plain Layout

show `false === 0`
\end_layout

\begin_layout Plain Layout

show `'' === 0`
\end_layout

\begin_layout Plain Layout

show `'5' === 5`
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All these are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 You can embed Java\SpecialChar \-
Script
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
embedded JavaScript
\end_layout

\end_inset

 in Coffee\SpecialChar \-
Script by surrounding the Java\SpecialChar \-
Script code with backquotes
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
backquotes
\end_layout

\end_inset

.
 Using Java\SpecialChar \-
Script when you have Coffee\SpecialChar \-
Script is similar to embedding assembly
 language in a high-level language.
 It should be something you very rarely need to do.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
There are some other situations that cause automatic type conversions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type conversion
\end_layout

\end_inset

 to happen.
 If you add a non-string value to a string, the value is automatically converted
 to a string before it is concatenated.
 If you multiply a number and a string, Coffee\SpecialChar \-
Script tries to make a number
 out of the string.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show 'Apollo' + 5
\end_layout

\begin_layout Plain Layout

show null + 'ify'
\end_layout

\begin_layout Plain Layout

show '5' * 5
\end_layout

\begin_layout Plain Layout

show 'strawberry' * 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last statement prints 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NaN
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
NaN
\end_layout

\end_inset

, which is a special value.
 It stands for 
\begin_inset Quotes els
\end_inset

not a number
\begin_inset Quotes ers
\end_inset

, and is of type number (which might sound a little contradictory).
 In this case, it refers to the fact that a strawberry is not a number.
 All arithmetic operations on the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NaN
\end_layout

\end_inset

 result in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NaN
\end_layout

\end_inset

, which is why multiplying it by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

5
\end_layout

\end_inset

, as in the example, still gives a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NaN
\end_layout

\end_inset

 value.
 Also, and this can be disorienting at times, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NaN == NaN
\end_layout

\end_inset

 equals 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

, checking whether a value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NaN
\end_layout

\end_inset

 can be done with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isNaN
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
isNaN
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard
These automatic conversions can be very convenient, but they are also rather
 weird and error prone.
 Even though 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

 are both arithmetic operators, they behave completely different in the
 example.
 In my own code, I use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

 on non-strings a lot, but make it a point not to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

 and the other numeric operators on string values.
\end_layout

\begin_layout Standard
Converting a number to a string is always possible and straightforward,
 but converting a string to a number may not even work (as in the last line
 of the example).
 We can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Number
\end_layout

\end_inset

 to explicitly convert the string to a number, making it clear that we might
 run the risk of getting a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NaN
\end_layout

\end_inset

 value.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show Number('5') * 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
When we discussed the boolean operators 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&&
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||
\end_layout

\end_inset

 earlier, I claimed they produced boolean values.
 This turns out to be a bit of an oversimplification.
 If you apply them to boolean values, they will indeed return booleans.
 But they can also be applied to other kinds of values, in which case they
 will return one of their arguments.
\end_layout

\begin_layout Standard
What 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
||
\end_layout

\end_inset

 really does is this: It looks at the value to the left of it first.
 If converting this value to a boolean would produce 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, it returns this left value, and otherwise it returns the one on its right.
 Check for yourself that this does the correct thing when the arguments
 are booleans.
 Why does it work like that? It turns out this is very practical.
 Consider this example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

prompt 'What is your name?', '',
\end_layout

\begin_layout Plain Layout

  (input) ->
\end_layout

\begin_layout Plain Layout

    show 'Well hello ' + (input || 'dear')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the user presses 
\begin_inset Formula $\hookleftarrow$
\end_inset

 / 
\begin_inset Quotes els
\end_inset

Enter
\begin_inset Quotes ers
\end_inset

 without giving a name, the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

input
\end_layout

\end_inset

 will hold the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

''
\end_layout

\end_inset

.
 This would give 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 when converted to a boolean.
 The expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

input || 'dear'
\end_layout

\end_inset

 can in this case be read as 
\begin_inset Quotes els
\end_inset

the value of the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

input
\end_layout

\end_inset

, or else the string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'dear'
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

.
 It is an easy way to provide a 
\begin_inset Quotes els
\end_inset

fallback
\begin_inset Quotes ers
\end_inset

 value.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&&
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
&&
\end_layout

\end_inset

 operator works similarly, but the other way around.
 When the value to its left is something that would give 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 when converted to a boolean, it returns that value, and otherwise it returns
 the value on its right.
\end_layout

\begin_layout Standard
Another property of these two operators is that the expression to their
 right is only evaluated when necessary.
 In the case of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true || X
\end_layout

\end_inset

, no matter what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 is, the result will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 is never evaluated, and if it has side effects they never happen.
 The same goes for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false && X
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

false || alert 'I am happening!'
\end_layout

\begin_layout Plain Layout

true  || alert 'Not me.'
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Functions
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Functions"

\end_inset


\end_layout

\begin_layout Standard
A program often needs to do the same thing in different places.
 Repeating all the necessary statements every time is tedious and error-prone.
 It would be better to put them in one place, and have the program take
 a detour through there whenever necessary.
 This is what functions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
function
\end_layout

\end_inset

 were invented for: They are canned code that a program can go through whenever
 it wants.
 Putting a string on the screen requires quite a few statements, but when
 we have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 function we can just write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show 'Aleph'
\end_layout

\end_inset

 and be done with it.
\end_layout

\begin_layout Standard
To view functions merely as canned chunks of code does not do them justice
 though.
 When needed, they can play the role of pure functions, algorithms, indirections
, abstractions, decisions, modules, continuations, data structures, and
 more.
 Being able to effectively use functions is a necessary skill for any kind
 of serious programming.
 This chapter provides an introduction into the subject, 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

 discusses the subtleties of functions in more depth.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pure function
\end_layout

\end_inset

Pure functions, for a start, are the things that were called functions in
 the mathematics classes that I hope you have been subjected to at some
 point in your life.
 Taking the cosine or the absolute value of a number is a pure function
 of one argument.
 Addition is a pure function of two arguments.
\end_layout

\begin_layout Standard
The defining properties of pure functions are that they always return the
 same value when given the same arguments, and never have side effects.
 They take some arguments, return a value based on these arguments, and
 do not monkey around with anything else.
\end_layout

\begin_layout Standard
In Coffee\SpecialChar \-
Script, addition is an operator, but it could be wrapped in a function
 like this (and as pointless as this looks, we will come across situations
 where it is actually useful):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

add = (a, b) -> a + b
\end_layout

\begin_layout Plain Layout

show add 2, 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add
\end_layout

\end_inset

 is the name of the function.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

 are the names of the two arguments.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a + b
\end_layout

\end_inset

 is the body of the function.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
->
\end_layout

\end_inset

The construct 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

 is used when creating a new function.
 When it is assigned to a variable name, the resulting function will be
 stored under this name.
 Before the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

 comes a list of argument
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
argument
\end_layout

\end_inset

 names in parentheses.
 If a function does not take any arguments, then the parentheses are not
 needed.
 After the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

 follows the body
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
body
\end_layout

\end_inset

 of the function.
 The body can follow the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

 on the same line or indented on the following line.
 
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
return
\end_layout

\end_inset

The last statement in a function determines its value.
 The keyword 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

, followed by an expression, can also be used to determine the value the
 function returns.
 When control comes across a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statement, it immediately jumps out of the current function and gives the
 returned value to the code that called the function.
 A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statement without an expression after it will cause the function to return
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A body can, of course, have more than one statement in it.
 Here is a function for computing powers (with positive, integer exponents):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

power = (base, exponent) ->
\end_layout

\begin_layout Plain Layout

  result = 1
\end_layout

\begin_layout Plain Layout

  for count in [0...exponent]
\end_layout

\begin_layout Plain Layout

    result *= base
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

show power 2, 10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you solved the exercise
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Exercisepower2"

\end_inset

, this technique for computing a power should look familiar.
 Creating a variable (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result
\end_layout

\end_inset

) and updating it are side effects.
 Did I not just say pure functions had no side effects? A variable created
 inside a function exists only inside the function.
 This is fortunate, or a programmer would have to come up with a different
 name for every variable he needs throughout a program.
 Because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result
\end_layout

\end_inset

 only exists inside 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

, the changes to it only last until the function returns, and from the perspecti
ve of code that calls it there are no side effects.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

, which returns the absolute value of the number it is given as its argument.
 The absolute value of a negative number is the positive version of that
 same number, and the absolute value of a positive number (or zero) is that
 number itself.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

absolute = (number) ->
\end_layout

\begin_layout Plain Layout

  if number < 0
\end_layout

\begin_layout Plain Layout

    -number
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    number
\end_layout

\begin_layout Plain Layout

show absolute -144
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pure functions have two very nice properties.
 They are easy to think about, and they are easy to re-use.
\end_layout

\begin_layout Standard
If a function is pure, a call to it can be seen as a thing in itself.
 When you are not sure that it is working correctly, you can test it by
 calling it directly from the console, which is simple because it does not
 depend on any context
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Technically, a pure function can not use the value of any external variables.
 These values might change, and this could make the function return a different
 value for the same arguments.
 In practice, the programmer may consider some variables 
\begin_inset Quotes els
\end_inset

constant
\begin_inset Quotes ers
\end_inset

 — they are not expected to change — and consider functions that use only
 constant variables pure.
 Variables that contain a function value are often good examples of constant
 variables.
\end_layout

\end_inset

.
 It is easy to make these tests automatic — to write a program that tests
 a specific function.
 Non-pure functions might return different values based on all kinds of
 factors, and have side effects that might be hard to test and think about.
\end_layout

\begin_layout Standard
Because pure functions are self-sufficient, they are likely to be useful
 and relevant in a wider range of situations than non-pure ones.
 Take 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

, for example.
 This function
\begin_inset Quotes ers
\end_inset

s usefulness depends on the presence of a special place on the screen for
 printing output.
 If that place is not there, the function is useless.
 We can imagine a related function, let
\begin_inset Quotes ers
\end_inset

s call it 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

format
\end_layout

\end_inset

, that takes a value as an argument and returns a string that represents
 this value.
 This function is useful in more situations than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Of course, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

format
\end_layout

\end_inset

 does not solve the same problem as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

, and no pure function is going to be able to solve that problem, because
 it requires a side effect.
 In many cases, non-pure functions are precisely what you need.
 In other cases, a problem can be solved with a pure function but the non-pure
 variant is much more convenient or efficient.
\end_layout

\begin_layout Standard
Thus, when something can easily be expressed as a pure function, write it
 that way.
 But never feel dirty for writing non-pure functions.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
testing
\end_layout

\end_inset

How do we make sure that a function gives the result that we expect? In
 the last exercise we tried with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-144
\end_layout

\end_inset

 and got the answer we wanted.
 For a simple function that is likely enough, but functions quickly become
 much more complicated and it becomes difficult to predict the output just
 from reading the program text.
 To reassure ourselves that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

 actually works many more test cases are needed.
 But typing test case after test case very quickly becomes very boring —
 so there must be a better way\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
The exercise described the properties that the function should have as:
 
\begin_inset Quotes els
\end_inset

The absolute value of a negative number is the positive version of that
 same number, and the absolute value of a positive number (or zero) is that
 number itself.
\begin_inset Quotes ers
\end_inset

 This description can be turned into properties that the computer can test
 for us.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

testAbsolute = (name, property) ->
\end_layout

\begin_layout Plain Layout

  qc.testPure absolute, [qc.arbInt], name, property
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

testAbsolute
\end_layout

\end_inset

 function calls on testPure in 
\family typewriter
qc
\family default
 — 
\family typewriter
qc
\family default
 stands for quick check
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Koen Claessen and John Hughes from Chalmers University of Technology created
 QuickCheck for Haskell and its ideas has since been reimplemented in many
 other programming languages.
 The 
\family typewriter
qc
\family default
 library is an implementation for JavaScript by Darrin Thompson.
 A CoffeeScript compatible version is included in the prelude.
\end_layout

\end_inset

 — and tells it in the first argument to test 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

.
 The next argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arbInt
\end_layout

\end_inset

, declare that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

 takes an arbitrary integer as its only argument.
 Don
\begin_inset Quotes ers
\end_inset

t worry about the brackets and dots, they will be explained in the next
 chapters.
 Calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

testAbsolute
\end_layout

\end_inset

 with a descriptive name and a property is all that is needed to tell what
 to expect of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

testAbsolute 'returns positive integers',
\end_layout

\begin_layout Plain Layout

  (c, arg, result) -> result >= 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First from the description of the function, clearly 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

 should return a value larger than or equal to zero.
 That is what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result >= 0
\end_layout

\end_inset

 in the property says.
 A property here is a function which is given three arguments; a test case
 (called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 is a reserved word), the argument that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

 was called with and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result
\end_layout

\end_inset

 it gave back.
 Based on these values the property then returns true or false depending
 on whether the function conformed to the property.
 
\end_layout

\begin_layout Standard
The description says: 
\begin_inset Quotes els
\end_inset

the absolute value of a positive number (or zero) is that number itself.
\begin_inset Quotes ers
\end_inset

 So this property only needs positive numbers, a call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

guard
\end_layout

\end_inset

 can to tell 
\family typewriter
qc
\family default
 to disregard values that are not positive.
 The property then checks that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result
\end_layout

\end_inset

 is the same as the argument.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

testAbsolute 'positive returns positive',
\end_layout

\begin_layout Plain Layout

  (c, arg, result) -> c.guard arg >= 0; result is arg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Almost the same goes for negative arguments, except we use unary minus in
 the property.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

testAbsolute 'negative returns positive',
\end_layout

\begin_layout Plain Layout

  (c, arg, result) -> c.guard arg < 0; result is -arg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So far only the desired properties of the function has been declared.
 No tests have been performed.
 Calling 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

qc.test()
\end_layout

\end_inset

 starts the testing process, 
\family typewriter
qc
\family default
 then generates test data and checks the properties.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

Pass: returns positive integers (pass=100, invalid=0)
\end_layout

\begin_layout Plain Layout

Pass: positive returns positive (pass=100, invalid=103)
\end_layout

\begin_layout Plain Layout

Pass: negative returns positive (pass=100, invalid=90)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That was nice.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

 has passed 300 test cases in the blink of an eye.
 The invalid counts comes from the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

guard
\end_layout

\end_inset

 calls that throw away test cases.
 If you want to see the test values then you can insert a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show c.args
\end_layout

\end_inset

 in the property.
\end_layout

\begin_layout Standard
So what does it look like if a test fails? The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 function from earlier in this chapter is a good candidate for a function
 that will fail to live up to expectations.
 We could reasonably expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 will behave the same as the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.pow
\end_layout

\end_inset

 function — but only for integers of course.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

qc.testPure power, [qc.arbInt, qc.arbInt],
\end_layout

\begin_layout Plain Layout

  'power == Math.pow for integers',
\end_layout

\begin_layout Plain Layout

  (c, base, exponent, result) ->
\end_layout

\begin_layout Plain Layout

    result == c.note Math.pow base, exponent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

testPure
\end_layout

\end_inset

 and describing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 as a function with two integer arguments does that.
 The property is then declaring that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 is the same as that from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.pow
\end_layout

\end_inset

.
 To see the value that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.pow
\end_layout

\end_inset

 returns, a call is made to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c.note
\end_layout

\end_inset

 which registers the value it is given.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fail: power == Math.pow for integers
\end_layout

\begin_layout Plain Layout

pass=9, invalid=0
\end_layout

\begin_layout Plain Layout

shrinkedArgs=3,-2,9,0.1111111111111111
\end_layout

\begin_layout Plain Layout

Failed case:
\end_layout

\begin_layout Plain Layout

[ -9,
\end_layout

\begin_layout Plain Layout

  -9,
\end_layout

\begin_layout Plain Layout

  -387420489,
\end_layout

\begin_layout Plain Layout

  -2.581174791713197e-9 ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That failed and 
\family typewriter
qc
\family default
 shows why.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-9
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-9
\end_layout

\end_inset

 in the last lines refer to the arguments that 
\family typewriter
qc
\family default
 generated for the test case.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-387420489
\end_layout

\end_inset

 is the result from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

.
 The last number is the value noted from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.pow
\end_layout

\end_inset

, it is a close approximation of the correct answer 
\begin_inset Formula $\textrm{-}9^{\textrm{-9}}=\textrm{-}\frac{1}{387420489}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

qc.testPure power, [qc.arbWholeNum, qc.arbWholeNum],
\end_layout

\begin_layout Plain Layout

  'power == Math.pow for positive integers',
\end_layout

\begin_layout Plain Layout

  (c, base, exponent, result) ->
\end_layout

\begin_layout Plain Layout

    result == c.note Math.pow base, exponent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The expectation that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 works for integers was too broad, but surely the functions will work the
 same for positive integers or what do you think? Instead of using guard
 to throw away test cases as before, the description of the arguments can
 be changed.
 Many different argument types are included in 
\family typewriter
qc
\family default
 (ranges, strings, dates, lists, \SpecialChar \ldots{}
) and there is also one for positive integers,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arbWholeNum
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fail: power == Math.pow for positive integers
\end_layout

\begin_layout Plain Layout

pass=28, invalid=0
\end_layout

\begin_layout Plain Layout

shrinkedArgs=9,18,150094635296999100,150094635296999140
\end_layout

\begin_layout Plain Layout

Failed case:
\end_layout

\begin_layout Plain Layout

[ 27,
\end_layout

\begin_layout Plain Layout

  27,
\end_layout

\begin_layout Plain Layout

  4.434264882430377e+38,
\end_layout

\begin_layout Plain Layout

  4.434264882430378e+38 ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Well it passed 28 tests before a test case for 
\begin_inset Formula $27^{27}$
\end_inset

 gave a difference on the last digit
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The ECMAScript standard allows these deviations for JavaScript and thus
 for CoffeeScript.
 If you should need unlimited precision integers then either use a third
 party library or a more mathematically inclined programming language such
 as Pure.
\end_layout

\end_inset

.
 Notice the line with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shrinkedArgs
\end_layout

\end_inset

.
 When a test fails then 
\family typewriter
qc
\family default
 tries to find a simpler test that reproduces the problem.
 Simpler can mean shorter strings, lists or in this case smaller numbers.
 So 
\family typewriter
qc
\family default
 found that there was a difference already for 
\begin_inset Formula $9^{18}$
\end_inset

.
 The result from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 ends with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

100
\end_layout

\end_inset

 and from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.pow
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

140
\end_layout

\end_inset

.
 So which is correct? None of them
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The LyX authoring environment used to create this book integrates with Maxima,
 the source of this result.
 Maxima is a computer algebra system that does symbolic and unlimited precision
 calculations.
 
\end_layout

\end_inset

: 
\begin_inset Formula $9^{18}=150094635296999121$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Copy the following program and modify the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

intensify
\end_layout

\end_inset

 until it passes the test properties.
 You can find descriptions of many 
\family typewriter
qc
\family default
 definitions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arbConst
\end_layout

\end_inset

 in the 
\family typewriter
qc
\family default
 reference 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:qc.js"

\end_inset

.
 From the prelude 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c.noteVerbose
\end_layout

\end_inset

 can help by both recording a result if the test fails and displaying values
 as they are tested.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require './prelude'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

intensify = (n) ->
\end_layout

\begin_layout Plain Layout

  2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

qc.testPure intensify, [qc.arbInt],
\end_layout

\begin_layout Plain Layout

  'intensify grows by 2 when positive',
\end_layout

\begin_layout Plain Layout

  (c, arg, result) ->
\end_layout

\begin_layout Plain Layout

    c.guard arg > 0
\end_layout

\begin_layout Plain Layout

    arg + 2 == result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

qc.testPure intensify, [qc.arbInt],
\end_layout

\begin_layout Plain Layout

  'intensify grows by 2 when negative',
\end_layout

\begin_layout Plain Layout

  (c, arg, result) ->
\end_layout

\begin_layout Plain Layout

    c.guard arg < 0
\end_layout

\begin_layout Plain Layout

    arg - 2 == result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

qc.testPure intensify, [qc.arbConst(0)],
\end_layout

\begin_layout Plain Layout

  'only non-zero intensify grows',
\end_layout

\begin_layout Plain Layout

  (c, arg, result) ->
\end_layout

\begin_layout Plain Layout

    result is 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

qc.test()
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

intensify = (n) ->
\end_layout

\begin_layout Plain Layout

  if n > 0
\end_layout

\begin_layout Plain Layout

    n + 2
\end_layout

\begin_layout Plain Layout

  else if n < 0
\end_layout

\begin_layout Plain Layout

    n - 2
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    n
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Writing test declarations before writing a function can be a good way of
 specifying it.
 The test declarations in these examples are much larger than the functions
 they are testing.
 In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Binary-Heaps"

\end_inset

 is a more realistic example of a class and tests for it.
 Declarative testing is well suited to testing algorithms and reusable libraries.
 There are many other test tools that you can choose depending on your preferenc
e and task
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Most JavaScript test tools are compatible with CoffeeScript or can easily
 be adapted.
\end_layout

\end_inset

.
 The main point here is that a reasonable level of testing is part of writing
 code.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Back to functions, they do not have to contain a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statement.
 If no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statement is encountered, the function returns the value of the last statement.
 The prelude function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 returns its argument so that it can be used inside expressions.
 If you want the function to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 then the last statement can be a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

yell = (message) ->
\end_layout

\begin_layout Plain Layout

  show message + '!!'
\end_layout

\begin_layout Plain Layout

  return
\end_layout

\begin_layout Plain Layout

yell 'Yow'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The names of the arguments of a function are available as variables inside
 it.
 They will refer to the values of the arguments the function is being called
 with, and like normal variables created inside a function, they do not
 exist outside it.
 Aside from the top-level environment
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
top-level environment
\end_layout

\end_inset

, there are smaller, local environments
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
local environment
\end_layout

\end_inset

 created by functions.
 When looking up a variable inside a function, the outer environment is
 checked first, and only if the variable does not exist there is it created
 in the local environment.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

dino = 'I am alive'
\end_layout

\begin_layout Plain Layout

reptile = 'I am A-OK'
\end_layout

\begin_layout Plain Layout

meteor = (reptile) ->
\end_layout

\begin_layout Plain Layout

  show reptile            # Argument
\end_layout

\begin_layout Plain Layout

  dino = 'I am extinct'
\end_layout

\begin_layout Plain Layout

  reptile = 'I survived'
\end_layout

\begin_layout Plain Layout

  possum = 'I am new'
\end_layout

\begin_layout Plain Layout

show dino                 # Outer
\end_layout

\begin_layout Plain Layout

meteor 'What happened?'
\end_layout

\begin_layout Plain Layout

show dino                 # Outer changed
\end_layout

\begin_layout Plain Layout

show reptile              # Outer unchanged
\end_layout

\begin_layout Plain Layout

try show possum catch e
\end_layout

\begin_layout Plain Layout

  show e.message          # Error undefined
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This makes it possible for arguments to a function to 
\begin_inset Quotes els
\end_inset

shadow
\begin_inset Quotes ers
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
shadow
\end_layout

\end_inset

 outer level variables that have the same name.
 The easiest way to deal with variables is to use unique names for variables
 throughout a file.
 In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Modularity"

\end_inset

 you will see that the top-level is not shared between files unless variables
 are specifically exported.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/environments.png
	lyxscale 60
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
So if the name of variable in an inner function exists in an outer environment
 then the variable is referring to the outer one, it is not a new definition.
 That is an expression like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

variable = 'something'
\end_layout

\end_inset

 may be a definition of a new variable or it may be an assignment to a previousl
y defined variable.
 As a matter of style, when you are using top-level variables then it makes
 sense to introduce them at the top of a file with a default value.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

variable = 'first'                    # Definition
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

showVariable = ->
\end_layout

\begin_layout Plain Layout

  show 'In showVariable, the variable holds: ' +
\end_layout

\begin_layout Plain Layout

        variable                      # second
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

test = ->
\end_layout

\begin_layout Plain Layout

  variable = 'second'                 # Assignment
\end_layout

\begin_layout Plain Layout

  show 'In test, the variable holds ' +
\end_layout

\begin_layout Plain Layout

       variable + '.'                 # second
\end_layout

\begin_layout Plain Layout

  showVariable()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show 'The variable is: ' + variable   # first
\end_layout

\begin_layout Plain Layout

test()
\end_layout

\begin_layout Plain Layout

show 'The variable is: ' + variable   # second
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The variables defined in the local environment are only visible to the code
 inside the function.
 If a function calls another function, the newly called function does not
 see the variables inside the first function.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

andHere = ->
\end_layout

\begin_layout Plain Layout

  try show aLocal                     # Not defined
\end_layout

\begin_layout Plain Layout

  catch e then show e.message
\end_layout

\begin_layout Plain Layout

isHere = ->
\end_layout

\begin_layout Plain Layout

  aLocal = 'aLocal is defined'
\end_layout

\begin_layout Plain Layout

  andHere()
\end_layout

\begin_layout Plain Layout

isHere()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, and this is a subtle but extremely useful phenomenon, when a function
 is defined 
\emph on
inside
\emph default
 another function, its local environment will be based on the local environment
 that surrounds it.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

isHere = ->
\end_layout

\begin_layout Plain Layout

  andHere = ->
\end_layout

\begin_layout Plain Layout

    try show aLocal                   # Is defined
\end_layout

\begin_layout Plain Layout

    catch e then show e.message
\end_layout

\begin_layout Plain Layout

  aLocal = 'aLocal is defined'
\end_layout

\begin_layout Plain Layout

  andHere()
\end_layout

\begin_layout Plain Layout

isHere()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Here is a special case that might surprise you:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

varWhich = 'top-level'
\end_layout

\begin_layout Plain Layout

parentFunction = ->
\end_layout

\begin_layout Plain Layout

  varWhich = 'local'
\end_layout

\begin_layout Plain Layout

  childFunction = ->
\end_layout

\begin_layout Plain Layout

    show varWhich
\end_layout

\begin_layout Plain Layout

  childFunction
\end_layout

\begin_layout Plain Layout

child = parentFunction()
\end_layout

\begin_layout Plain Layout

child()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

parentFunction
\end_layout

\end_inset

 
\emph on
returns
\emph default
 its internal function, and the code at the bottom calls this function.
 Even though 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

parentFunction
\end_layout

\end_inset

 has finished executing at this point, the local environment where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

variable
\end_layout

\end_inset

 has the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'local'
\end_layout

\end_inset

 still exists, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

childFunction
\end_layout

\end_inset

 still uses it.
 This phenomenon is called closure
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
closure
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
With scoping we can 
\begin_inset Quotes els
\end_inset

synthesise
\begin_inset Quotes ers
\end_inset

 functions.
 By using some of the variables from an enclosing function, an inner function
 can be made to do different things.
 Imagine we need a few different but similar functions, one that adds 2
 to its argument, one that adds 5, and so on.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

makeAddFunction = (amount) ->
\end_layout

\begin_layout Plain Layout

  add = (number) -> number + amount
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

addTwo = makeAddFunction 2
\end_layout

\begin_layout Plain Layout

addFive = makeAddFunction 5
\end_layout

\begin_layout Plain Layout

show addTwo(1) + addFive(1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
On top of the fact that different functions can contain variables of the
 same name without getting tangled up, these scoping rules also allow functions
 to call 
\emph on
themselves
\emph default
 without running into problems.
 A function that calls itself is called recursive.
 Recursion
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
recursion
\end_layout

\end_inset

 allows for some interesting definitions.
 When you define recursive functions the first thing you need is a stop
 condition, otherwise your recursive function becomes an elaborate but never
 ending loop.
 Look at this implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

powerRec = (base, exponent) ->
\end_layout

\begin_layout Plain Layout

  if exponent == 0
\end_layout

\begin_layout Plain Layout

    1
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    base * powerRec base, exponent - 1
\end_layout

\begin_layout Plain Layout

show 'power 3, 3 = ' + powerRec 3, 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is rather close to the way mathematicians define exponentiation, and
 to me it looks a lot nicer than the earlier version.
 It sort of loops, but there is no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

, or even a local side effect to be seen.
 By calling itself, the function produces the same effect.
 The stop condition is when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exponent
\end_layout

\end_inset

 becomes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exponent - 1
\end_layout

\end_inset

 ensures that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exponent
\end_layout

\end_inset

 gets closer to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

 for each call.
 Note the assumption that exponent is a positive integer, that should be
 clearly documented if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

powerRec
\end_layout

\end_inset

 was a part of a reusable library.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Does this elegance affect performance? There is only one way to know for
 sure: measure it.
 The timings below are from my machine, you should not rely much on those.
 CPU's, operating systems, compilers and interpreters in browsers all has
 an effect on performance, so measure in something that is as close to your
 target environment as possible.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

timeIt = (func) ->
\end_layout

\begin_layout Plain Layout

  start = new Date()
\end_layout

\begin_layout Plain Layout

  for i in [0...1000000] then func()
\end_layout

\begin_layout Plain Layout

  show "Timing: #{(new Date() - start)*0.001}s"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

timeIt -> p = add 9,18                # 0.042s
\end_layout

\begin_layout Plain Layout

timeIt -> p = Math.pow 9,18           # 0.049s
\end_layout

\begin_layout Plain Layout

timeIt -> p = power 9,18              # 0.464s
\end_layout

\begin_layout Plain Layout

timeIt -> p = powerRec 9,18           # 0.544s
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
efficiency
\end_layout

\end_inset

The dilemma of speed versus elegance
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
elegance
\end_layout

\end_inset

 is an interesting one.
 It not only occurs when deciding for or against recursion.
 In many situations, an elegant, intuitive, and often short solution can
 be replaced by a more convoluted but faster solution.
\end_layout

\begin_layout Standard
In the case of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 function above the un-elegant version is still sufficiently simple and
 easy to read.
 It does not make very much sense to replace it with the recursive version.
 Often, though, the concepts a program is dealing with get so complex that
 giving up some efficiency in order to make the program more straightforward
 becomes an attractive choice.
\end_layout

\begin_layout Standard
The basic rule, which has been repeated by many programmers and with which
 I wholeheartedly agree, is to not worry about efficiency until your program
 is provably too slow.
 When it is, find out which parts are too slow, and start exchanging elegance
 for efficiency in those parts.
\end_layout

\begin_layout Standard
Of course, the above rule does not mean one should start ignoring performance
 altogether.
 In many cases, like the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 function, not much simplicity is gained by the 
\begin_inset Quotes els
\end_inset

elegant
\begin_inset Quotes ers
\end_inset

 approach.
 In other cases, an experienced programmer can see right away that a simple
 approach is never going to be fast enough.
\end_layout

\begin_layout Standard
The reason I am making a big deal out of this is that surprisingly many
 programmers focus fanatically on efficiency, even in the smallest details.
 The result is bigger, more complicated, and often less correct programs,
 which take longer to write than their more straightforward equivalents
 and often run only marginally faster.
\end_layout

\begin_layout Standard
When you have a simple, correct implementation that is too slow, then you
 can use that as a reference implementation to test your improved version.
 The one thing you do need to consider up front is what kind of data structures
 and algorithms can handle the task at hand.
 There is a huge difference between searching in a list with ten items and
 searching in a list with millions of items.
 These kind of considerations are covered in more detail in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Searching"

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
But I was talking about recursion.
 A concept closely related to recursion is a thing called the stack
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
stack
\end_layout

\end_inset

.
 When a function is called, control is given to the body of that function.
 When that body returns, the code that called the function is resumed.
 While the body is running, the computer must remember the context from
 which the function was called, so that it knows where to continue afterwards.
 The place where this context is stored is called the stack.
\end_layout

\begin_layout Standard
The fact that it is called 
\begin_inset Quotes els
\end_inset

stack
\begin_inset Quotes ers
\end_inset

 has to do with the fact that, as we saw, a function body can again call
 a function.
 Every time a function is called, another context has to be stored.
 One can visualise this as a stack of contexts.
 Every time a function is called, the current context is thrown on top of
 the stack.
 When a function returns, the context on top is taken off the stack and
 resumed.
\end_layout

\begin_layout Standard
This stack requires space in the computer
\begin_inset Quotes ers
\end_inset

s memory to be stored.
 When the stack grows too big, the computer will give up with a message
 like 
\begin_inset Quotes eld
\end_inset

out of stack space
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

too much recursion
\begin_inset Quotes erd
\end_inset

.
 This is something that has to be kept in mind when writing recursive functions.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chicken = ->
\end_layout

\begin_layout Plain Layout

  show 'Lay an egg'
\end_layout

\begin_layout Plain Layout

  egg()
\end_layout

\begin_layout Plain Layout

egg     = ->
\end_layout

\begin_layout Plain Layout

  show 'Chick hatched'
\end_layout

\begin_layout Plain Layout

  chicken()
\end_layout

\begin_layout Plain Layout

try show chicken() + ' came first.'
\end_layout

\begin_layout Plain Layout

catch error then show error.message
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to demonstrating a very interesting way of writing a broken
 program, this example shows that a function does not have to call itself
 directly to be recursive.
 If it calls another function which (directly or indirectly) calls the first
 function again, it is still recursive.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 parts are covered in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Error-Handling"

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Recursion is not always just a less-efficient alternative to looping.
 Some problems are much easier to solve with recursion than with loops.
 Most often these are problems that require exploring or processing several
 
\begin_inset Quotes els
\end_inset

branch\SpecialChar \-
es
\begin_inset Quotes ers
\end_inset

, each of which might branch out again into more branches.
\end_layout

\begin_layout Standard
Consider this puzzle: By starting from the number 1 and repeatedly either
 adding 5 or multiplying by 3, an infinite amount of new numbers can be
 produced.
 How would you write a function that, given a number, tries to find a sequence
 of additions and multiplications that produce that number?
\end_layout

\begin_layout Standard
For example, the number 13 could be reached by first multiplying 1 by 3,
 and then adding 5 twice.
 The number 15 can not be reached at all.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

findSequence = (goal) ->
\end_layout

\begin_layout Plain Layout

  find = (start, history) ->
\end_layout

\begin_layout Plain Layout

    if start == goal
\end_layout

\begin_layout Plain Layout

      history
\end_layout

\begin_layout Plain Layout

    else if start > goal
\end_layout

\begin_layout Plain Layout

      null
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      find(start + 5, '(' + history + ' + 5)') ? 
\backslash

\end_layout

\begin_layout Plain Layout

      find(start * 3, '(' + history + ' * 3)')
\end_layout

\begin_layout Plain Layout

  find 1, '1'
\end_layout

\begin_layout Plain Layout

show findSequence 24
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the solution does not necessarily find the 
\emph on
shortest
\emph default
 sequence of operations, it is satisfied when it finds any sequence at all.
\end_layout

\begin_layout Standard
The inner 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

 function, by calling itself in two different ways, explores both the possibilit
y of adding 5 to the current number and of multiplying it by 3.
 When it finds the number, it returns the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

history
\end_layout

\end_inset

 string, which is used to record all the operators that were performed to
 get to this number.
 It also checks whether the current number is bigger than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

, because if it is, we should stop exploring this branch, it is not going
 to give us our number.
\end_layout

\begin_layout Standard
The use of the existential 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?
\end_layout

\end_inset

 operator in the example can be read as 
\begin_inset Quotes els
\end_inset

return the solution found by adding 5 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

start
\end_layout

\end_inset

, and if that fails, return the solution found by multiplying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

start
\end_layout

\end_inset

 by 3
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Usually when you define a function you assign it to a name that you can
 use to refer to it later.
 That is not required and sometimes it is not worthwhile to give a function
 a name, then you can use an anonymous function
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
anonymous function
\end_layout

\end_inset

 instead.
\end_layout

\begin_layout Standard
Like in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeAddFunction
\end_layout

\end_inset

 example we saw earlier:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

makeAddFunction = (amount) ->
\end_layout

\begin_layout Plain Layout

  (number) -> number + amount
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show makeAddFunction(11) 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the function named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add
\end_layout

\end_inset

 in the first version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeAddFunction
\end_layout

\end_inset

 was referred to only once, the name does not serve any purpose and we might
 as well directly return the function value.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

greaterThan
\end_layout

\end_inset

, which takes one argument, a number, and returns a function that represents
 a test.
 When this returned function is called with a single number as argument,
 it returns a boolean: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 if the given number is greater than the number that was used to create
 the test function, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 otherwise.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

greaterThan = (x) ->
\end_layout

\begin_layout Plain Layout

  (y) -> y > x
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

greaterThanTen = greaterThan 10
\end_layout

\begin_layout Plain Layout

show greaterThanTen 9
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Try the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

yell 'Hello', 'Good Evening', 'How do you do?'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yell
\end_layout

\end_inset

 defined earlier in this chapter only accepts one argument.
 Yet when you call it like this, the computer does not complain at all,
 but just ignores the other arguments.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

yell()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can, apparently, even get away with passing too few arguments.
 When an argument is not passed, its value inside the function is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In the next chapter, we will see a way in which a function body can get
 at the exact list of arguments that were passed to it.
 This can be useful, as it makes it possible to have a function accept any
 number of arguments.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

console.log
\end_layout

\end_inset

 makes use of this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

console.log 'R', 2, 'D', 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, the downside of this is that it is also possible to accidentally
 pass the wrong number of arguments to functions that expect a fixed amount
 of them and never be told about it.
\end_layout

\begin_layout Chapter
Data Structures: Objects and Arrays
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Data Structures
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Data-Structures"

\end_inset


\end_layout

\begin_layout Standard
This chapter will be devoted to solving a few simple problems.
 In the process, we will discuss two new types of values, arrays and objects,
 and look at some techniques related to them.
\end_layout

\begin_layout Standard
Consider the following situation: Your crazy aunt Emily, who is rumoured
 to have over fifty cats living with her (you never managed to count them),
 regularly sends you e-mails to keep you up to date on her exploits.
 They usually look like this:
\end_layout

\begin_layout Quote

\emph on
Dear nephew,
\end_layout

\begin_layout Quote

\emph on
Your mother told me you have taken up skydiving.
 Is this true? You watch yourself, young man! Remember what happened to
 my husband? And that was only from the second floor!
\end_layout

\begin_layout Quote

\emph on
Anyway, things are very exciting here.
 I have spent all week trying to get the attention of Mr.
 Drake, the nice gentleman who moved in next door, but I think he is afraid
 of cats.
 Or allergic to them? I am going to try putting Fat Igor on his shoulder
 next time I see him, very curious what will happen.
\end_layout

\begin_layout Quote

\emph on
Also, the scam I told you about is going better than expected.
 I have already gotten back five 
\begin_inset Quotes els
\end_inset

payments
\begin_inset Quotes ers
\end_inset

, and only one complaint.
 It is starting to make me feel a bit bad though.
 And you are right that it is probably illegal in some way.
\end_layout

\begin_layout Quote

\emph on
(
\emph default
\SpecialChar \ldots{}

\emph on
 etc 
\emph default
\SpecialChar \ldots{}

\emph on
)
\end_layout

\begin_layout Quote

\emph on
Much love,
\end_layout

\begin_layout Quote

\emph on
Aunt Emily
\end_layout

\begin_layout Quote

\emph on
died 27/04/2006: Black Leclère
\end_layout

\begin_layout Quote

\emph on
born 05/04/2006 (mother Lady Penelope): Red Lion, Doctor Hobbles the 3rd,
 Little Iroquois
\end_layout

\begin_layout Standard
To humour the old dear, you would like to keep track of the genealogy of
 her cats, so you can add things like 
\begin_inset Quotes eld
\end_inset

P.S.
 I hope Doctor Hobbles the 2nd enjoyed his birthday this Saturday!
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

How is old Lady Penelope doing? She
\begin_inset Quotes ers
\end_inset

s five years old now, isn
\begin_inset Quotes ers
\end_inset

t she?
\begin_inset Quotes erd
\end_inset

, preferably without accidentally asking about dead cats.
 You are in the possession of a large quantity of old e-mails from your
 aunt, and fortunately she is very consistent in always putting information
 about the cats
\begin_inset Quotes ers
\end_inset

 births and deaths at the end of her mails in precisely the same format.
\end_layout

\begin_layout Standard
You are hardly inclined to go through all those mails by hand.
 Fortunately, we were just in need of an example problem, so we will try
 to work out a program that does the work for us.
 For a start, we write a program that gives us a list of cats that are still
 alive after the last e-mail.
\end_layout

\begin_layout Standard
Before you ask, at the start of the correspondence, aunt Emily had only
 a single cat: Spot.
 (She was still rather conventional in those days.)
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/eyes.jpg
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Standard
It usually pays to have some kind of clue what one
\begin_inset Quotes ers
\end_inset

s program is going to do before starting to type.
 Here
\begin_inset Quotes ers
\end_inset

s a plan:
\end_layout

\begin_layout Enumerate
Start with a set of cat names that has only 
\begin_inset Quotes eld
\end_inset

Spot
\begin_inset Quotes erd
\end_inset

 in it.
\end_layout

\begin_layout Enumerate
Go over every e-mail in our archive, in chronological order.
\end_layout

\begin_layout Enumerate
Look for paragraphs that start with 
\begin_inset Quotes eld
\end_inset

born
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

died
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
Add the names from paragraphs that start with 
\begin_inset Quotes eld
\end_inset

born
\begin_inset Quotes erd
\end_inset

 to our set of names.
\end_layout

\begin_layout Enumerate
Remove the names from paragraphs that start with 
\begin_inset Quotes eld
\end_inset

died
\begin_inset Quotes erd
\end_inset

 from our set.
\end_layout

\begin_layout Standard
Where taking the names from a paragraph goes like this:
\end_layout

\begin_layout Enumerate
Find the colon in the paragraph.
\end_layout

\begin_layout Enumerate
Take the part after this colon.
\end_layout

\begin_layout Enumerate
Split this part into separate names by looking for commas.
\end_layout

\begin_layout Standard
It may require some suspension of disbelief to accept that aunt Emily always
 used this exact format, and that she never forgot or misspelled a name,
 but that is just how your aunt is.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
First, let me tell you about properties
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
properties
\end_layout

\end_inset

.
 A lot of Coffee\SpecialChar \-
Script values have other values associated with them.
 These associations are called properties.
 Every string has a property called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
length
\end_layout

\end_inset

, which refers to a number, the amount of characters in that string.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

Properties can be accessed in two ways:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

text = 'purple haze'
\end_layout

\begin_layout Plain Layout

show text['length']
\end_layout

\begin_layout Plain Layout

show text.length
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second way is a shorthand for the first, and it only works when the
 name of the property would be a valid variable name — when it does not
 have any spaces or symbols in it and does not start with a digit character.
\end_layout

\begin_layout Standard
Numbers, booleans, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

, and the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 do not have any properties.
 Trying to read properties from such a value produces an error.
 Try the following code, if only to get an idea about the kind of error-message
 you get in such a case (which, for some browsers, can be rather cryptic).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

nothing = null
\end_layout

\begin_layout Plain Layout

show nothing.length
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The properties of a string value can not be changed.
 There are quite a few more than just 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

, as we will see, but you are not allowed to add or remove any.
\end_layout

\begin_layout Standard
This is different with values of the type object
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
object
\end_layout

\end_inset

.
 Their main role is to hold other values.
 They have, you could say, their own set of tentacles in the form of properties.
 You are free to modify these, remove them, or add new ones.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
{}
\end_layout

\end_inset

An object can be written like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cat =
\end_layout

\begin_layout Plain Layout

  colour: 'grey'
\end_layout

\begin_layout Plain Layout

  name: 'Spot'
\end_layout

\begin_layout Plain Layout

  size: 46
\end_layout

\begin_layout Plain Layout

# Or: cat = {colour: 'grey', name: 'Spot', size: 46}
\end_layout

\begin_layout Plain Layout

cat.size = 47
\end_layout

\begin_layout Plain Layout

show cat.size
\end_layout

\begin_layout Plain Layout

delete cat.size
\end_layout

\begin_layout Plain Layout

show cat.size
\end_layout

\begin_layout Plain Layout

show cat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Like variables, each property attached to an object is labelled by a string.
 The first statement creates an object in which the property 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'colour'
\end_layout

\end_inset

 holds the string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'grey'
\end_layout

\end_inset

, the property 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'name'
\end_layout

\end_inset

 is attached to the string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'Spot'
\end_layout

\end_inset

, and the property 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'size'
\end_layout

\end_inset

 refers to the number 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

46
\end_layout

\end_inset

.
 The second statement gives the property named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 a new value, which is done in the same way as modifying a variable.
\end_layout

\begin_layout Standard
The keyword 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delete
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
delete
\end_layout

\end_inset

 cuts off properties.
 Trying to read a non-existent property gives the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If a property that does not yet exist is set with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 operator, it is added to the object.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

empty = {}
\end_layout

\begin_layout Plain Layout

empty.notReally = 1000
\end_layout

\begin_layout Plain Layout

show empty.notReally
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Properties whose names are not valid variable names have to be quoted when
 creating the object, and approached using brackets:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

thing = {'gabba gabba': 'hey', '5': 10}
\end_layout

\begin_layout Plain Layout

show thing['5']
\end_layout

\begin_layout Plain Layout

thing['5'] = 20
\end_layout

\begin_layout Plain Layout

show thing[2 + 3]
\end_layout

\begin_layout Plain Layout

delete thing['gabba gabba']
\end_layout

\begin_layout Plain Layout

show thing
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, the part between the brackets can be any expression.
 It is converted to a string to determine the property name it refers to.
 One can even use variables to name properties:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

propertyName = 'length'
\end_layout

\begin_layout Plain Layout

text = 'mainline'
\end_layout

\begin_layout Plain Layout

show text[propertyName]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
of
\end_layout

\end_inset

 can be used to test whether an object has a certain property.
 It produces a boolean.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chineseBox = {}
\end_layout

\begin_layout Plain Layout

chineseBox.content = chineseBox
\end_layout

\begin_layout Plain Layout

show 'content' of chineseBox
\end_layout

\begin_layout Plain Layout

show 'content' of chineseBox.content
\end_layout

\begin_layout Plain Layout

show chineseBox
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
When object values are shown in the console, only the first few layers of
 properties are shown.
 You can give an extra argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

depth
\end_layout

\end_inset

, to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 to inspect more layers.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

abyss = {let:1, us:go:deep:down:7}
\end_layout

\begin_layout Plain Layout

show abyss
\end_layout

\begin_layout Plain Layout

show abyss, 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The solution for the cat problem talks about a 
\begin_inset Quotes els
\end_inset

set
\begin_inset Quotes ers
\end_inset

 of names.
 A set
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
set
\end_layout

\end_inset

 is a collection of values in which no value may occur more than once.
 If names are strings, can you think of a way to use an object to represent
 a set of names?
\end_layout

\begin_layout Plain Layout
Show how a name can be added to this set, how one can be removed, and how
 you can check whether a name occurs in it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
This can be done by storing the content of the set as the properties of
 an object.
 Adding a name is done by setting a property by that name to a value, any
 value.
 Removing a name is done by deleting this property.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset

 operator can be used to determine whether a certain name is part of the
 set.
 There are a few subtle problems with this approach, which will be discussed
 and solved in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

.
 For this chapter, it works well enough.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

set = {'Spot': true}
\end_layout

\begin_layout Plain Layout

# Add 'White Fang' to the set
\end_layout

\begin_layout Plain Layout

set['White Fang'] = true
\end_layout

\begin_layout Plain Layout

# Remove 'Spot'
\end_layout

\begin_layout Plain Layout

delete set['Spot']
\end_layout

\begin_layout Plain Layout

# See if 'Asoka' is in the set
\end_layout

\begin_layout Plain Layout

show 'Asoka' of set
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
mutability
\end_layout

\end_inset

Object values, apparently, can change.
 The types of values discussed in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Basic-CoffeeScript"

\end_inset

 are all immutable, it is impossible to change an existing value of those
 types.
 You can combine them and derive new values from them, but when you take
 a specific string value, the text inside it can not change.
 With objects, on the other hand, the content of a value can be modified
 by changing its properties.
\end_layout

\begin_layout Standard
When we have two numbers, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

120
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

120
\end_layout

\end_inset

, they can for all practical purposes be considered the precise same number.
 With objects, there is a difference between having two references to the
 same object and having two different objects that contain the same properties.
 Consider the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object1 = {value: 10}
\end_layout

\begin_layout Plain Layout

object2 = object1
\end_layout

\begin_layout Plain Layout

object3 = {value: 10}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show object1 == object2
\end_layout

\begin_layout Plain Layout

show object1 == object3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object1.value = 15
\end_layout

\begin_layout Plain Layout

show object2.value
\end_layout

\begin_layout Plain Layout

show object3.value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object2
\end_layout

\end_inset

 are two variables grasping the 
\emph on
same
\emph default
 value.
 There is only one actual object, which is why changing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object1
\end_layout

\end_inset

 also changes the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object2
\end_layout

\end_inset

.
 The variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object3
\end_layout

\end_inset

 points to another object, which initially contains the same properties
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object1
\end_layout

\end_inset

, but lives a separate life.
\end_layout

\begin_layout Standard
Coffee\SpecialChar \-
Script
\begin_inset Quotes ers
\end_inset

s 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
==
\end_layout

\end_inset

 operator, when comparing objects, will only return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 if both values given to it are the precise same value.
 Comparing different object with identical contents will give 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 This is useful in some situations, but unpractical in others
\begin_inset Foot
status open

\begin_layout Plain Layout
In the underscore library you can find a function 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

isEqual
\end_layout

\end_inset

 which compares two objects based on all layers of their contents.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Object values can play a lot of different roles.
 Behaving like a set is only one of those.
 We will see a few other roles in this chapter, and 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

 shows another important way of using objects.
\end_layout

\begin_layout Standard
In the plan for the cat problem — in fact, call it an 
\emph on
algorithm
\emph default
, not a plan, that makes it sound like we know what we are talking about
 — in the algorithm, it talks about going over all the e-mails in an archive.
 What does this archive look like? And where does it come from?
\end_layout

\begin_layout Standard
Do not worry about the second question for now.
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Modularity"

\end_inset

 talks about some ways to import data into your programs, but for now you
 will find that the e-mails are just magically there.
 Some magic is really easy, inside computers.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The way in which the archive is stored is still an interesting question.
 It contains a number of e-mails.
 An e-mail can be a string, that should be obvious.
 The whole archive could be put into one huge string, but that is hardly
 practical.
 What we want is a collection of separate strings.
\end_layout

\begin_layout Standard
Collections of things are what objects are used for.
 One could make an object like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mailArchive = {
\end_layout

\begin_layout Plain Layout

  'the first e-mail': 'Dear nephew, ...'
\end_layout

\begin_layout Plain Layout

  'the second e-mail': '...'
\end_layout

\begin_layout Plain Layout

  # and so on ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But that makes it hard to go over the e-mails from start to end — how does
 the program guess the name of these properties? This can be solved by more
 predictable property names:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mailArchive = {
\end_layout

\begin_layout Plain Layout

  0: 'Dear nephew, ...
 (mail number 1)'
\end_layout

\begin_layout Plain Layout

  1: '(mail number 2)'
\end_layout

\begin_layout Plain Layout

  2: '(mail number 3)'
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for current of mailArchive
\end_layout

\begin_layout Plain Layout

  show 'Processing e-mail #' + current +
\end_layout

\begin_layout Plain Layout

       ': ' + mailArchive[current]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Luck has it that there is a special kind of objects specifically for this
 kind of use.
 They are called arrays
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
array
\end_layout

\end_inset

, and they provide some conveniences, such as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
length
\end_layout

\end_inset

 property that contains the amount of values in the array, and a number
 of operations useful for this kind of collections.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
[]
\end_layout

\end_inset

New arrays can be created using brackets (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

).
 As with properties, the commas between elements are optional when they
 are placed on separate lines.
 Ranges and for comprehensions also create arrays.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mailArchive = ['mail one', 'mail two', 'mail three']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for current in [0...mailArchive.length]
\end_layout

\begin_layout Plain Layout

  show 'Processing e-mail #' + current +
\end_layout

\begin_layout Plain Layout

       ': ' + mailArchive[current]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example, the numbers of the elements are not specified explicitly
 anymore.
 The first one automatically gets the number 0, the second the number 1,
 and so on.
\end_layout

\begin_layout Standard
Why start at 0? People tend to start counting from 1.
 As unintuitive as it seems, numbering the elements in a collection from
 0 is often more practical.
 Just go with it for now, it will grow on you.
\end_layout

\begin_layout Standard
Starting at element 0 also means that in a collection with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 elements, the last element can be found at position 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X - 1
\end_layout

\end_inset

.
 This is why the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 loop in the example uses an exclusive range 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0...mailArchive.length
\end_layout

\end_inset

.
 There is no element at position 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mailArchive.length
\end_layout

\end_inset

, so as soon as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

current
\end_layout

\end_inset

 has that value, we stop looping.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\family default
\size default
\emph default

\begin_inset CommandInset label
LatexCommand label
name "sub:Exerciserange"

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

range
\end_layout

\end_inset

 that takes one argument, a positive number, and returns an array containing
 all numbers from 0 up to and including the given number.
\end_layout

\begin_layout Plain Layout
An empty array can be created by simply typing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[]
\end_layout

\end_inset

.
 Also remember that adding properties to an object, and thus also to an
 array, can be done by assigning them a value with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=
\end_layout

\end_inset

 operator.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 property is automatically updated when elements are added.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

range = (upto) ->
\end_layout

\begin_layout Plain Layout

  result = []
\end_layout

\begin_layout Plain Layout

  i = 0
\end_layout

\begin_layout Plain Layout

  while i <= upto
\end_layout

\begin_layout Plain Layout

    result[i] = i
\end_layout

\begin_layout Plain Layout

    i++
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

show range 4
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Instead of naming the loop variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

current
\end_layout

\end_inset

, as I have been doing so far, it is now called simply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i
\end_layout

\end_inset

.
 Using single letters, usually 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

j
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 for loop variables is a widely spread habit among programmers.
 It has its origin mostly in laziness: We
\begin_inset Quotes ers
\end_inset

d rather type one character than seven, and names like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

current
\end_layout

\end_inset

 do not really clarify the meaning of the variable much.
\end_layout

\begin_layout Plain Layout
If a program uses too many meaningless single-letter variables, it can become
 unbelievably confusing.
 In my own programs, I try to only do this in a few common cases.
 Small loops are one of these cases.
 If the loop contains another loop, and that one also uses a variable named
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i
\end_layout

\end_inset

, the inner loop will modify the variable that the outer loop is using,
 and everything will break.
 One could use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

j
\end_layout

\end_inset

 for the inner loop, but in general, when the body of a loop is big, you
 should come up with a variable name that has some clear meaning.
\end_layout

\begin_layout Plain Layout
In CoffeeScript the solution can be written in much shorter forms using
 a for expression that collects the results or by using the built-in range.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

range = (upto) -> i for i in [0..upto]
\end_layout

\begin_layout Plain Layout

show range 4
\end_layout

\begin_layout Plain Layout

range = (upto) -> [0..upto]
\end_layout

\begin_layout Plain Layout

show range 4
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
In CoffeeScript most statements can also be used as expressions.
 That means for example that the values from a for comprehension can be
 collected in a variable and used later.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

numbers = (number for number in [0..12] by 2)
\end_layout

\begin_layout Plain Layout

show numbers
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Both string and array objects contain, in addition to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 property, a number of properties that refer to function values.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

doh = 'Doh'
\end_layout

\begin_layout Plain Layout

show typeof doh.toUpperCase
\end_layout

\begin_layout Plain Layout

show doh.toUpperCase()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every string has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toUpperCase
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
toUpperCase
\end_layout

\end_inset

 property.
 When called, it will return a copy of the string, in which all letters
 have been converted to uppercase.
 There is also 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toLowerCase
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
toLowerCase
\end_layout

\end_inset

.
 Guess what that does.
\end_layout

\begin_layout Standard
Notice that, even though the call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toUpperCase
\end_layout

\end_inset

 does not pass any arguments, the function does somehow have access to the
 string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'Doh'
\end_layout

\end_inset

, the value of which it is a property.
 How this works precisely is described in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

.
\end_layout

\begin_layout Standard
Properties that contain functions are generally called methods
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
method
\end_layout

\end_inset

, for example 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toUpperCase
\end_layout

\end_inset

 is a method of a string object
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mack = []
\end_layout

\begin_layout Plain Layout

mack.push 'Mack'
\end_layout

\begin_layout Plain Layout

mack.push 'the'
\end_layout

\begin_layout Plain Layout

mack.push 'Knife'
\end_layout

\begin_layout Plain Layout

show mack.join ' '
\end_layout

\begin_layout Plain Layout

show mack.pop()
\end_layout

\begin_layout Plain Layout

show mack
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

push
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
push
\end_layout

\end_inset

, which is associated with arrays, can be used to add values to it.
 It could have been used in the last exercise, as an alternative to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

result[i] = i
\end_layout

\end_inset

.
 Then there is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pop
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pop
\end_layout

\end_inset

, the opposite of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

push
\end_layout

\end_inset

: it takes off and returns the last value in the array.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

join
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
join
\end_layout

\end_inset

 builds a single big string from an array of strings.
 The parameter it is given is pasted between the values in the array.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Coming back to those cats, we now know that an array would be a good way
 to store the archive of e-mails.
 In this book, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

retrieveMails
\end_layout

\end_inset

 after the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

require
\end_layout

\end_inset

 can be used to (magically) get hold of this array.
 The magic will be dispelled in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Modularity"

\end_inset

.
 Going over them to process them one after another is no rocket science
 anymore either:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

mailArchive = (require "./04-emails").retrieveMails() 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for email, i in mailArchive
\end_layout

\begin_layout Plain Layout

  show "Processing e-mail ##{i} #{email[0..15]}..."
\end_layout

\begin_layout Plain Layout

  # Do more things...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for ...
 in
\end_layout

\end_inset

 statement we can get both the value and its index in the array.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

email[0..15]
\end_layout

\end_inset

 gets the first snippet of each email.
 We have also decided on a way to represent the set of cats that are alive.
 The next problem, then, is to find the paragraphs in an e-mail that start
 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'born'
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'died'
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The first question that comes up is what exactly a paragraph is.
 In this case, the string value itself can not help us much: Coffee\SpecialChar \-
Script
\begin_inset Quotes ers
\end_inset

s concept of text does not go any deeper than the 
\begin_inset Quotes els
\end_inset

sequence of characters
\begin_inset Quotes ers
\end_inset

 idea, so we must define paragraphs in those terms.
\end_layout

\begin_layout Standard
Earlier, we saw that there is such a thing as a newline character.
 These are what most people use to split paragraphs.
 We consider a paragraph, then, to be a part of an e-mail that starts at
 a newline character or at the start of the content, and ends at the next
 newline character or at the end of the content.
\end_layout

\begin_layout Standard
And we do not even have to write the algorithm for splitting a string into
 paragraphs ourselves.
 Strings already have a method named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

split
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
split
\end_layout

\end_inset

, which is (almost) the opposite of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

join
\end_layout

\end_inset

 method of arrays.
 It splits a string into an array, using the string given as its argument
 to determine in which places to cut.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words = 'Cities of the Interior'
\end_layout

\begin_layout Plain Layout

show words.split ' '
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thus, cutting on newlines (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'
\backslash
n'
\end_layout

\end_inset

), can be used to split an e-mail into paragraphs.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

split
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

join
\end_layout

\end_inset

 are not precisely each other
\begin_inset Quotes ers
\end_inset

s inverse.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

string.split(x).join(x)
\end_layout

\end_inset

 always produces the original value, but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

array.join(x).split(x)
\end_layout

\end_inset

 does not.
 Can you give an example of an array where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.join(' ').split(' ')
\end_layout

\end_inset

 produces a different value?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

array = ['a', 'b', 'c d']
\end_layout

\begin_layout Plain Layout

show array.join(' ').split(' ')
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Paragraphs that do not start with either 
\begin_inset Quotes eld
\end_inset

born
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

died
\begin_inset Quotes erd
\end_inset

 can be ignored by the program.
 How do we test whether a string starts with a certain word? The method
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

charAt
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
charAt
\end_layout

\end_inset

 can be used to get a specific character from a string.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.charAt(0)
\end_layout

\end_inset

 gives the first character, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 is the second one, and so on.
 One way to check whether a string starts with 
\begin_inset Quotes eld
\end_inset

born
\begin_inset Quotes erd
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

paragraph = 'born 15-11-2003 (mother Spot): White Fang'
\end_layout

\begin_layout Plain Layout

show paragraph.charAt(0) == 'b' &&
\end_layout

\begin_layout Plain Layout

     paragraph.charAt(1) == 'o' &&
\end_layout

\begin_layout Plain Layout

     paragraph.charAt(2) == 'r' &&
\end_layout

\begin_layout Plain Layout

     paragraph.charAt(3) == 'n'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But that gets a bit clumsy — imagine checking for a word of ten characters.
 There is something to be learned here though: when a line gets ridiculously
 long, it can be spread over multiple lines.
 The result can be made easier to read by lining up the start of the new
 line with the first element on the original line that plays a similar role.
 You can also end a line with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash

\end_layout

\end_inset

 to indicate that it continues on the next line.
\end_layout

\begin_layout Standard
Strings also have a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

slice
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
slice
\end_layout

\end_inset

.
 It copies out a piece of the string, starting from the character at the
 position given by the first argument, and ending before (not including)
 the character at the position given by the second one.
 It is the same as using a range as an index.
 This allows the check to be written in a shorter way.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show paragraph.slice(0, 4) == 'born'
\end_layout

\begin_layout Plain Layout

show paragraph[0...4] == 'born'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startsWith
\end_layout

\end_inset

 that takes two arguments, both strings.
 It returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 when the first argument starts with the characters in the second argument,
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 otherwise.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

startsWith = (string, pattern) ->
\end_layout

\begin_layout Plain Layout

  string.slice(0, pattern.length) == pattern
\end_layout

\begin_layout Plain Layout

# or
\end_layout

\begin_layout Plain Layout

startsWith = (string, pattern) ->
\end_layout

\begin_layout Plain Layout

  string[0...pattern.length] == pattern
\end_layout

\begin_layout Plain Layout

show startsWith 'rotation', 'rot'
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
What happens when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

charAt
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

slice
\end_layout

\end_inset

 or a range are used to take a piece of a string that does not exist? Will
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startsWith
\end_layout

\end_inset

 still work when the pattern is longer than the string it is matched against?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show 'Pip'.charAt 250
\end_layout

\begin_layout Plain Layout

show 'Nop'.slice 1, 10
\end_layout

\begin_layout Plain Layout

show 'Pin'[1...10]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

charAt
\end_layout

\end_inset

 will return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

''
\end_layout

\end_inset

 when there is no character at the given position, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

slice
\end_layout

\end_inset

 or the range will simply leave out the part of the new string that does
 not exist.
\end_layout

\begin_layout Standard
So yes, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startsWith
\end_layout

\end_inset

 should work.
 When 
\begin_inset listings
lstparams "breaklines=true"
inline true
status open

\begin_layout Plain Layout

startsWith('Idiots', 'Most honoured colleagues')
\end_layout

\end_inset

 is called, the call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

slice
\end_layout

\end_inset

 will, because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

string
\end_layout

\end_inset

 does not have enough characters, always return a string that is shorter
 than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pattern
\end_layout

\end_inset

.
 Because of that, the comparison with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 will return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

, which is correct.
\end_layout

\begin_layout Standard
It helps to always take a moment to consider abnormal (but valid) inputs
 for a program.
 These are usually called corner cases
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
corner case
\end_layout

\end_inset

, and it is very common for programs that work perfectly on all the 
\begin_inset Quotes els
\end_inset

normal
\begin_inset Quotes ers
\end_inset

 inputs to screw up on corner cases
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Some test cases for 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

startsWith
\end_layout

\end_inset

 are present in the source code file for this chapter.
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The only part of the cat-problem that is still unsolved is the extraction
 of names from a paragraph.
 The algorithm was this:
\end_layout

\begin_layout Enumerate
Find the colon in the paragraph.
\end_layout

\begin_layout Enumerate
Take the part after this colon.
\end_layout

\begin_layout Enumerate
Split this part into separate names by looking for commas.
\end_layout

\begin_layout Standard
This has to happen both for paragraphs that start with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'died'
\end_layout

\end_inset

, and paragraphs that start with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'born'
\end_layout

\end_inset

.
 It would be a good idea to put it into a function, so that the two pieces
 of code that handle these different kinds of paragraphs can both use it.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Can you write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catNames
\end_layout

\end_inset

 that takes a paragraph as an argument and returns an array of names?
\end_layout

\begin_layout Plain Layout
Strings have an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

indexOf
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
indexOf
\end_layout

\end_inset

 method that can be used to find the (first) position of a character or
 sub-string within that string.
 Also, when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

slice
\end_layout

\end_inset

 is given only one argument, it will return the part of the string from
 the given position all the way to the end.
 With a range either the start or end can be left out: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'shorthand'[...5]
\end_layout

\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'short'
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'shorthand'[5...]
\end_layout

\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'hand'
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
It can be helpful to use CoffeeScript interactively to 
\begin_inset Quotes els
\end_inset

explore
\begin_inset Quotes ers
\end_inset

 functions.
 Try 
\begin_inset listings
lstparams "breaklines=true"
inline true
status open

\begin_layout Plain Layout

'foo: bar'.indexOf(':')
\end_layout

\end_inset

 and see what you get.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

catNames = (paragraph) ->
\end_layout

\begin_layout Plain Layout

  colon = paragraph.indexOf ':'
\end_layout

\begin_layout Plain Layout

  paragraph[colon+2...].split ', '
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show catNames 'born 20/09/2004 (mother Yellow Bess): ' +
\end_layout

\begin_layout Plain Layout

              'Doctor Hobbles the 2nd, Noog'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The tricky part, which the original description of the algorithm ignored,
 is dealing with spaces after the colon and the commas.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+ 2
\end_layout

\end_inset

 used when slicing the string is needed to leave out the colon itself and
 the space after it.
 The argument to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

split
\end_layout

\end_inset

 contains both a comma and a space, because that is what the names are really
 separated by, rather than just a comma.
\end_layout

\begin_layout Plain Layout
This function does not do any checking for problems.
 We assume, in this case, that the input is always correct.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All that remains now is putting the pieces together.
 One way to do that looks like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mailArchive = (require './04-emails').retrieveMails()
\end_layout

\begin_layout Plain Layout

livingCats = 'Spot': true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for email, i in mailArchive
\end_layout

\begin_layout Plain Layout

  paragraphs = email.split '
\backslash
n'
\end_layout

\begin_layout Plain Layout

  for paragraph in paragraphs
\end_layout

\begin_layout Plain Layout

    if startsWith paragraph, 'born'
\end_layout

\begin_layout Plain Layout

      names = catNames paragraph
\end_layout

\begin_layout Plain Layout

      for name in names
\end_layout

\begin_layout Plain Layout

        livingCats[name] = true
\end_layout

\begin_layout Plain Layout

    else if startsWith paragraph, 'died'
\end_layout

\begin_layout Plain Layout

      names = catNames paragraph
\end_layout

\begin_layout Plain Layout

      for name in names
\end_layout

\begin_layout Plain Layout

        delete livingCats[name]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show livingCats
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is quite a big dense chunk of code.
 We will look into making it a bit lighter in a moment.
 But first let us look at our results.
 We know how to check whether a specific cat survives:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if 'Spot' in livingCats
\end_layout

\begin_layout Plain Layout

  show 'Spot lives!'
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

  show 'Good old Spot, may she rest in peace.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But how do we list all the cats that are alive? The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
of
\end_layout

\end_inset

 keyword is somewhat similar to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

in
\end_layout

\end_inset

 keyword when it is used together with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for cat of livingCats
\end_layout

\begin_layout Plain Layout

  show cat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A loop like that will go over the names of the properties in an object,
 which allows us to enumerate all the names in our set.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Some pieces of code look like an impenetrable jungle.
 The example solution to the cat problem suffers from this.
 One way to make some light shine through it is to just add some strategic
 blank lines.
 This makes it look better, but does not really solve the problem.
\end_layout

\begin_layout Standard
What is needed here is to break the code up.
 We already wrote two helper functions, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startsWith
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catNames
\end_layout

\end_inset

, which both take care of a small, understandable part of the problem.
 Let us continue doing this.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

addToSet = (set, values) ->
\end_layout

\begin_layout Plain Layout

  for i in [0..values.length]
\end_layout

\begin_layout Plain Layout

    set[values[i]] = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

removeFromSet = (set, values) ->
\end_layout

\begin_layout Plain Layout

  for i in [0..values.length]
\end_layout

\begin_layout Plain Layout

    delete set[values[i]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These two functions take care of the adding and removing of names from the
 set.
 That already cuts out the two most inner loops from the solution:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

livingCats = 'Spot': true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for email in mailArchive
\end_layout

\begin_layout Plain Layout

  paragraphs = email.split '
\backslash
n'
\end_layout

\begin_layout Plain Layout

  for paragraph in paragraphs
\end_layout

\begin_layout Plain Layout

    if startsWith paragraph, 'born'
\end_layout

\begin_layout Plain Layout

      addToSet livingCats, catNames paragraph
\end_layout

\begin_layout Plain Layout

    else if startsWith paragraph, 'died'
\end_layout

\begin_layout Plain Layout

      removeFromSet livingCats, catNames paragraph
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show livingCats
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quite an improvement, if I may say so myself.
\end_layout

\begin_layout Standard
Why do 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addToSet
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

removeFromSet
\end_layout

\end_inset

 take the set as an argument? They could use the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

livingCats
\end_layout

\end_inset

 directly, if they wanted to.
 The reason is that this way they are not completely tied to our current
 problem.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addToSet
\end_layout

\end_inset

 directly changed 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

livingCats
\end_layout

\end_inset

, it would have to be called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addCatsToCatSet
\end_layout

\end_inset

, or something similar.
 The way it is now, it is a more generally useful tool.
\end_layout

\begin_layout Standard
Even if we are never going to use these functions for anything else, which
 is quite probable, it is useful to write them like this.
 Because they are 
\begin_inset Quotes els
\end_inset

self sufficient
\begin_inset Quotes ers
\end_inset

, they can be read and understood on their own, without needing to know
 about some external variable called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

livingCats
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The functions are not pure: They change the object passed as their 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

 argument.
 This makes them slightly trickier than real pure functions, but still a
 lot less confusing than functions that run amok and change any value or
 variable they please.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
We continue breaking the algorithm into pieces:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

findLivingCats = ->
\end_layout

\begin_layout Plain Layout

  mailArchive = (require './04-emails').retrieveMails()
\end_layout

\begin_layout Plain Layout

  livingCats = 'Spot': true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  handleParagraph = (paragraph) ->
\end_layout

\begin_layout Plain Layout

    if startsWith paragraph, 'born'
\end_layout

\begin_layout Plain Layout

      addToSet livingCats, catNames paragraph
\end_layout

\begin_layout Plain Layout

    else if startsWith paragraph, 'died'
\end_layout

\begin_layout Plain Layout

      removeFromSet livingCats, catNames paragraph
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  for email in mailArchive
\end_layout

\begin_layout Plain Layout

    paragraphs = email.split '
\backslash
n'
\end_layout

\begin_layout Plain Layout

    for paragraph in paragraphs
\end_layout

\begin_layout Plain Layout

      handleParagraph paragraph
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  livingCats
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

howMany = 0
\end_layout

\begin_layout Plain Layout

for cat of findLivingCats()
\end_layout

\begin_layout Plain Layout

  howMany++
\end_layout

\begin_layout Plain Layout

show 'There are ' + howMany + ' cats.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The whole algorithm is now encapsulated by a function.
 This means that it does not leave a mess after it runs: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

livingCats
\end_layout

\end_inset

 is now a local variable in the function, instead of a top-level one, so
 it only exists while the function runs.
 The code that needs this set can call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findLivingCats
\end_layout

\end_inset

 and use the value it returns.
\end_layout

\begin_layout Standard
It seemed to me that making 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

handleParagraph
\end_layout

\end_inset

 a separate function also cleared things up.
 But this one is so closely tied to the cat-algorithm that it is meaningless
 in any other situation.
 On top of that, it needs access to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

livingCats
\end_layout

\end_inset

 variable.
 Thus, it is a perfect candidate to be a function-inside-a-function.
 When it lives inside 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findLivingCats
\end_layout

\end_inset

, it is clear that it is only relevant there, and it has access to the variables
 of its parent function.
\end_layout

\begin_layout Standard
This solution is actually 
\emph on
bigger
\emph default
 than the previous one.
 Still, it is tidier and I hope you will agree that it is easier to read.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
The program still ignores a lot of the information that is contained in
 the e-mails.
 There are birth-dates, dates of death, and the names of mothers in there.
\end_layout

\begin_layout Standard
To start with the dates: What would be a good way to store a date? We could
 make an object with three properties, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

year
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

month
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

day
\end_layout

\end_inset

, and store numbers in them.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

whenWasIt = year: 1980, month: 2, day: 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But Coffee\SpecialChar \-
Script already provides a kind of object for this purpose.
 Such an object can be created by using the keyword 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
new
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

whenWasIt = new Date 1980, 1, 1
\end_layout

\begin_layout Plain Layout

show whenWasIt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Just like the notation with colons and optional braces we have already seen,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 is a way to create object values.
 Instead of specifying all the property names and values, a function is
 used to build up the object.
 This makes it possible to define a kind of standard procedure for creating
 objects.
 Functions like this are called constructors
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
constructor
\end_layout

\end_inset

, and in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

 we will see how to write them.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Date
\end_layout

\end_inset

 constructor can be used in different ways.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show new Date
\end_layout

\begin_layout Plain Layout

show new Date 1980, 1, 1
\end_layout

\begin_layout Plain Layout

show new Date 2007, 2, 30, 8, 20, 30
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, these objects can store a time of day as well as a date.
 When not given any arguments, an object representing the current time and
 date is created.
 Arguments can be given to ask for a specific date and time.
 The order of the arguments is year, month, day, hour, minute, second, milliseco
nds.
 These last four are optional, they become 0 when not given.
\end_layout

\begin_layout Standard
The month numbers these objects use go from 0 to 11, which can be confusing.
 Especially since day numbers 
\emph on
do
\emph default
 start from 1.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The content of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset

 object can be inspected with a number of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get...
\end_layout

\end_inset

 methods.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

today = new Date();
\end_layout

\begin_layout Plain Layout

show "Year: #{today.getFullYear()}
\end_layout

\begin_layout Plain Layout

 month: #{today.getMonth()}
\end_layout

\begin_layout Plain Layout

 day: #{today.getDate()}"
\end_layout

\begin_layout Plain Layout

show "Hour: #{today.getHours()}
\end_layout

\begin_layout Plain Layout

 minutes: #{today.getMinutes()}
\end_layout

\begin_layout Plain Layout

 seconds: #{today.getSeconds()}"
\end_layout

\begin_layout Plain Layout

show "Day of week: #{today.getDay()}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All of these, except for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getDay
\end_layout

\end_inset

, also have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set...
\end_layout

\end_inset

 variant that can be used to change the value of the date object.
\end_layout

\begin_layout Standard
Inside the object, a date is represented by the amount of milliseconds it
 is away from January 1st 1970.
 You can imagine this is quite a large number.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

today = new Date()
\end_layout

\begin_layout Plain Layout

show today.getTime()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A very useful thing to do with dates is comparing them.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

wallFall = new Date 1989, 10, 9
\end_layout

\begin_layout Plain Layout

gulfWarOne = new Date 1990, 6, 2
\end_layout

\begin_layout Plain Layout

show wallFall < gulfWarOne
\end_layout

\begin_layout Plain Layout

show wallFall == wallFall
\end_layout

\begin_layout Plain Layout

# but
\end_layout

\begin_layout Plain Layout

show wallFall == new Date 1989, 10, 9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Comparing dates with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<=
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>=
\end_layout

\end_inset

 does exactly what you would expect.
 When a date object is compared to itself with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 the result is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, which is also good.
 But when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
==
\end_layout

\end_inset

 is used to compare a date object to a different, equal date object, we
 get 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 Huh?
\end_layout

\begin_layout Standard
As mentioned earlier, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 will return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 when comparing two different objects, even if they contain the same properties.
 This is a bit clumsy and error-prone here, since one would expect 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>=
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 to behave in a more or less similar way.
 Testing whether two dates are equal can be done like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

wallFall1 = new Date 1989, 10, 9
\end_layout

\begin_layout Plain Layout

wallFall2 = new Date 1989, 10, 9
\end_layout

\begin_layout Plain Layout

show wallFall1.getTime() == wallFall2.getTime()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
In addition to a date and time, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset

 objects also contain information about a timezone
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
timezone
\end_layout

\end_inset

.
 When it is one o
\begin_inset Quotes ers
\end_inset

clock in Amsterdam, it can, depending on the time of year, be noon in London,
 and seven in the morning in New York.
 Such times can only be compared when you take their time zones into account.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getTimezoneOffset
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
getTimezoneOffset
\end_layout

\end_inset

 function of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset

 can be used to find out how many minutes it differs from GMT (Greenwich
 Mean Time).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

now = new Date()
\end_layout

\begin_layout Plain Layout

show now.getTimezoneOffset()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'died 27/04/2006: Black Leclère'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The date part is always in the exact same place of a paragraph.
 How convenient.
 Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extractDate
\end_layout

\end_inset

 that takes such a paragraph as its argument, extracts the date, and returns
 it as a date object.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

extractDate = (paragraph) ->
\end_layout

\begin_layout Plain Layout

  numberAt = (start, length) ->
\end_layout

\begin_layout Plain Layout

    Number paragraph[start...start + length]
\end_layout

\begin_layout Plain Layout

  new Date numberAt(11, 4),     # Year
\end_layout

\begin_layout Plain Layout

           numberAt( 8, 2) - 1, # Month
\end_layout

\begin_layout Plain Layout

           numberAt( 5, 2)      # Day
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show extractDate 'died 27-04-2006: Black Leclère'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
It would work without the calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Number
\end_layout

\end_inset

, but as mentioned earlier, I prefer not to use strings as if they are numbers.
 The inner function was introduced to prevent having to repeat the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Number
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

slice
\end_layout

\end_inset

 part three times.
\end_layout

\begin_layout Plain Layout
Note the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset

 for the month number.
 Like most people, Aunt Emily counts her months from 1, so we have to adjust
 the value before giving it to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset

 constructor.
 (The day number does not have this problem, since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset

 objects count days in the usual human way.)
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Regular-Expressions"

\end_inset

 we will see a more practical and robust way of extracting pieces from strings
 that have a fixed structure.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Storing cats will work differently from now on.
 Instead of just putting the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 into the set, we store an object with information about the cat.
 When a cat dies, we do not remove it from the set, we just add a property
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

death
\end_layout

\end_inset

 to the object to store the date on which the creature died.
\end_layout

\begin_layout Standard
This means our 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addToSet
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

removeFromSet
\end_layout

\end_inset

 functions have become useless.
 Something similar is needed, but it must also store birth-dates and, later,
 the mother
\begin_inset Quotes ers
\end_inset

s name.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

catRecord = (name, birthdate, mother) ->
\end_layout

\begin_layout Plain Layout

  name:   name
\end_layout

\begin_layout Plain Layout

  birth:  birthdate
\end_layout

\begin_layout Plain Layout

  mother: mother
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

addCats = (set, names, birthdate, mother) ->
\end_layout

\begin_layout Plain Layout

  for name in names
\end_layout

\begin_layout Plain Layout

    set[name] = catRecord name, birthdate, mother
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

deadCats = (set, names, deathdate) ->
\end_layout

\begin_layout Plain Layout

  for name in names
\end_layout

\begin_layout Plain Layout

    set[name].death = deathdate
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catRecord
\end_layout

\end_inset

 is a separate function for creating these storage objects.
 It might be useful in other situations, such as creating the object for
 Spot.
 
\begin_inset Quotes els
\end_inset

Record
\begin_inset Quotes ers
\end_inset

 is a term often used for objects like this, which are used to group a limited
 number of values.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
So let us try to extract the names of the mother cats from the paragraphs.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'born 15/11/2003 (mother Spot): White Fang'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One way to do this would be\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

extractMother = (paragraph) ->
\end_layout

\begin_layout Plain Layout

  start = paragraph.indexOf '(mother '
\end_layout

\begin_layout Plain Layout

  start += '(mother '.length
\end_layout

\begin_layout Plain Layout

  end = paragraph.indexOf ')'
\end_layout

\begin_layout Plain Layout

  paragraph[start...end]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show extractMother 
\backslash

\end_layout

\begin_layout Plain Layout

  'born 15/11/2003 (mother Spot): White Fang'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice how the start position has to be adjusted for the length of the string
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'(mother '
\end_layout

\end_inset

, because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

indexOf
\end_layout

\end_inset

 returns the position of the start of the pattern, not its end.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The thing that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extractMother
\end_layout

\end_inset

 does can be expressed in a more general way.
 Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 that takes three arguments, all of which are strings.
 It will return the part of the first argument that occurs between the patterns
 given by the second and the third arguments.
 That is:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between 'born 15/11/2003 (mother Spot): White Fang',
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

          '(mother ', ')'
\end_layout

\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'Spot'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between 'bu ] boo [ bah ] gzz', '[ ', ' ]'
\end_layout

\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'bah'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
To make that second test work, it can be useful to know that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

indexOf
\end_layout

\end_inset

 can be given a second, optional parameter that specifies at which point
 it should start searching.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

between = (string, start, end) ->
\end_layout

\begin_layout Plain Layout

  startAt = string.indexOf start
\end_layout

\begin_layout Plain Layout

  startAt += start.length
\end_layout

\begin_layout Plain Layout

  endAt = string.indexOf end, startAt
\end_layout

\begin_layout Plain Layout

  string[startAt...endAt]
\end_layout

\begin_layout Plain Layout

show between 'bu ] boo [ bah ] gzz', '[ ', ' ]'
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Having 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 makes it possible to express extractMother in a simpler way:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

extractMother = (paragraph) ->
\end_layout

\begin_layout Plain Layout

  between paragraph, '(mother ', ')'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The new, improved cat-algorithm looks like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

findCats = ->
\end_layout

\begin_layout Plain Layout

  mailArchive = (require './04-emails').retrieveMails()
\end_layout

\begin_layout Plain Layout

  cats = {'Spot': catRecord 'Spot',
\end_layout

\begin_layout Plain Layout

    new Date(1997, 2, 5), 'unknown'}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  handleParagraph = (paragraph) ->
\end_layout

\begin_layout Plain Layout

    if startsWith paragraph, 'born'
\end_layout

\begin_layout Plain Layout

      addCats cats, catNames(paragraph),
\end_layout

\begin_layout Plain Layout

              extractDate(paragraph),
\end_layout

\begin_layout Plain Layout

              extractMother(paragraph)
\end_layout

\begin_layout Plain Layout

    else if startsWith paragraph, 'died'
\end_layout

\begin_layout Plain Layout

      deadCats cats, catNames(paragraph),
\end_layout

\begin_layout Plain Layout

               extractDate(paragraph)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  for email in mailArchive
\end_layout

\begin_layout Plain Layout

    paragraphs = email.split '
\backslash
n'
\end_layout

\begin_layout Plain Layout

    for paragraph in paragraphs
\end_layout

\begin_layout Plain Layout

      handleParagraph paragraph
\end_layout

\begin_layout Plain Layout

  cats
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

catData = findCats()
\end_layout

\begin_layout Plain Layout

show catData
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Having that extra data allows us to finally have a clue about the cats aunt
 Emily talks about.
 A function like this could be useful:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

formatDate = (date) -> "#{date.getDate()}/" +
\end_layout

\begin_layout Plain Layout

                       "#{date.getMonth() + 1}/" +
\end_layout

\begin_layout Plain Layout

                       "#{date.getFullYear()}"
\end_layout

\begin_layout Plain Layout

catInfo = (data, name) ->
\end_layout

\begin_layout Plain Layout

  unless name of data
\end_layout

\begin_layout Plain Layout

    return "No cat by the name of #{name} is known."
\end_layout

\begin_layout Plain Layout

  cat = data[name]
\end_layout

\begin_layout Plain Layout

  message = "#{name}," +
\end_layout

\begin_layout Plain Layout

            " born #{formatDate cat.birth}" +
\end_layout

\begin_layout Plain Layout

            " from mother #{cat.mother}"
\end_layout

\begin_layout Plain Layout

  if "death" of cat
\end_layout

\begin_layout Plain Layout

    message += ", died #{formatDate cat.death}"
\end_layout

\begin_layout Plain Layout

  "#{message}."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show catInfo catData, "Fat Igor"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statement in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catInfo
\end_layout

\end_inset

 is used as an escape hatch.
 If there is no data about the given cat, the rest of the function is meaningles
s, so we immediately return a value, which prevents the rest of the code
 from running.
\end_layout

\begin_layout Standard
In the past, certain groups of programmers considered functions that contain
 multiple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statements sinful.
 The idea was that this made it hard to see which code was executed and
 which code was not.
 Other techniques, which will be discussed in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Error-Handling"

\end_inset

, have made the reasons behind this idea more or less obsolete, but you
 might still occasionally come across someone who will criticise the use
 of 
\begin_inset Quotes els
\end_inset

shortcut
\begin_inset Quotes ers
\end_inset

 return statements.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

formatDate
\end_layout

\end_inset

 function used by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catInfo
\end_layout

\end_inset

 does not add a zero before the month and the day part when these are only
 one digit long.
 Write a new version that does this.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

formatDate = (date) ->
\end_layout

\begin_layout Plain Layout

  pad = (number) ->
\end_layout

\begin_layout Plain Layout

    if number < 10
\end_layout

\begin_layout Plain Layout

      "0" + number
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      number
\end_layout

\begin_layout Plain Layout

  "#{pad date.getDate()}/" +
\end_layout

\begin_layout Plain Layout

  "#{pad date.getMonth() + 1}/" +
\end_layout

\begin_layout Plain Layout

  "#{date.getFullYear()}"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show formatDate new Date 2000, 0, 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
existential accessor
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
?.
\end_layout

\end_inset

The property 
\begin_inset Quotes els
\end_inset

dot
\begin_inset Quotes ers
\end_inset

 accessor that we have been using comes in a handy form combined with the
 existential operator.
 Instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object.element
\end_layout

\end_inset

 we can write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object?.element
\end_layout

\end_inset

 if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object
\end_layout

\end_inset

 is defined then we get the value as before.
 But if it is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 then we get 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 instead of an error.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

oldestCat
\end_layout

\end_inset

 which, given an object containing cats as its argument, returns the name
 of the oldest living cat.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

oldestCat = (data) ->
\end_layout

\begin_layout Plain Layout

  oldest = null
\end_layout

\begin_layout Plain Layout

  for name of data
\end_layout

\begin_layout Plain Layout

    cat = data[name]
\end_layout

\begin_layout Plain Layout

    unless 'death' of cat
\end_layout

\begin_layout Plain Layout

      if oldest is null or oldest.birth > cat.birth
\end_layout

\begin_layout Plain Layout

        oldest = cat
\end_layout

\begin_layout Plain Layout

  oldest?.name
\end_layout

\begin_layout Plain Layout

show oldestCat catData
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The conditions in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unless/if
\end_layout

\end_inset

 statements might seem a little intimidating.
 It can be read as 
\begin_inset Quotes els
\end_inset

only store the current cat in the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

oldest
\end_layout

\end_inset

 if it is not dead, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

oldest
\end_layout

\end_inset

 is either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 or a cat that was born after the current cat
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for cat, info of catData # Test with dead cats
\end_layout

\begin_layout Plain Layout

  delete catData[cat] unless 'death' of info
\end_layout

\begin_layout Plain Layout

show oldestCat catData
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Note that this function returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 when there are no living cats in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

data
\end_layout

\end_inset

.
 What does your solution do in that case?
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now that we are familiar with arrays, I can show you something related.
 Whenever a function is called, a special variable named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arguments
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
arguments
\end_layout

\end_inset

 is added to the environment in which the function body runs.
 This variable refers to an object that resembles an array.
 It has a property 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

 for the first argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 for the second, and so on for every argument the function was given.
 It also has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
length
\end_layout

\end_inset

 property.
\end_layout

\begin_layout Standard
This object is not a real array though, it does not have methods like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

push
\end_layout

\end_inset

, and it does not automatically update its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 property when you add something to it.
 Why not, I never really found out, but this is something one needs to be
 aware of.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

argumentCounter = ->
\end_layout

\begin_layout Plain Layout

  show "You gave me #{arguments.length} arguments."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

argumentCounter "Death", "Famine", "Pestilence"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some functions can take any number of arguments.
 These typically loop over the values in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arguments
\end_layout

\end_inset

 object to do something with them.
 We can create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

print
\end_layout

\end_inset

 function that uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 to print each of its arguments.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

print = -> show arg for arg in arguments
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print 'From here to', 1/0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Others can take optional arguments which, when not given by the caller,
 get some sensible default value.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

add = (number, howmuch) ->
\end_layout

\begin_layout Plain Layout

  if  arguments.length < 2
\end_layout

\begin_layout Plain Layout

    howmuch = 1
\end_layout

\begin_layout Plain Layout

  number + howmuch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show add 6
\end_layout

\begin_layout Plain Layout

show add 6, 4
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Extend the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

range
\end_layout

\end_inset

 function from the exercise 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Exerciserange"

\end_inset

 to take a second, optional argument.
 If only one argument is given, it behaves as earlier and produces a range
 from 0 to the given number.
 If two arguments are given, the first indicates the start of the range,
 the second the end.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

range = (start, end) ->
\end_layout

\begin_layout Plain Layout

  if arguments.length < 2
\end_layout

\begin_layout Plain Layout

    end = start
\end_layout

\begin_layout Plain Layout

    start = 0
\end_layout

\begin_layout Plain Layout

  result = []
\end_layout

\begin_layout Plain Layout

  for i in [start..end]
\end_layout

\begin_layout Plain Layout

    result.push i
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show range 4
\end_layout

\begin_layout Plain Layout

show range 2, 4
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The optional argument does not work precisely like the one in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add
\end_layout

\end_inset

 example above.
 When it is not given, the first argument takes the role of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

end
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

start
\end_layout

\end_inset

 becomes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
CoffeeScript has a few of features that can make it simpler to work with
 arguments.
 You can set default values directly in the argument list.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 function is defined like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show = (obj, depth = 2, showHidden = false,
\end_layout

\begin_layout Plain Layout

             colors = useColors) ->
\end_layout

\begin_layout Plain Layout

  # body
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the arguments starting from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

depth
\end_layout

\end_inset

 are not present in a call, they get the value after the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=
\end_layout

\end_inset

.
 No checks are needed in the body where the arguments are used.
\end_layout

\begin_layout Standard
For variable arguments you can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

...
\end_layout

\end_inset

 commonly called splats.
 The ellipsis can indicate extra arguments in a function definition or a
 call.
 Do you remember the testPure function? It was used with both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absolute
\end_layout

\end_inset

 which takes one argument and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 which takes two.
 In its definition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(c, a...)
\end_layout

\end_inset

 says that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a...
\end_layout

\end_inset

 is a variable argument list.
 The variable arguments are used two times, in the call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func
\end_layout

\end_inset

 and in the call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

property
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

prelude.qc.testPure = (func, types, name, property) ->
\end_layout

\begin_layout Plain Layout

  prelude.qc.declare name, types, (c, a...) ->
\end_layout

\begin_layout Plain Layout

    c.assert property c, a..., c.note func a...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

or=
\end_layout

\end_inset

 operator can be used in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

options or= defaults
\end_layout

\end_inset

 as shorthand for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

options || (options = defaults)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
You may remember this line of code from the introduction:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show sum [1..10]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
All we need to make this line work is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 function.
 This function takes an array of numbers, and returns their sum.
 Write it, it should be easy.
 Check that it also works with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

range
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sum = (numbers) ->
\end_layout

\begin_layout Plain Layout

  total = 0
\end_layout

\begin_layout Plain Layout

  for num in numbers
\end_layout

\begin_layout Plain Layout

    total += num
\end_layout

\begin_layout Plain Layout

  total
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show sum [1..10]
\end_layout

\begin_layout Plain Layout

show sum range 1, 10
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The previous chapter showed the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.max
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.min
\end_layout

\end_inset

.
 With what you know now, you will notice that these are really the properties
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

 of the object stored under the name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Math
\end_layout

\end_inset

.
 This is another role that objects can play: A warehouse holding a number
 of related values.
\end_layout

\begin_layout Standard
There are quite a lot of values inside 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math
\end_layout

\end_inset

, if they would all have been placed directly into the global environment
 they would, as it is called, pollute it.
 The more names have been taken, the more likely one is to accidentally
 overwrite the value of some variable.
 For example, it is not a far shot to want to name something 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Most languages will stop you, or at least warn you, when you are defining
 a variable with a name that is already taken.
 Not Java\SpecialChar \-
Script.
\end_layout

\begin_layout Standard
In any case, one can find a whole outfit of mathematical functions and constants
 inside 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math
\end_layout

\end_inset

.
 All the trigonometric functions are there — 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sin
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tan
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

acos
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

asin
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

atan
\end_layout

\end_inset

.
 
\begin_inset Formula $\pi$
\end_inset

 and e, which are written with all capital letters (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PI
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

E
\end_layout

\end_inset

), which was, at one time, a fashionable way to indicate something is a
 constant.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pow
\end_layout

\end_inset

 is a good replacement for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 functions we have been writing, it also accepts negative and fractional
 exponents.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sqrt
\end_layout

\end_inset

 takes square roots.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

 can give the maximum or minimum of two values.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

round
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Math.round
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

floor
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Math.floor
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ceil
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Math.ceil
\end_layout

\end_inset

 will round numbers to the closest whole number, the whole number below
 it, and the whole number above it respectively.
\end_layout

\begin_layout Standard
There are a number of other values in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math
\end_layout

\end_inset

, but this text is an introduction, not a reference
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
reference
\end_layout

\end_inset

.
 References are what you look at when you suspect something exists in the
 language, but need to find out what it is called or how it worked exactly.
 A useful 
\begin_inset CommandInset href
LatexCommand href
name "reference for predefined global objects"
target "https://developer.mozilla.org/en/JavaScript/Reference#Standard_global_objects_(by_category)"

\end_inset

 like the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math
\end_layout

\end_inset

 object exist at the 
\begin_inset CommandInset href
LatexCommand href
name "Mozilla Developer Network"
target "https://developer.mozilla.org/en/Javascript"

\end_inset

.
\end_layout

\begin_layout Standard
An interesting object is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 when you look through its 
\begin_inset CommandInset href
LatexCommand href
name "reference"
target "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array"

\end_inset

 notice that many definitions for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 are marked 
\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 1
use_makebox 0
width "22col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout

\size scriptsize
Requires JavaScript 1.6
\end_layout

\end_inset

 or another version number.
 JavaScript 1.5 corresponds to 
\size small
ECMA-262 3
\begin_inset script superscript

\begin_layout Plain Layout
rd
\end_layout

\end_inset


\size default
 Edition from December 1999.
\end_layout

\begin_layout Standard
More than a decade later this is still the standard that most JavaScript
 engines implement — including V8, the engine that via JavaScript compiles
 CoffeeScript to native machine code.
 It is fair to say that JavaScript is evolving at a glacial pace.
 Fortunately CoffeeScript and Underscore leapfrogs the JavaScript process
 and gives you language and library advances that you can use without waiting
 for existing browsers and engines to be upgraded.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Maybe you already thought of a way to find out what is available in the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math
\end_layout

\end_inset

 object:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for name of Math
\end_layout

\begin_layout Plain Layout

  show name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But alas, nothing appears.
 Similarly, when you do this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for name of ['Huey', 'Dewey', 'Loui']
\end_layout

\begin_layout Plain Layout

  show name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You only see 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

, not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

push
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

join
\end_layout

\end_inset

, which are definitely also in there.
 Apparently, some properties of objects are hidden
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
hidden properties
\end_layout

\end_inset

.
 There is a good reason for this: All objects have a few methods, for example
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toString
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
toString
\end_layout

\end_inset

, which converts the object into some kind of relevant string, and you do
 not want to see those when you are, for example, looking for the cats that
 you stored in the object.
\end_layout

\begin_layout Standard
Why the properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math
\end_layout

\end_inset

 are hidden is unclear to me.
 Someone probably wanted it to be a mysterious kind of object.
 But you can peek under the hood with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 — see the prelude for details:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show Math, 2, true
\end_layout

\begin_layout Plain Layout

show ['Huey', 'Dewey', 'Loui'], 2, true
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All properties your programs add to objects are visible.
 There is no way to make them hidden, which is unfortunate because, as we
 will see in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

, it would be nice to be able to add methods to objects without having them
 show up in our 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset

 loops.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
read-only properties
\end_layout

\end_inset

Some properties are read-only, you can get their value but not change it.
 For example, the properties of a string value are all read-only.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
watched properties
\end_layout

\end_inset

Other properties can be 
\begin_inset Quotes els
\end_inset

watched
\begin_inset Quotes ers
\end_inset

.
 Changing them causes 
\emph on
things
\emph default
 to happen.
 For example, lowering the length of an array causes excess elements to
 be discarded:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

array = ['Heaven', 'Earth', 'Man']
\end_layout

\begin_layout Plain Layout

array.length = 2
\end_layout

\begin_layout Plain Layout

show array
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Error Handling
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Error Handling
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Error-Handling"

\end_inset


\end_layout

\begin_layout Standard
Writing programs that work when everything goes as expected is a good start.
 Making your programs behave properly when encountering unexpected conditions
 is where it really gets challenging.
\end_layout

\begin_layout Standard
The problematic situations that a program can encounter fall into two categories
: Programmer mistakes and genuine problems.
 If someone forgets to pass a required argument to a function, that is an
 example of the first kind of problem.
 On the other hand, if a program asks the user to enter a name and it gets
 back an empty string, that is something the programmer can not prevent.
\end_layout

\begin_layout Standard
In general, one deals with programmer errors by finding and fixing them,
 and with genuine errors by having the code check for them and perform some
 suitable action to remedy them (for example, asking for the name again),
 or at least fail in a well-defined and clean way.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
It is important to decide into which of these categories a certain problem
 falls.
 For example, consider our old 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power
\end_layout

\end_inset

 function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

power = (base, exponent) ->
\end_layout

\begin_layout Plain Layout

  result = 1
\end_layout

\begin_layout Plain Layout

  for count in [0..exponent]
\end_layout

\begin_layout Plain Layout

    result *= base
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When some geek tries to call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power 'Rabbit', 4
\end_layout

\end_inset

, that is quite obviously a programmer error, but how about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

power 9, 0.5
\end_layout

\end_inset

? The function can not handle fractional exponents, but, mathematically
 speaking, raising a number to the ½ power is perfectly reasonable (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.pow
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Math.pow
\end_layout

\end_inset

 can handle it).
 In situations where it is not entirely clear what kind of input a function
 accepts, it is often a good idea to explicitly state the kind of arguments
 that are acceptable in a comment.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
If a function encounters a problem that it can not solve itself, what should
 it do? In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

 we wrote the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

between = (string, start, end) ->
\end_layout

\begin_layout Plain Layout

  startAt = string.indexOf start
\end_layout

\begin_layout Plain Layout

  startAt += start.length 
\end_layout

\begin_layout Plain Layout

  endAt = string.indexOf end, startAt
\end_layout

\begin_layout Plain Layout

  string[startAt...endAt]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

start
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

end
\end_layout

\end_inset

 do not occur in the string, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

indexOf
\end_layout

\end_inset

 will return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset

 and this version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 will return a lot of nonsense:
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between('Your mother!', '{-', '-}')
\end_layout

\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'our mother'
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
When the program is running, and the function is called like that, the code
 that called it will get a string value, as it expected, and happily continue
 doing something with it.
 But the value is wrong, so whatever it ends up doing with it will also
 be wrong.
 And if you are unlucky, this wrongness only causes a problem after having
 passed through twenty other functions.
 In cases like that, it is extremely hard to find out where the problem
 started.
\end_layout

\begin_layout Standard
In some cases, you will be so unconcerned about these problems that you
 do not mind the function misbehaving when given incorrect input.
 For example, if you know for sure the function will only be called from
 a few places, and you can prove that these places give it decent input,
 it is generally not worth the trouble to make the function bigger and uglier
 so that it can handle problematic cases.
\end_layout

\begin_layout Standard
But most of the time, functions that fail 
\begin_inset Quotes els
\end_inset

silently
\begin_inset Quotes ers
\end_inset

 are hard to use, and even dangerous.
 What if the code calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 wants to know whether everything went well? At the moment, it can not tell,
 except by re-doing all the work that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 did and checking the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 with its own result.
 That is bad.
 One solution is to make 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 return a special value, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

, when it fails.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

between = (string, start, end) ->
\end_layout

\begin_layout Plain Layout

  startAt = string.indexOf start
\end_layout

\begin_layout Plain Layout

  if startAt == -1 then return
\end_layout

\begin_layout Plain Layout

  startAt += start.length
\end_layout

\begin_layout Plain Layout

  endAt = string.indexOf end, startAt
\end_layout

\begin_layout Plain Layout

  if endAt == -1 then return
\end_layout

\begin_layout Plain Layout

  string[startAt...endAt]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can see that error checking does not generally make functions prettier.
 But now code that calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 can do something like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

prompt "Tell me something", "", (answer) ->
\end_layout

\begin_layout Plain Layout

  parenthesized = between answer, "(", ")"
\end_layout

\begin_layout Plain Layout

  if parenthesized?
\end_layout

\begin_layout Plain Layout

    show "You parenthesized '#{parenthesized}'."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
In many cases returning a special value is a perfectly fine way to indicate
 an error.
 It does, however, have its downsides.
 Firstly, what if the function can already return every possible kind of
 value? For example, consider this function that gets the last element from
 an array:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lastElement = (array) ->
\end_layout

\begin_layout Plain Layout

  if array.length > 0
\end_layout

\begin_layout Plain Layout

    array[array.length - 1]
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    undefined
\end_layout

\begin_layout Plain Layout

show lastElement [1, 2, undefined]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So did the array have a last element? Looking at the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lastElement
\end_layout

\end_inset

 returns, it is impossible to say.
\end_layout

\begin_layout Standard
The second issue with returning special values is that it can sometimes
 lead to a whole lot of clutter.
 If a piece of code calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 ten times, it has to check ten times whether 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 was returned.
 Also, if a function calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

 but does not have a strategy to recover from a failure, it will have to
 check the return value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

between
\end_layout

\end_inset

, and if it is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

, this function can then return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 or some other special value to its caller, who in turn also checks for
 this value.
\end_layout

\begin_layout Standard
Sometimes, when something strange occurs, it would be practical to just
 stop doing what we are doing and immediately jump back to a place that
 knows how to handle the problem.
\end_layout

\begin_layout Standard
Well, we are in luck, a lot of programming languages provide such a thing.
 Usually, it is called exception handling
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
exception handling
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The theory behind exception handling goes like this: It is possible for
 code to raise
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
raise
\end_layout

\end_inset

 (or throw
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
throw
\end_layout

\end_inset

) an exception
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
exception
\end_layout

\end_inset

, which is a value.
 Raising an exception somewhat resembles a super-charged return from a function
 — it does not just jump out of the current function, but also out of its
 callers, all the way up to the top-level call that started the current
 execution.
 This is called unwinding the stack
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
unwinding the stack
\end_layout

\end_inset

.
 You may remember the stack
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
stack
\end_layout

\end_inset

 of function calls that was mentioned in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functions"

\end_inset

.
 An exception zooms down this stack, throwing away all the call contexts
 it encounters.
\end_layout

\begin_layout Standard
If they always zoomed right down to the base of the stack, exceptions would
 not be of much use, they would just provide a novel way to blow up your
 program.
 Fortunately, it is possible to set obstacles for exceptions along the stack.
 These 
\begin_inset Quotes els
\end_inset

catch
\begin_inset Quotes ers
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
catch
\end_layout

\end_inset

 the exception as it is zooming down, and can do something with it, after
 which the program continues running at the point where the exception was
 caught.
 An example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lastElement = (array) ->
\end_layout

\begin_layout Plain Layout

  if array.length > 0
\end_layout

\begin_layout Plain Layout

    array[array.length - 1]
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    throw 'Can not take the last element' +
\end_layout

\begin_layout Plain Layout

          ' of an empty array.' 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lastElementPlusTen = (array) ->
\end_layout

\begin_layout Plain Layout

  lastElement(array) + 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

  show lastElementPlusTen []
\end_layout

\begin_layout Plain Layout

catch error
\end_layout

\begin_layout Plain Layout

  show 'Something went wrong: ' + error
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
throw
\end_layout

\end_inset

 is the keyword that is used to raise an exception.
 The keyword 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
try
\end_layout

\end_inset

 sets up an obstacle for exceptions: When the code in the block after it
 raises an exception, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
catch
\end_layout

\end_inset

 block will be executed.
 The variable named in parentheses after the word 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 is the name given to the exception value inside this block.
\end_layout

\begin_layout Standard
Note that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lastElementPlusTen
\end_layout

\end_inset

 completely ignores the possibility that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lastElement
\end_layout

\end_inset

 might go wrong.
 This is the big advantage of exceptions — error-handling code is only necessary
 at the point where the error occurs, and the point where it is handled.
 The functions in between can forget all about it.
 Well, almost.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Consider the following: A function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

processThing
\end_layout

\end_inset

 wants to set a top-level variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

currentThing
\end_layout

\end_inset

 to point to a specific thing while its body executes, so that other functions
 can have access to that thing too.
 Normally you would of course just pass the thing as an argument, but assume
 for a moment that that is not practical.
 When the function finishes, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

currentThing
\end_layout

\end_inset

 should be set back to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

currentThing = null
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

processThing = (thing) ->
\end_layout

\begin_layout Plain Layout

  if currentThing != null
\end_layout

\begin_layout Plain Layout

    throw 'Oh no! We are already processing a thing!'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  currentThing = thing
\end_layout

\begin_layout Plain Layout

  # do complicated processing...
\end_layout

\begin_layout Plain Layout

  currentThing = null
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But what if the complicated processing raises an exception? In that case
 the call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

processThing
\end_layout

\end_inset

 will be thrown off the stack by the exception, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

currentThing
\end_layout

\end_inset

 will never be reset to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 statements can also be followed by a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

finally
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
finally
\end_layout

\end_inset

 keyword, which means 
\begin_inset Quotes els
\end_inset

no matter 
\emph on
what
\emph default
 happens, run this code after trying to run the code in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try
\end_layout

\end_inset

 block
\begin_inset Quotes ers
\end_inset

.
 If a function has to clean something up, the cleanup code should usually
 be put into a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

finally
\end_layout

\end_inset

 block:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

processThing = (thing) ->
\end_layout

\begin_layout Plain Layout

  if currentThing != null
\end_layout

\begin_layout Plain Layout

    throw 'Oh no! We are already processing a thing!'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  currentThing = thing
\end_layout

\begin_layout Plain Layout

  try
\end_layout

\begin_layout Plain Layout

    # do complicated processing...
\end_layout

\begin_layout Plain Layout

  finally
\end_layout

\begin_layout Plain Layout

    currentThing = null
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
A lot of errors in programs cause the Coffee\SpecialChar \-
Script environment to raise
 an exception.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

  show Sasquatch
\end_layout

\begin_layout Plain Layout

catch error
\end_layout

\begin_layout Plain Layout

  show 'Caught: ' + error.message
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In cases like this, special error objects are raised.
 These always have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

message
\end_layout

\end_inset

 property containing a description of the problem.
 You can raise similar objects using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 keyword and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Error
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Error
\end_layout

\end_inset

 constructor:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

throw new Error 'Fire!'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
When an exception goes all the way to the bottom of the stack without being
 caught, it gets handled by the environment.
 What this means differs between different browsers and engines, sometimes
 a description of the error is written to some kind of log, sometimes a
 window pops up describing the error.
\end_layout

\begin_layout Standard
The errors produced by entering code in the CoffeeScript REPL are caught
 by the console, and displayed along with a stack trace.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Most programmers consider exceptions purely an error\SpecialChar \nobreakdash-
handling mechanism.
 In essence, though, they are just another way of influencing the control
 flow of a program.
 For example, they can be used as a kind of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 statement in a recursive function.
 Here is a slightly strange function which determines whether an object,
 and the objects stored inside it, contain at least seven 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 values:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FoundSeven = {}
\end_layout

\begin_layout Plain Layout

hasSevenTruths = (object) ->
\end_layout

\begin_layout Plain Layout

  counted = 0
\end_layout

\begin_layout Plain Layout

  count = (object) ->
\end_layout

\begin_layout Plain Layout

    for name of object
\end_layout

\begin_layout Plain Layout

      if object[name] == true
\end_layout

\begin_layout Plain Layout

        if (++counted) == 7
\end_layout

\begin_layout Plain Layout

          throw FoundSeven
\end_layout

\begin_layout Plain Layout

      if typeof object[name] == 'object'
\end_layout

\begin_layout Plain Layout

        count object[name]
\end_layout

\begin_layout Plain Layout

  try
\end_layout

\begin_layout Plain Layout

    count object
\end_layout

\begin_layout Plain Layout

    return false
\end_layout

\begin_layout Plain Layout

  catch exception
\end_layout

\begin_layout Plain Layout

    if exception != FoundSeven
\end_layout

\begin_layout Plain Layout

      throw exception
\end_layout

\begin_layout Plain Layout

    return true
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The inner function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 is recursively called for every object that is part of the argument.
 When the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

counted
\end_layout

\end_inset

 reaches seven, there is no point in continuing to count, but just returning
 from the current call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 will not necessarily stop the counting, since there might be more calls
 below it.
 So what we do is just throw a value, which will cause the control to jump
 right out of any calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

, and land at the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 block.
\end_layout

\begin_layout Standard
But just returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 in case of an exception is not correct.
 Something else might be going wrong, so we first check whether the exception
 is the object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FoundSeven
\end_layout

\end_inset

, created specifically for this purpose.
 If it is not, this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 block does not know how to handle it, so it raises it again.
\end_layout

\begin_layout Standard
This is a pattern that is also common when dealing with error conditions
 — you have to make sure that your 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

catch
\end_layout

\end_inset

 block only handles exceptions that it knows how to handle.
 Throwing string values, as some of the examples in this chapter do, is
 rarely a good idea, because it makes it hard to recognise the type of the
 exception.
 A better idea is to use unique values, such as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FoundSeven
\end_layout

\end_inset

 object, or to introduce a new type of objects, as described in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

.
\end_layout

\begin_layout Part
Paradigm
\end_layout

\begin_layout Chapter
Functional Programming
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Functional Programming
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Functional-Programming"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
As programs get bigger, they also become more complex and harder to understand.
 We all think ourselves pretty clever, of course, but we are mere human
 beings, and even a moderate amount of chaos tends to baffle us.
 And then it all goes downhill.
 Working on something you do not really understand is a bit like cutting
 random wires on those time-activated bombs they always have in movies.
 If you are lucky, you might get the right one — especially if you are the
 hero of the movie and strike a suitably dramatic pose — but there is always
 the possibility of blowing everything up.
\end_layout

\begin_layout Standard
Admittedly, in most cases, breaking a program does not cause any large explosion
s.
 But when a program, by someone
\begin_inset Quotes ers
\end_inset

s ignorant tinkering, has degenerated into a ramshackle mass of errors,
 reshaping it into something sensible is a terrible labour — sometimes you
 might just as well start over.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
abstraction
\end_layout

\end_inset

Thus, the programmer is always looking for ways to keep the complexity of
 his programs as low as possible.
 An important way to do this is to try and make code more abstract.
 When writing a program, it is easy to get sidetracked into small details
 at every point.
 You come across some little issue, and you deal with it, and then proceed
 to the next little problem, and so on.
 This makes the code read like a grandmother
\begin_inset Quotes ers
\end_inset

s tale.
\end_layout

\begin_layout Quote

\emph on
Yes, dear, to make pea soup you will need split peas, the dry kind.
 And you have to soak them at least for a night, or you will have to cook
 them for hours and hours.
 I remember one time, when my dull son tried to make pea soup.
 Would you believe he hadn
\begin_inset Quotes ers
\end_inset

t soaked the peas? We almost broke our teeth, all of us.
 Anyway, when you have soaked the peas, and you
\begin_inset Quotes ers
\end_inset

ll want about a cup of them per person, and pay attention because they will
 expand a bit while they are soaking, so if you aren
\begin_inset Quotes ers
\end_inset

t careful they will spill out of whatever you use to hold them, so also
 use plenty water to soak in, but as I said, about a cup of them, when they
 are dry, and after they are soaked you cook them in four cups of water
 per cup of dry peas.
 Let it simmer for two hours, which means you cover it and keep it barely
 cooking, and then add some diced onions, sliced celery stalk, and maybe
 a carrot or two and some ham.
 Let it all cook for a few minutes more, and it is ready to eat.
\end_layout

\begin_layout Standard
Another way to describe this recipe:
\end_layout

\begin_layout Quote

\emph on
Per person: one cup dried split peas, half a chopped onion, half a carrot,
 a celery stalk, and optionally ham.
\end_layout

\begin_layout Quote

\emph on
Soak peas overnight, simmer them for two hours in four cups of water (per
 person), add vegetables and ham, and cook for ten more minutes.
\end_layout

\begin_layout Standard
This is shorter, but if you do not know how to soak peas you will surely
 screw up and put them in too little water.
 But how to soak peas can be looked up, and that is the trick.
 If you assume a certain basic knowledge in the audience, you can talk in
 a language that deals with bigger concepts, and express things in a much
 shorter and clearer way.
\end_layout

\begin_layout Standard
This, more or less, is what abstraction is.
\end_layout

\begin_layout Standard
How is this far-fetched recipe story relevant to programming? Well, obviously,
 the recipe is the program.
 Furthermore, the basic knowledge that the cook is supposed to have corresponds
 to the functions and other constructs that are available to the programmer.
 If you remember the introduction of this book, things like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 make it easier to build loops, and in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

 we wrote some simple functions in order to make other functions shorter
 and more straightforward.
 Such tools, some of them made available by the language itself, others
 built by the programmer, are used to reduce the amount of uninteresting
 details in the rest of the program, and thus make that program easier to
 work with.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Functional programming
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
functional programming
\end_layout

\end_inset

, which is the subject of this chapter, produces abstraction through clever
 ways of combining functions.
 A programmer armed with a repertoire of fundamental functions and, more
 importantly, the knowledge on how to use them, is much more effective than
 one who starts from scratch.
 Unfortunately, a standard Coffee\SpecialChar \-
Script environment comes with deplorably
 few essential functions, so we have to write them ourselves or, which is
 often preferable, make use of somebody else
\begin_inset Quotes ers
\end_inset

s code (more on that in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Modularity"

\end_inset

).
\end_layout

\begin_layout Standard
In this chapter we write a set of useful functions to understand how they
 work and solve problems with them to understand how to use them.
 In later chapters we will use the larger set of functions in the Underscore
 library that comes with CoffeeScript.
\end_layout

\begin_layout Standard
There are other popular approaches to abstraction, most notably object-oriented
 programming, the subject of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
In programming a fundamental operation is performing an action on every
 element of an array.
 Many programming languages have borrowed their way of doing this from the
 C programming language:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

size_t i;
\end_layout

\begin_layout Plain Layout

size_t N = sizeof(thing) / sizeof(thing[0]);
\end_layout

\begin_layout Plain Layout

for (i = 0; i < N; ++i) {
\end_layout

\begin_layout Plain Layout

  do_something(thing[i]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is very ugly, an eyesore if you have any good taste at all.
 It has been improved somewhat in derived languages like C++ and JavaScript.
 Other programming languages can have very different approaches
\begin_inset Foot
status open

\begin_layout Plain Layout
In 
\emph on
Mathematica
\emph default
 a function can be set as listable — eliminating the need for a loop:
\end_layout

\begin_layout Plain Layout

\size scriptsize
\begin_inset VSpace smallskip
\end_inset


\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=Mathematica,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

f[x_] := If[x > 0, Sqrt[x], Sqrt[-x]]; SetAttributes[f, Listable];
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\size scriptsize
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=Mathematica,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

f[
\backslash
{3, 0, -2
\backslash
}]
\end_layout

\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset Formula ${\scriptstyle \left\{ \sqrt{3},\:0,\:\sqrt{2}\right\} }$
\end_inset


\end_layout

\end_inset

.
 In Coffee\SpecialChar \-
Script it becomes the reasonably pleasant:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

for i in [0...thing.length] then doSomething thing[i]
\end_layout

\begin_layout Plain Layout

# or
\end_layout

\begin_layout Plain Layout

for element in thing then doSomething element
\end_layout

\end_inset

Still do we have to do this over and over or can it be abstracted?
\end_layout

\begin_layout Standard
The problem is that, whereas most functions just take some values, combine
 them, and return something, such a loop contains a piece of code that it
 must execute.
 It is easy to write a function that goes over an array and prints out every
 element:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

printArray = (array) ->
\end_layout

\begin_layout Plain Layout

  for element in array
\end_layout

\begin_layout Plain Layout

    show element
\end_layout

\begin_layout Plain Layout

  return
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But what if we want to do something else than print? Since 
\begin_inset Quotes els
\end_inset

doing something
\begin_inset Quotes ers
\end_inset

 can be represented as a function, and functions are also values, we can
 pass our action as a function value:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

forEach = (array, action) ->
\end_layout

\begin_layout Plain Layout

  for element in array
\end_layout

\begin_layout Plain Layout

    action element
\end_layout

\begin_layout Plain Layout

  #return
\end_layout

\begin_layout Plain Layout

forEach ['Wampeter', 'Foma', 'Granfalloon'], show
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In CoffeeScript most statements are expressions that return a value, that
 is also the case with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 statement.
 A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 statement at the end of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 will make it return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

.
 Here 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 is allowed to return its value, when we get to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function you will see why.
\end_layout

\begin_layout Standard
By making use of an anonymous function, something just like a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 loop can be written as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sum = (numbers) ->
\end_layout

\begin_layout Plain Layout

  total = 0
\end_layout

\begin_layout Plain Layout

  forEach numbers, (number) -> total += number
\end_layout

\begin_layout Plain Layout

  total
\end_layout

\begin_layout Plain Layout

show sum [1, 10, 100]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

total
\end_layout

\end_inset

 is visible inside the anonymous function because of the scoping rules.
 Also note that this version is hardly shorter than the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 loop.
\end_layout

\begin_layout Standard
You do get a variable bound to the current element in the array, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

number
\end_layout

\end_inset

, so there is no need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

numbers[i]
\end_layout

\end_inset

 anymore, and when this array is created by evaluating some expression,
 there is no need to store it in a variable, because it can be passed to
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 directly.
\end_layout

\begin_layout Standard
The cat-code in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

 contains a piece like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

paragraphs = email.split '
\backslash
n'
\end_layout

\begin_layout Plain Layout

for paragraph in paragraphs
\end_layout

\begin_layout Plain Layout

  handleParagraph paragraph
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This can now be written as\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

forEach email.split('
\backslash
n'), handleParagraph
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the whole, using more abstract (or 
\begin_inset Quotes els
\end_inset

higher level
\begin_inset Quotes ers
\end_inset

) constructs results in more information and less noise: The code in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 reads 
\emph on

\begin_inset Quotes els
\end_inset

for each number in numbers add that number to the total
\emph default

\begin_inset Quotes ers
\end_inset

, instead of\SpecialChar \ldots{}
 
\begin_inset Quotes els
\end_inset


\emph on
there is this variable that starts at zero, and it counts upward to the
 length of the array called numbers, and for every value of this variable
 we look up the corresponding element in the array and add this to the total
\emph default

\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
What 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 does is take an algorithm, in this case 
\begin_inset Quotes els
\end_inset

going over an array
\begin_inset Quotes ers
\end_inset

, and abstract it.
 The 
\begin_inset Quotes els
\end_inset

gaps
\begin_inset Quotes ers
\end_inset

 in the algorithm, in this case, what to do for each of these elements,
 are filled by functions which are passed to the algorithm function.
\end_layout

\begin_layout Standard
Functions that operate on other functions are called higher-order function
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
higher-order function
\end_layout

\end_inset

s.
 By operating on functions, they can talk about actions on a whole new level.
 The 
\begin_inset listings
lstparams "breaklines=true"
inline true
status open

\begin_layout Plain Layout

makeAddFunction
\end_layout

\end_inset

 function from 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functions"

\end_inset

 is also a higher-order function.
 Instead of taking a function value as an argument, it produces a new function.
\end_layout

\begin_layout Standard
Higher-order functions can be used to generalise many algorithms that regular
 functions can not easily describe.
 When you have a repertoire of these functions at your disposal, it can
 help you think about your code in a clearer way: Instead of a messy set
 of variables and loops, you can decompose algorithms into a combination
 of a few fundamental algorithms, which are invoked by name, and do not
 have to be typed out again and again.
\end_layout

\begin_layout Standard
Being able to write 
\emph on
what
\emph default
 we want to do instead of 
\emph on
how
\emph default
 we do it means we are working at a higher level of abstraction.
 In practice, this means shorter, clearer, and more pleasant code.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Another useful type of higher-order function 
\emph on
modifies
\emph default
 the function value it is given:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

negate = (func) ->
\end_layout

\begin_layout Plain Layout

  (x) -> not func x
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isNotNaN = negate isNaN
\end_layout

\begin_layout Plain Layout

show isNotNaN NaN
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function returned by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

negate
\end_layout

\end_inset

 feeds the argument it is given to the original function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func
\end_layout

\end_inset

, and then negates the result.
 But what if the function you want to negate takes more than one argument?
 You can get access to any arguments passed to a function with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arguments
\end_layout

\end_inset

 array, but how do you call a function when you do not know how many arguments
 you have?
\end_layout

\begin_layout Standard
Functions
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Unfortunately, on at least older versions of the Internet Explorer browser
 a lot of built-in functions, such as 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

alert
\end_layout

\end_inset

, are not 
\emph on
really
\emph default
 functions\SpecialChar \ldots{}
 or something.
 They report their type as 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

'object'
\end_layout

\end_inset

 when given to the 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

typeof
\end_layout

\end_inset

 operator, and they do not have an 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

apply
\end_layout

\end_inset

 method.
 Your own functions do not suffer from this, they are always real functions.
\end_layout

\end_inset

 have a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

apply
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
apply
\end_layout

\end_inset

, which is used for situations like this.
 It takes two arguments.
 The role of the first argument will be discussed in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

, for now we just use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 there.
 The second argument is an array containing the arguments that the function
 must be applied to.
 Now you know the underlying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arguments
\end_layout

\end_inset

 mechanism remember that you can also use splats\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show Math.min.apply null, [5, 6]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

negate = (func) ->
\end_layout

\begin_layout Plain Layout

  -> not func.apply null, arguments
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

negate = (func) ->
\end_layout

\begin_layout Plain Layout

  (args...) -> not func args...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Let us look at a few more basic algorithms related to arrays.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 function is really a variant of an algorithm which is usually called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
reduce
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldl
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

reduce = (array, combine, base) ->
\end_layout

\begin_layout Plain Layout

  forEach array, (element) ->
\end_layout

\begin_layout Plain Layout

    base = combine base, element
\end_layout

\begin_layout Plain Layout

  base
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

add = (a, b) -> a + b
\end_layout

\begin_layout Plain Layout

sum = (numbers) -> reduce numbers, add, 0
\end_layout

\begin_layout Plain Layout

show sum [1, 10, 100]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 combines an array into a single value by repeatedly using a function that
 combines an element of the array with a base value.
 This is exactly what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 did, so it can be made shorter by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

\SpecialChar \ldots{}
 except that addition is an operator and not a function in Coffee\SpecialChar \-
Script,
 so we first had to put it into a function.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

countZeroes
\end_layout

\end_inset

, which takes an array of numbers as its argument and returns the amount
 of zeroes that occur in it.
 Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
Then, write the higher-order function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

, which takes an array and a test function as arguments, and returns the
 amount of elements in the array for which the test function returned 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 Re-implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

countZeroes
\end_layout

\end_inset

 using this function.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

countZeroes = (array) ->
\end_layout

\begin_layout Plain Layout

  counter = (total, element) ->
\end_layout

\begin_layout Plain Layout

    total++ if element is 0
\end_layout

\begin_layout Plain Layout

    total
\end_layout

\begin_layout Plain Layout

  reduce array, counter, 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bits = [1, 0, 1, 0, 0, 1, 1, 1, 0]
\end_layout

\begin_layout Plain Layout

show countZeroes bits
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Here is the solution that uses a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 function, with a function that produces equality-testers included to make
 the final 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

countZeroes
\end_layout

\end_inset

 function even shorter:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

count = (test, array) ->
\end_layout

\begin_layout Plain Layout

  reduce array, ((total, element) ->
\end_layout

\begin_layout Plain Layout

    total + if test element then 1 else 0), 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

equals = (x) ->
\end_layout

\begin_layout Plain Layout

  (element) -> x == element
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

countZeroes = (array) ->
\end_layout

\begin_layout Plain Layout

  count equals(0), array
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show countZeroes bits
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
One other generally useful 
\begin_inset Quotes els
\end_inset

fundamental algorithm
\begin_inset Quotes ers
\end_inset

 related to arrays is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
map
\end_layout

\end_inset

.
 It goes over an array, applying a function to every element, just like
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

.
 But instead of discarding the values returned by function, it builds up
 a new array from these values.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

map = (array, func) ->
\end_layout

\begin_layout Plain Layout

  result = []
\end_layout

\begin_layout Plain Layout

  forEach array, (element) ->
\end_layout

\begin_layout Plain Layout

    result.push func element
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show map [0.01, 2, 9.89, Math.PI], Math.round
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the last argument is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func
\end_layout

\end_inset

, not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function
\end_layout

\end_inset

, this is because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function
\end_layout

\end_inset

 is a keyword and thus not a valid variable name.
 And then:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# Leave out result since forEach already returns it
\end_layout

\begin_layout Plain Layout

map = (array, func) ->
\end_layout

\begin_layout Plain Layout

  forEach array, (element) ->
\end_layout

\begin_layout Plain Layout

    func element
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Leave out func arguments
\end_layout

\begin_layout Plain Layout

map = (array, func) ->
\end_layout

\begin_layout Plain Layout

  forEach array, func
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Leave out forEach arguments
\end_layout

\begin_layout Plain Layout

map = forEach
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reduction shows how nicely functions and expressions can be used to
 shorten a function.
 If we were concerned with the performance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 then inserting a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset

 at the end of its definition would prevent it from collecting the results
 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 comprehension and we would have to provide an implementation in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
There once was, living in the deep mountain forests of Transylvania, a recluse.
 Most of the time, he just wandered around his mountain, talking to trees
 and laughing with birds.
 But now and then, when the pouring rain trapped him in his little hut,
 and the howling wind made him feel unbearably small, the recluse felt an
 urge to write something, wanted to pour some thoughts out onto paper, where
 they could maybe grow bigger than he himself was.
\end_layout

\begin_layout Standard
After failing miserably at poetry, fiction, and philosophy, the recluse
 finally decided to write a technical book.
 In his youth, he had done some computer programming, and he figured that
 if he could just write a good book about that, fame and recognition would
 surely follow.
\end_layout

\begin_layout Standard
So he wrote.
 At first he used fragments of tree bark, but that turned out not to be
 very practical.
 He went down to the nearest village and bought himself a laptop computer.
 After a few chapters, he realised he wanted to put the book in 
\shape smallcaps
\size small
HTML
\shape default
\size default
 format, in order to put it on his web-page\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/html.png
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Are you familiar with 
\shape smallcaps
\size small
HTML
\shape default
\size default
? It is the method used to add mark-up to pages on the web, and we will
 be using it a few times in this book, so it would be nice if you know how
 it works, at least generally.
 If you are a good student, you could go search the web for a good introduction
 to 
\shape smallcaps
\size small
HTML
\shape default
\size default
 now, and come back here when you have read it.
 Most of you probably are lousy students, so I will just give a short explanatio
n and hope it is enough.
\end_layout

\begin_layout Standard

\shape smallcaps
\size small
HTML
\shape default
\size default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
HTML
\end_layout

\end_inset

 stands for 
\begin_inset Quotes els
\end_inset

HyperText Mark-up Language
\begin_inset Quotes ers
\end_inset

.
 An 
\shape smallcaps
\size small
HTML
\shape default
\size default
 document is all text.
 Because it must be able to express the structure of this text, information
 about which text is a heading, which text is purple, and so on, a few character
s have a special meaning, somewhat like backslashes in Coffee\SpecialChar \-
Script strings.
 The 
\begin_inset Quotes els
\end_inset

less than
\begin_inset Quotes ers
\end_inset

 and 
\begin_inset Quotes els
\end_inset

greater than
\begin_inset Quotes ers
\end_inset

 characters are used to create 
\begin_inset Quotes els
\end_inset

tag
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
tag
\end_layout

\end_inset

s
\begin_inset Quotes ers
\end_inset

.
 A tag gives extra information about the text in the document.
 It can stand on its own, for example to mark the place where a picture
 should appear in the page, or it can contain text and other tags, for example
 when it marks the start and end of a paragraph.
\end_layout

\begin_layout Standard
Some tags are compulsory, a whole 
\shape smallcaps
\size small
HTML
\shape default
\size default
 document must always be contained in between 
\begin_inset listings
lstparams "language=HTML"
inline true
status open

\begin_layout Plain Layout

html
\end_layout

\end_inset

 tags.
 The 
\shape smallcaps
\size small
HTML
\shape default
\size default
 version is specified on the first line with the document type, 
\begin_inset listings
lstparams "language=HTML"
inline true
status open

\begin_layout Plain Layout

DOCTYPE
\end_layout

\end_inset

, so browsers can parse and render it correctly.
 Here is an example of an 
\shape smallcaps
\size small
HTML
\begin_inset script subscript

\begin_layout Plain Layout

\shape smallcaps
\size small
5
\end_layout

\end_inset


\shape default
\size default
 document:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=HTML,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

<!DOCTYPE HTML>
\end_layout

\begin_layout Plain Layout

<html>
\end_layout

\begin_layout Plain Layout

  <head>
\end_layout

\begin_layout Plain Layout

    <meta charset="utf-8"/>
\end_layout

\begin_layout Plain Layout

    <title>A quote</title>
\end_layout

\begin_layout Plain Layout

  </head>
\end_layout

\begin_layout Plain Layout

  <body>
\end_layout

\begin_layout Plain Layout

    <h1>A quote</h1>
\end_layout

\begin_layout Plain Layout

    <blockquote>
\end_layout

\begin_layout Plain Layout

      <p>The connection between the language in which we
\end_layout

\begin_layout Plain Layout

      think/program and the problems and solutions we can
\end_layout

\begin_layout Plain Layout

      imagine is very close.
 For this reason restricting
\end_layout

\begin_layout Plain Layout

      language features with the intent of eliminating
\end_layout

\begin_layout Plain Layout

      programmer errors is at best dangerous.</p>
\end_layout

\begin_layout Plain Layout

      <p>-- Bjarne Stroustrup</p>
\end_layout

\begin_layout Plain Layout

    </blockquote>
\end_layout

\begin_layout Plain Layout

    <p>Mr.
 Stroustrup is the inventor of the C++
\end_layout

\begin_layout Plain Layout

    programming language, but quite an insightful
\end_layout

\begin_layout Plain Layout

    person nevertheless.</p>
\end_layout

\begin_layout Plain Layout

    <p>Also, here is a picture of an ostrich:</p>
\end_layout

\begin_layout Plain Layout

    <img src="../img/ostrich.jpg"/>
\end_layout

\begin_layout Plain Layout

  </body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Elements that contain text or other tags are first opened with 
\begin_inset listings
lstparams "language=HTML"
inline true
status open

\begin_layout Plain Layout

<tagname>
\end_layout

\end_inset

, and afterwards finished with 
\begin_inset listings
lstparams "language=HTML"
inline true
status open

\begin_layout Plain Layout

</tagname>
\end_layout

\end_inset

.
 The 
\begin_inset listings
lstparams "language=HTML"
inline true
status open

\begin_layout Plain Layout

html
\end_layout

\end_inset

 element always contains two children: 
\begin_inset listings
lstparams "language=HTML"
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "language=HTML"
inline true
status open

\begin_layout Plain Layout

body
\end_layout

\end_inset

.
 The first contains information 
\emph on
about
\emph default
 the document, the second contains the actual document.
\end_layout

\begin_layout Standard
Most tag names are cryptic abbreviations.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h1
\end_layout

\end_inset

 stands for 
\begin_inset Quotes els
\end_inset

heading 1
\begin_inset Quotes ers
\end_inset

, the biggest kind of heading.
 There are also 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h2
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h6
\end_layout

\end_inset

 for successively smaller headings.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 means 
\begin_inset Quotes els
\end_inset

paragraph
\begin_inset Quotes ers
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

img
\end_layout

\end_inset

 stands for 
\begin_inset Quotes els
\end_inset

image
\begin_inset Quotes ers
\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

img
\end_layout

\end_inset

 element does not contain any text or other tags, but it does have some
 extra information, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

src="../img/ostrich.png"
\end_layout

\end_inset

, which is called an 
\begin_inset Quotes els
\end_inset

attribute
\begin_inset Quotes ers
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
attribute
\end_layout

\end_inset

.
 In this case, it contains information about the image file that should
 be shown here.
\end_layout

\begin_layout Standard
Because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>
\end_layout

\end_inset

 have a special meaning in 
\shape smallcaps
\size small
HTML
\shape default
\size default
 documents, they can not be written directly in the text of the document.
 If you want to say 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

5 < 10
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 in an 
\shape smallcaps
\size small
HTML
\shape default
\size default
 document, you have to write 
\begin_inset Quotes els
\end_inset


\begin_inset listings
lstparams "language=HTML"
inline true
status open

\begin_layout Plain Layout

5 &lt; 10
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

, where 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lt
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 stands for 
\begin_inset Quotes els
\end_inset

less than
\begin_inset Quotes ers
\end_inset

.
 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&gt;
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 is used for 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

>
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

, and because these codes also give the ampersand character a special meaning,
 a plain 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

 is written as 
\begin_inset Quotes els
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&amp;
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
Now, those are only the bare basics of 
\shape smallcaps
\size small
HTML
\shape default
\size default
, but they should be enough to make it through this chapter, and later chapters
 that deal with 
\shape smallcaps
\size small
HTML
\shape default
\size default
 documents, without getting entirely confused.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The prelude has a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

viewURL
\end_layout

\end_inset

 that can be used to look at 
\shape smallcaps
\size small
HTML
\shape default
\size default
 documents.
 The example document above is stored in the file 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'06-Quote.html'
\end_layout

\end_inset

, so you can view it by executing the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

viewURL '06-Quote.html'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also run a tiny server from your program or the interactive Coffee\SpecialChar \-
Script
 environment (
\shape smallcaps
\size small
REPL
\shape default
\size default
).
 It can serve a webpage either from a string variable or from a file.
 If you have created a web page in a string variable, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

stroustrupQuote
\end_layout

\end_inset

 then you can start the server with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

viewServer stroustrupQuote
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or you could give it a filename as its argument.
 When you are done with the server then you can either type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

stopServer()
\end_layout

\end_inset

 or 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false"
inline true
status open

\begin_layout Plain Layout

CTRL-C
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
So, picking up the story again, the recluse wanted to have his book in 
\shape smallcaps
\size small
HTML
\shape default
\size default
 format.
 At first he just wrote all the tags directly into his manuscript, but typing
 all those less-than and greater-than signs made his fingers hurt, and he
 constantly forgot to write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&amp;
\end_layout

\end_inset

 when he needed an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&
\end_layout

\end_inset

.
 This gave him a headache.
 Next, he tried to write the book in Microsoft Word, and then save it as
 
\shape smallcaps
\size small
HTML
\shape default
\size default
.
 But the 
\shape smallcaps
\size small
HTML
\shape default
\size default
 that came out of that was fifteen times bigger and more complicated than
 it had to be.
 And besides, Microsoft Word gave him a headache.
\end_layout

\begin_layout Standard
The solution that he eventually came up with was this: He would write the
 book as plain text, following some simple rules about the way paragraphs
 were separated and the way headings looked.
 Then, he would write a program to convert this text into precisely the
 
\shape smallcaps
\size small
HTML
\shape default
\size default
 that he wanted.
\end_layout

\begin_layout Standard
The rules are this:
\end_layout

\begin_layout Enumerate
Paragraphs are separated by blank lines.
\end_layout

\begin_layout Enumerate
A paragraph that starts with a 
\begin_inset Quotes els
\end_inset

%
\begin_inset Quotes ers
\end_inset

 symbol is a header.
 The more 
\begin_inset Quotes els
\end_inset

%
\begin_inset Quotes ers
\end_inset

 symbols, the smaller the header.
\end_layout

\begin_layout Enumerate
Inside paragraphs, pieces of text can be emphasised by putting them between
 asterisks.
\end_layout

\begin_layout Enumerate
Footnotes are written between braces.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
After he had struggled painfully with his book for six months, the recluse
 had still only finished a few paragraphs.
 At this point, his hut was struck by lightning, killing him, and forever
 putting his writing ambitions to rest.
 From the charred remains of his laptop, I could recover the following file:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=XML,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

% The Book of Programming
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% The Two Aspects
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Below the surface of the machine, the program moves.
\end_layout

\begin_layout Plain Layout

Without effort, it expands and contracts.
 In great harmony, 
\end_layout

\begin_layout Plain Layout

electrons scatter and regroup.
 The forms on the monitor
\end_layout

\begin_layout Plain Layout

are but ripples on the water.
 The essence stays invisibly
\end_layout

\begin_layout Plain Layout

below.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

When the creators built the machine, they put in the
\end_layout

\begin_layout Plain Layout

processor and the memory.
 From these arise the two aspects
\end_layout

\begin_layout Plain Layout

of the program.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The aspect of the processor is the active substance.
 It is
\end_layout

\begin_layout Plain Layout

called Control.
 The aspect of the memory is the passive 
\end_layout

\begin_layout Plain Layout

substance.
 It is called Data.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data is made of merely bits, yet it takes complex forms.
\end_layout

\begin_layout Plain Layout

Control consists only of simple instructions, yet it
\end_layout

\begin_layout Plain Layout

performs difficult tasks.
 From the small and trivial, the
\end_layout

\begin_layout Plain Layout

large and complex arise.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The program source is Data.
 Control arises from it.
 The
\end_layout

\begin_layout Plain Layout

Control proceeds to create new Data.
 The one is born from
\end_layout

\begin_layout Plain Layout

the other, the other is useless without the one.
 This is
\end_layout

\begin_layout Plain Layout

the harmonious cycle of Data and Control.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Of themselves, Data and Control are without structure.
 The
\end_layout

\begin_layout Plain Layout

programmers of old moulded their programs out of this raw
\end_layout

\begin_layout Plain Layout

substance.
 Over time, the amorphous Data has crystallised
\end_layout

\begin_layout Plain Layout

into data types, and the chaotic Control was restricted
\end_layout

\begin_layout Plain Layout

into control structures and functions.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% Short Sayings
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

When a student asked Fu-Tzu about the nature of the cycle
\end_layout

\begin_layout Plain Layout

of Data and Control, Fu-Tzu replied 'Think of a compiler,
\end_layout

\begin_layout Plain Layout

compiling itself.'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A student asked 'The programmers of old used only simple
\end_layout

\begin_layout Plain Layout

machines and no programming languages, yet they made
\end_layout

\begin_layout Plain Layout

beautiful programs.
 Why do we use complicated machines
\end_layout

\begin_layout Plain Layout

and programming languages?'.
 Fu-Tzu replied 'The builders
\end_layout

\begin_layout Plain Layout

of old used only sticks and clay, yet they made beautiful
\end_layout

\begin_layout Plain Layout

huts.'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A hermit spent ten years writing a program.
 'My program can
\end_layout

\begin_layout Plain Layout

compute the motion of the stars on a 286-computer running
\end_layout

\begin_layout Plain Layout

MS DOS', he proudly announced.
 'Nobody owns a 286-computer
\end_layout

\begin_layout Plain Layout

or uses MS DOS anymore.', Fu-Tzu responded.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Fu-Tzu had written a small program that was full of global
\end_layout

\begin_layout Plain Layout

state and dubious shortcuts.
 Reading it, a student asked
\end_layout

\begin_layout Plain Layout

'You warned us against these techniques, yet I find them in
\end_layout

\begin_layout Plain Layout

your program.
 How can this be?' Fu-Tzu said 'There is no
\end_layout

\begin_layout Plain Layout

need to fetch a water hose when the house is not on fire.'
\end_layout

\begin_layout Plain Layout

{This is not to be read as an encouragement of sloppy
\end_layout

\begin_layout Plain Layout

programming, but rather as a warning against neurotic
\end_layout

\begin_layout Plain Layout

adherence to rules of thumb.}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% Wisdom
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A student was complaining about digital numbers.
 'When I
\end_layout

\begin_layout Plain Layout

take the root of two and then square it again, the result
\end_layout

\begin_layout Plain Layout

is already inaccurate!'.
 Overhearing him, Fu-Tzu laughed.
\end_layout

\begin_layout Plain Layout

'Here is a sheet of paper.
 Write down the precise value of
\end_layout

\begin_layout Plain Layout

the square root of two for me.'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Fu-Tzu said 'When you cut against the grain of the wood,
\end_layout

\begin_layout Plain Layout

much strength is needed.
 When you program against the grain
\end_layout

\begin_layout Plain Layout

of a problem, much code is needed.'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Tzu-li and Tzu-ssu were boasting about the size of their
\end_layout

\begin_layout Plain Layout

latest programs.
 'Two-hundred thousand lines', said Tzu-li,
\end_layout

\begin_layout Plain Layout

'not counting comments!'.
 'Psah', said Tzu-ssu, 'mine is
\end_layout

\begin_layout Plain Layout

almost a *million* lines already.' Fu-Tzu said 'My best
\end_layout

\begin_layout Plain Layout

program has five hundred lines.' Hearing this, Tzu-li and
\end_layout

\begin_layout Plain Layout

Tzu-ssu were enlightened.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A student had been sitting motionless behind his computer
\end_layout

\begin_layout Plain Layout

for hours, frowning darkly.
 He was trying to write a
\end_layout

\begin_layout Plain Layout

beautiful solution to a difficult problem, but could not
\end_layout

\begin_layout Plain Layout

find the right approach.
 Fu-Tzu hit him on the back of his
\end_layout

\begin_layout Plain Layout

head and shouted '*Type something!*' The student started
\end_layout

\begin_layout Plain Layout

writing an ugly solution.
 After he had finished, he
\end_layout

\begin_layout Plain Layout

suddenly understood the beautiful solution.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% Progression
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A beginning programmer writes his programs like an ant
\end_layout

\begin_layout Plain Layout

builds her hill, one piece at a time, without thought for
\end_layout

\begin_layout Plain Layout

the bigger structure.
 His programs will be like loose sand.
\end_layout

\begin_layout Plain Layout

They may stand for a while, but growing too big they fall
\end_layout

\begin_layout Plain Layout

apart{Referring to the danger of internal inconsistency
\end_layout

\begin_layout Plain Layout

and duplicated structure in unorganised code.}.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Realising this problem, the programmer will start to spend
\end_layout

\begin_layout Plain Layout

a lot of time thinking about structure.
 His programs will
\end_layout

\begin_layout Plain Layout

be rigidly structured, like rock sculptures.
 They are solid,
\end_layout

\begin_layout Plain Layout

but when they must change, violence must be done to them
\end_layout

\begin_layout Plain Layout

{Referring to the fact that structure tends to put
\end_layout

\begin_layout Plain Layout

restrictions on the evolution of a program.}.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The master programmer knows when to apply structure and
\end_layout

\begin_layout Plain Layout

when to leave things in their simple form.
 His programs
\end_layout

\begin_layout Plain Layout

are like clay, solid yet malleable.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% Language
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

When a programming language is created, it is given
\end_layout

\begin_layout Plain Layout

syntax and semantics.
 The syntax describes the form of
\end_layout

\begin_layout Plain Layout

the program, the semantics describe the function.
 When the
\end_layout

\begin_layout Plain Layout

syntax is beautiful and the semantics are clear, the
\end_layout

\begin_layout Plain Layout

program will be like a stately tree.
 When the syntax is
\end_layout

\begin_layout Plain Layout

clumsy and the semantics confusing, the program will be
\end_layout

\begin_layout Plain Layout

like a bramble bush.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Tzu-ssu was asked to write a program in the language
\end_layout

\begin_layout Plain Layout

called  Java, which takes a very primitive approach to
\end_layout

\begin_layout Plain Layout

functions.
 Every morning, as he sat down in front of his
\end_layout

\begin_layout Plain Layout

computer, he started complaining.
 All day he cursed,
\end_layout

\begin_layout Plain Layout

blaming the language for all that went wrong.
 Fu-Tzu
\end_layout

\begin_layout Plain Layout

listened for a while, and then reproached him, saying
\end_layout

\begin_layout Plain Layout

'Every language has its own way.
 Follow its form, do not
\end_layout

\begin_layout Plain Layout

try to program as if you were using another language.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
To honour the memory of our good recluse, I would like to finish his HTML-genera
ting program for him.
 A good approach to this problem goes like this:
\end_layout

\begin_layout Enumerate
Split the file into paragraphs by cutting it at every empty line.
\end_layout

\begin_layout Enumerate
Remove the 
\begin_inset Quotes els
\end_inset

%
\begin_inset Quotes ers
\end_inset

 characters from header paragraphs and mark them as headers.
\end_layout

\begin_layout Enumerate
Process the text of the paragraphs themselves, splitting them into normal
 parts, emphasised parts, and footnotes.
\end_layout

\begin_layout Enumerate
Move all the footnotes to the bottom of the document, leaving numbers
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Like this\SpecialChar \ldots{}

\end_layout

\end_inset

 in their place.
\end_layout

\begin_layout Enumerate
Wrap each piece into the correct 
\shape smallcaps
\size small
HTML
\shape default
\size default
 tags.
\end_layout

\begin_layout Enumerate
Combine everything into a single 
\shape smallcaps
\size small
HTML
\shape default
\size default
 document.
\end_layout

\begin_layout Standard
This approach does not allow footnotes inside emphasised text, or vice versa.
 This is kind of arbitrary, but helps keep the example code simple.
 If, at the end of the chapter, you feel like an extra challenge, you can
 try to revise the program to support 
\begin_inset Quotes els
\end_inset

nested
\begin_inset Quotes ers
\end_inset

 mark-up.
\end_layout

\begin_layout Standard
The whole manuscript is in 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'06-RecluseFile.text'
\end_layout

\end_inset

.
 You can get it as a string value by calling the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

readTextFile
\end_layout

\end_inset

 function in the prelude.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

recluseFile = readTextFile '06-RecluseFile.text'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
Step 1 of the algorithm is trivial.
 A blank line is what you get when you have two newlines in a row, and if
 you remember the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

split
\end_layout

\end_inset

 method that strings have, which we saw in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

, you will realise that this will do the trick:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

paragraphs = recluseFile.split "
\backslash
n
\backslash
n"
\end_layout

\begin_layout Plain Layout

show "Found #{paragraphs.length} paragraphs."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

processParagraph
\end_layout

\end_inset

 that, when given a paragraph string as its argument, checks whether this
 paragraph is a header.
 If it is, it strips of the 
\begin_inset Quotes els
\end_inset

%
\begin_inset Quotes ers
\end_inset

 characters and counts their number.
 Then, it returns an object with two properties, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

content
\end_layout

\end_inset

, which contains the text inside the paragraph, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type
\end_layout

\end_inset

, which contains the tag that this paragraph must be wrapped in, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'p'
\end_layout

\end_inset

 for regular paragraphs, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'h1'
\end_layout

\end_inset

 for headers with one 
\begin_inset Quotes els
\end_inset

%
\begin_inset Quotes ers
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'hX'
\end_layout

\end_inset

 for headers with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 
\begin_inset Quotes els
\end_inset

%
\begin_inset Quotes ers
\end_inset

 characters.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

processParagraph = (paragraph) ->
\end_layout

\begin_layout Plain Layout

  header = 0
\end_layout

\begin_layout Plain Layout

  while paragraph[0] == '%'
\end_layout

\begin_layout Plain Layout

    paragraph = paragraph.slice 1
\end_layout

\begin_layout Plain Layout

    header++
\end_layout

\begin_layout Plain Layout

  type: if header == 0 then 'p' else 'h' + header,
\end_layout

\begin_layout Plain Layout

  content: paragraph
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show processParagraph paragraphs[0]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is where we can try out the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function we saw earlier.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

paragraphs = map recluseFile.split('
\backslash
n
\backslash
n'),
\end_layout

\begin_layout Plain Layout

                 processParagraph
\end_layout

\begin_layout Plain Layout

show paragraphs[0..2]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And 
\emph on
bang
\emph default
, we have an array of nicely categorised paragraph objects.
 We are getting ahead of ourselves though, we forgot step 3 of the algorithm:
\end_layout

\begin_layout Quote

\emph on
Process the text of the paragraphs themselves, splitting them into normal
 parts, emphasised parts, and footnotes.
\end_layout

\begin_layout Standard
Which can be decomposed into:
\end_layout

\begin_layout Enumerate
If the paragraph starts with an asterisk, take off the emphasised part and
 store it.
\end_layout

\begin_layout Enumerate
If the paragraph starts with an opening brace, take off the footnote and
 store it.
\end_layout

\begin_layout Enumerate
Otherwise, take off the part until the first emphasised part or footnote,
 or until the end of the string, and store it as normal text.
\end_layout

\begin_layout Enumerate
If there is anything left in the paragraph, start at 1 again.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Build a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

splitParagraph
\end_layout

\end_inset

 which, given a paragraph string, returns an array of paragraph fragments.
 Think of a good way to represent the fragments, they need 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

content
\end_layout

\end_inset

 properties.
\end_layout

\begin_layout Plain Layout
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

indexOf
\end_layout

\end_inset

, which searches for a character or sub-string in a string and returns its
 position, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset

 if not found, will probably be useful in some way here.
\end_layout

\begin_layout Plain Layout
This is a tricky algorithm, and there are many not-quite-correct or way-too-long
 ways to describe it.
 If you run into problems, just think about it for a minute.
 Try to write inner functions that perform the smaller actions that make
 up the algorithm.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
Here is one possible solution:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

splitParagraph = (text) ->
\end_layout

\begin_layout Plain Layout

  # Find character position or end of text
\end_layout

\begin_layout Plain Layout

  indexOrEnd = (character) ->
\end_layout

\begin_layout Plain Layout

    index = text.indexOf character
\end_layout

\begin_layout Plain Layout

    if index == -1 then text.length else index
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # Return and remove text upto next special
\end_layout

\begin_layout Plain Layout

  # character or end of text
\end_layout

\begin_layout Plain Layout

  takeNormal = ->
\end_layout

\begin_layout Plain Layout

    end = reduce map(['*', '{'], indexOrEnd),
\end_layout

\begin_layout Plain Layout

                 Math.min, text.length
\end_layout

\begin_layout Plain Layout

    part = text.slice 0, end
\end_layout

\begin_layout Plain Layout

    text = text.slice end
\end_layout

\begin_layout Plain Layout

    part
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # Return and remove text upto character
\end_layout

\begin_layout Plain Layout

  takeUpTo = (character) ->
\end_layout

\begin_layout Plain Layout

    end = text.indexOf character, 1
\end_layout

\begin_layout Plain Layout

    if end == -1
\end_layout

\begin_layout Plain Layout

      throw new Error 'Missing closing ' +
\end_layout

\begin_layout Plain Layout

                      '"' + character + '"'
\end_layout

\begin_layout Plain Layout

    part = text.slice 1, end
\end_layout

\begin_layout Plain Layout

    text = text.slice end + 1
\end_layout

\begin_layout Plain Layout

    part
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  fragments = [];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  while text != ''
\end_layout

\begin_layout Plain Layout

    if text[0] == '*'
\end_layout

\begin_layout Plain Layout

      fragments.push
\end_layout

\begin_layout Plain Layout

        type: 'emphasised',
\end_layout

\begin_layout Plain Layout

        content: takeUpTo '*'
\end_layout

\begin_layout Plain Layout

    else if text[0] == '{'
\end_layout

\begin_layout Plain Layout

      fragments.push
\end_layout

\begin_layout Plain Layout

        type: 'footnote',
\end_layout

\begin_layout Plain Layout

        content: takeUpTo '}'
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      fragments.push
\end_layout

\begin_layout Plain Layout

        type: 'normal',
\end_layout

\begin_layout Plain Layout

        content: takeNormal()
\end_layout

\begin_layout Plain Layout

  fragments
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Note the over-eager use of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeNormal
\end_layout

\end_inset

 function.
 This is a chapter about functional programming, so program functionally
 we will! Can you see how this works? The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 produces an array of positions where the given characters were found, or
 the end of the string if they were not found, and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 takes the minimum of them, which is the next point in the string that we
 have to look at.
\end_layout

\begin_layout Plain Layout
If you
\begin_inset Quotes ers
\end_inset

d write that out without mapping and reducing you
\begin_inset Quotes ers
\end_inset

d get something like this:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

takeNormalAlternative = ->
\end_layout

\begin_layout Plain Layout

  nextAsterisk = text.indexOf '*'
\end_layout

\begin_layout Plain Layout

  nextBrace = text.indexOf '{'
\end_layout

\begin_layout Plain Layout

  end = text.length
\end_layout

\begin_layout Plain Layout

  if nextAsterisk != -1
\end_layout

\begin_layout Plain Layout

    end = nextAsterisk
\end_layout

\begin_layout Plain Layout

  if nextBrace != -1 and nextBrace < end
\end_layout

\begin_layout Plain Layout

    end = nextBrace
\end_layout

\begin_layout Plain Layout

  part = text.slice 0, end
\end_layout

\begin_layout Plain Layout

  text = text.slice end
\end_layout

\begin_layout Plain Layout

  part
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Which is even more hideous.
 Most of the time, when a decision has to be made based on a series of things,
 even if there are only two of them, writing it as array operations is nicer
 than handling every value in a separate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statement.
 (Fortunately, 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Regular-Expressions"

\end_inset

 describes an easier way to ask for the first occurrence of 
\begin_inset Quotes els
\end_inset

this or that character
\begin_inset Quotes ers
\end_inset

 in a string.)
\end_layout

\begin_layout Plain Layout
If you wrote a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

splitParagraph
\end_layout

\end_inset

 that stored fragments in a different way than the solution above, you might
 want to adjust it, because the functions in the rest of the chapter assume
 that fragments are objects with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

content
\end_layout

\end_inset

 properties.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now wire 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

processParagraph
\end_layout

\end_inset

 to also split the text inside the paragraphs, my version can be modified
 like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

processParagraph = (paragraph) ->
\end_layout

\begin_layout Plain Layout

  header = 0
\end_layout

\begin_layout Plain Layout

  while paragraph[0] == '%'
\end_layout

\begin_layout Plain Layout

    paragraph = paragraph.slice 1
\end_layout

\begin_layout Plain Layout

    header++
\end_layout

\begin_layout Plain Layout

  type: if header == 0 then 'p' else 'h' + header,
\end_layout

\begin_layout Plain Layout

  content: splitParagraph paragraph
\end_layout

\begin_layout Plain Layout

# Adhoc test
\end_layout

\begin_layout Plain Layout

recluseFile = readTextFile '06-RecluseFile.text' 
\end_layout

\begin_layout Plain Layout

paragraphs = map recluseFile.split('
\backslash
n
\backslash
n'),
\end_layout

\begin_layout Plain Layout

                 processParagraph
\end_layout

\begin_layout Plain Layout

show paragraphs, 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mapping that over the array of paragraphs gives us an array of paragraph
 objects, which in turn contain arrays of fragment objects.
 The next thing to do is to take out the footnotes, and put references to
 them in their place.
 Something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

extractFootnotes = (paragraphs) ->
\end_layout

\begin_layout Plain Layout

  footnotes = []
\end_layout

\begin_layout Plain Layout

  currentNote = 0
\end_layout

\begin_layout Plain Layout

  replaceFootnote = (fragment) ->
\end_layout

\begin_layout Plain Layout

    if fragment.type == 'footnote'
\end_layout

\begin_layout Plain Layout

      ++currentNote
\end_layout

\begin_layout Plain Layout

      footnotes.push fragment
\end_layout

\begin_layout Plain Layout

      fragment.number = currentNote
\end_layout

\begin_layout Plain Layout

      type: 'reference', number: currentNote
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      fragment
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  forEach paragraphs, (paragraph) ->
\end_layout

\begin_layout Plain Layout

    paragraph.content = map paragraph.content,
\end_layout

\begin_layout Plain Layout

                            replaceFootnote
\end_layout

\begin_layout Plain Layout

  footnotes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

replaceFootnote
\end_layout

\end_inset

 function is called on every fragment.
 When it gets a fragment that should stay where it is, it just returns it,
 but when it gets a footnote, it stores this footnote in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

footnotes
\end_layout

\end_inset

 array, and returns a reference to it instead.
 In the process, every footnote and reference is also numbered.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
That gives us enough tools to extract the information we need from the file.
 All that is left now is generating the correct 
\shape smallcaps
\size small
HTML
\shape default
\size default
.
\end_layout

\begin_layout Standard
A lot of people think that concatenating strings is a great way to produce
 
\shape smallcaps
\size small
HTML
\shape default
\size default
.
 When they need a link to, for example, a site where you can play the game
 of Go, they will do:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

url = "http://www.gokgs.com/"
\end_layout

\begin_layout Plain Layout

text = "Play Go!"
\end_layout

\begin_layout Plain Layout

linkText = "<a href=
\backslash
"#{url}
\backslash
">#{text}</a>"
\end_layout

\begin_layout Plain Layout

show linkText
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 is the tag used to create links in 
\shape smallcaps
\size small
HTML
\shape default
\size default
 documents.) \SpecialChar \ldots{}
 Not only is this clumsy, but when the string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

text
\end_layout

\end_inset

 happens to include an angular bracket or an ampersand, it is also wrong.
 Weird things will happen on your website, and you will look embarrassingly
 amateurish.
 We would not want that to happen.
 A few simple HTML-generating functions are easy to write.
 So let us write them.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The secret to successful 
\shape smallcaps
\size small
HTML
\shape default
\size default
 generation is to treat your 
\shape smallcaps
\size small
HTML
\shape default
\size default
 document as a data structure instead of a flat piece of text.
 Coffee\SpecialChar \-
Script
\begin_inset Quotes ers
\end_inset

s objects provide a very easy way to model this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

linkObject =
\end_layout

\begin_layout Plain Layout

  name: 'a'
\end_layout

\begin_layout Plain Layout

  attributes:
\end_layout

\begin_layout Plain Layout

    href: 'http://www.gokgs.com/'
\end_layout

\begin_layout Plain Layout

  content: ['Play Go!']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each 
\shape smallcaps
\size small
HTML
\shape default
\size default
 element contains a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

name
\end_layout

\end_inset

 property, giving the name of the tag it represents.
 When it has attributes, it also contains an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

attributes
\end_layout

\end_inset

 property, which contains an object in which the attributes are stored.
 When it has content, there is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

content
\end_layout

\end_inset

 property, containing an array of other elements contained in this element.
 Strings play the role of pieces of text in our 
\shape smallcaps
\size small
HTML
\shape default
\size default
 document, so the array 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

['Play Go!']
\end_layout

\end_inset

 means that this link has only one element inside it, which is a simple
 piece of text.
\end_layout

\begin_layout Standard
Typing in these objects directly is clumsy, but we do not have to do that.
 We provide a shortcut function to do this for us:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

tag = (name, content, attributes) ->
\end_layout

\begin_layout Plain Layout

  name: name
\end_layout

\begin_layout Plain Layout

  attributes: attributes
\end_layout

\begin_layout Plain Layout

  content: content
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that, since we allow the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

attributes
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

content
\end_layout

\end_inset

 of an element to be undefined if they are not applicable, the second and
 third argument to this function can be left off when they are not needed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tag
\end_layout

\end_inset

 is still rather primitive, so we write shortcuts for common types of elements,
 such as links, or the outer structure of a simple document:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

link = (target, text) ->
\end_layout

\begin_layout Plain Layout

  tag "a", [text], href: target
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show link "http://www.gokgs.com/", "Play Go!"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

htmlDoc = (title, bodyContent) ->
\end_layout

\begin_layout Plain Layout

  tag "html", [tag("head", [tag "title", [title]]),
\end_layout

\begin_layout Plain Layout

               tag "body", bodyContent]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show htmlDoc "Quote", "In his house at R'lyeh " +
\end_layout

\begin_layout Plain Layout

                      "dead Cthulu waits dreaming."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Looking back at the example 
\shape smallcaps
\size small
HTML
\shape default
\size default
 document if necessary, write an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

image
\end_layout

\end_inset

 function which, when given the location of an image file, will create an
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

img
\end_layout

\end_inset

 
\shape smallcaps
\size small
HTML
\shape default
\size default
 element.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

image = (src) ->
\end_layout

\begin_layout Plain Layout

  tag 'img', [], src: src
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When we have created a document, it will have to be reduced to a string.
 But building this string from the data structures we have been producing
 is very straightforward.
 The important thing is to remember to transform the special characters
 in the text of our document\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

escapeHTML = (text) ->
\end_layout

\begin_layout Plain Layout

  replacements = [[/&/g, '&amp;']
\end_layout

\begin_layout Plain Layout

                  [/"/g, '&quot;']
\end_layout

\begin_layout Plain Layout

                  [/</g, '&lt;']
\end_layout

\begin_layout Plain Layout

                  [/>/g, '&gt;']]
\end_layout

\begin_layout Plain Layout

  forEach replacements, (replace) ->
\end_layout

\begin_layout Plain Layout

    text = text.replace replace[0], replace[1]
\end_layout

\begin_layout Plain Layout

  text
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

replace
\end_layout

\end_inset

 method of strings creates a new string in which all occurrences of the
 pattern in the first argument are replaced by the second argument, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'Borobudur'.replace(/r/g, 'k')
\end_layout

\end_inset

 gives 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'Bokobuduk'
\end_layout

\end_inset

.
 Do not worry about the pattern syntax here — we will get to that in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Regular-Expressions"

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

escapeHTML
\end_layout

\end_inset

 function puts the different replacements that have to be made into an array,
 so that it can loop over them and apply them to the argument one by one.
\end_layout

\begin_layout Standard
Double quotes are also replaced, because we will also be using this function
 for the text inside the attributes of 
\shape smallcaps
\size small
HTML
\shape default
\size default
 tags.
 Those will be surrounded by double quotes, and thus must not have any double
 quotes inside of them.
\end_layout

\begin_layout Standard
Calling replace four times means the computer has to go over the whole string
 four times to check and replace its content.
 This is not very efficient.
 If we cared enough, we could write a more complex version of this function,
 something that resembles the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

splitParagraph
\end_layout

\end_inset

 function we saw earlier, to go over it only once.
 For now, we are too lazy for this.
 Again, 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Regular-Expressions"

\end_inset

 shows a much better way to do this.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
To turn an 
\shape smallcaps
\size small
HTML
\shape default
\size default
 element object into a string, we can use a recursive function like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

renderHTML = (element) ->
\end_layout

\begin_layout Plain Layout

  pieces = []
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  renderAttributes = (attributes) ->
\end_layout

\begin_layout Plain Layout

    result = []
\end_layout

\begin_layout Plain Layout

    if attributes
\end_layout

\begin_layout Plain Layout

      for name of attributes 
\end_layout

\begin_layout Plain Layout

        result.push ' ' + name + '="' +
\end_layout

\begin_layout Plain Layout

          escapeHTML(attributes[name]) + '"'
\end_layout

\begin_layout Plain Layout

    result.join ''
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render = (element) ->
\end_layout

\begin_layout Plain Layout

    # Text node
\end_layout

\begin_layout Plain Layout

    if typeof element is 'string'
\end_layout

\begin_layout Plain Layout

      pieces.push escapeHTML element
\end_layout

\begin_layout Plain Layout

    # Empty tag
\end_layout

\begin_layout Plain Layout

    else if not element.content or
\end_layout

\begin_layout Plain Layout

                element.content.length == 0
\end_layout

\begin_layout Plain Layout

      pieces.push '<' + element.name +
\end_layout

\begin_layout Plain Layout

        renderAttributes(element.attributes) + '/>'
\end_layout

\begin_layout Plain Layout

    # Tag with content
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      pieces.push '<' + element.name +
\end_layout

\begin_layout Plain Layout

        renderAttributes(element.attributes) + '>'
\end_layout

\begin_layout Plain Layout

      forEach element.content, render
\end_layout

\begin_layout Plain Layout

      pieces.push '</' + element.name + '>'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  render element
\end_layout

\begin_layout Plain Layout

  pieces.join ''
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset

 loop that extracts the properties from a Coffee\SpecialChar \-
Script object in order to
 make 
\shape smallcaps
\size small
HTML
\shape default
\size default
 tag attributes out of them.
 Also note that in two places, arrays are being used to accumulate strings,
 which are then joined into a single result string.
 Why did I not just start with an empty string and then add the content
 to it with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+=
\end_layout

\end_inset

 operator?
\end_layout

\begin_layout Standard
It turns out that creating new strings, especially big strings, is quite
 a lot of work.
 Remember that Coffee\SpecialChar \-
Script string values never change.
 If you concatenate something to them, a new string is created, the old
 ones stay intact.
 If we build up a big string by concatenating lots of little strings, new
 strings have to be created at every step, only to be thrown away when the
 next piece is concatenated to them.
 If, on the other hand, we store all the little strings in an array and
 then join them, only 
\emph on
one
\emph default
 big string has to be created.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
So, let us try out this 
\shape smallcaps
\size small
HTML
\shape default
\size default
 generating system\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show renderHTML link 'http://www.nedroid.com',
\end_layout

\begin_layout Plain Layout

                     'Drawings!'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That seems to work.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

body = [tag('h1', ['The Test']),
\end_layout

\begin_layout Plain Layout

        tag('p', ['Here is a paragraph ' +
\end_layout

\begin_layout Plain Layout

                  'and an image...']),
\end_layout

\begin_layout Plain Layout

        image('../img/ostrich.jpg')]
\end_layout

\begin_layout Plain Layout

doc = htmlDoc 'The Test', body
\end_layout

\begin_layout Plain Layout

show renderHTML doc
\end_layout

\begin_layout Plain Layout

# Type `stopServer()` or Ctrl-C when done.
\end_layout

\begin_layout Plain Layout

viewServer renderHTML doc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, I should probably warn you that this approach is not perfect.
 What it actually renders is 
\shape smallcaps
\size small
XML
\shape default
\size default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
XML
\end_layout

\end_inset

, which is similar to 
\shape smallcaps
\size small
HTML
\shape default
\size default
, but more structured.
 In simple cases, such as the above, this does not cause any problems.
 However, there are some things, which are correct 
\shape smallcaps
\size small
XML
\shape default
\size default
, but not proper 
\shape smallcaps
\size small
HTML
\shape default
\size default
, and these might confuse a browser that is trying to show the documents
 we create.
 For example, if you have an empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

script
\end_layout

\end_inset

 tag (used to put Java\SpecialChar \-
Script into a page) in your document, browsers will
 not realise that it is empty and think that everything after it is Java\SpecialChar \-
Script.
 (In this case, the problem can be fixed by putting a single space inside
 of the tag, so that it is no longer empty, and gets a proper closing tag.)
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

renderFragment
\end_layout

\end_inset

, and use that to implement another function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

renderParagraph
\end_layout

\end_inset

, which takes a paragraph object (with the footnotes already filtered out),
 and produces the correct 
\shape smallcaps
\size small
HTML
\shape default
\size default
 element (which might be a paragraph or a header, depending on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type
\end_layout

\end_inset

 property of the paragraph object).
\end_layout

\begin_layout Plain Layout
This function might come in useful for rendering the footnote references:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

footnote = (number) ->
\end_layout

\begin_layout Plain Layout

  tag 'sup',
\end_layout

\begin_layout Plain Layout

    [link '#footnote' + number, String number]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sup
\end_layout

\end_inset

 tag will show its content as 
\begin_inset Quotes els
\end_inset

superscript
\begin_inset Quotes ers
\end_inset

, which means it will be smaller and a little higher than other text.
 The target of the link will be something like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'#footnote1'
\end_layout

\end_inset

.
 Links that contain a 
\begin_inset Quotes els
\end_inset

#
\begin_inset Quotes ers
\end_inset

 character refer to 
\begin_inset Quotes els
\end_inset

anchors
\begin_inset Quotes ers
\end_inset

 within a page, and in this case we will use them to make it so that clicking
 on the footnote link will take the reader to the bottom of the page, where
 the footnotes live.
\end_layout

\begin_layout Plain Layout
The tag to render emphasised fragments with is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

em
\end_layout

\end_inset

, and normal text can be rendered without any extra tags.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

renderFragment = (fragment) ->
\end_layout

\begin_layout Plain Layout

  if fragment.type == 'reference'
\end_layout

\begin_layout Plain Layout

    footnote fragment.number
\end_layout

\begin_layout Plain Layout

  else if fragment.type == 'emphasised'
\end_layout

\begin_layout Plain Layout

    tag 'em', [fragment.content]
\end_layout

\begin_layout Plain Layout

  else if fragment.type == 'normal'
\end_layout

\begin_layout Plain Layout

    fragment.content
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

renderParagraph = (paragraph) ->
\end_layout

\begin_layout Plain Layout

  tag paragraph.type,
\end_layout

\begin_layout Plain Layout

    map paragraph.content, renderFragment
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show renderParagraph paragraphs[7]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are almost finished.
 The only thing that we do not have a rendering function for yet are the
 footnotes.
 To make the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'#footnote1'
\end_layout

\end_inset

 links work, an anchor must be included with every footnote.
 In 
\shape smallcaps
\size small
HTML
\shape default
\size default
, an anchor is specified with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 element, which is also used for links.
 In this case, it needs a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

name
\end_layout

\end_inset

 attribute, instead of an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

href
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

renderFootnote = (footnote) ->
\end_layout

\begin_layout Plain Layout

  anchor = tag "a", [],
\end_layout

\begin_layout Plain Layout

    name: "footnote" + footnote.number
\end_layout

\begin_layout Plain Layout

  number = "[#{footnote.number}] "
\end_layout

\begin_layout Plain Layout

  tag "p", [tag("small",
\end_layout

\begin_layout Plain Layout

    [anchor, number, footnote.content])]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, then, is the function which, when given a file in the correct format
 and a document title, returns an 
\shape smallcaps
\size small
HTML
\shape default
\size default
 document:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

renderFile = (file, title) ->
\end_layout

\begin_layout Plain Layout

  paragraphs = map file.split('
\backslash
n
\backslash
n'),
\end_layout

\begin_layout Plain Layout

                   processParagraph
\end_layout

\begin_layout Plain Layout

  footnotes = map extractFootnotes(paragraphs),
\end_layout

\begin_layout Plain Layout

                  renderFootnote
\end_layout

\begin_layout Plain Layout

  body = map paragraphs,
\end_layout

\begin_layout Plain Layout

             renderParagraph
\end_layout

\begin_layout Plain Layout

  body = body.concat footnotes
\end_layout

\begin_layout Plain Layout

  renderHTML htmlDoc title, body
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

page = renderFile recluseFile, 'The Book of Programming'
\end_layout

\begin_layout Plain Layout

show page
\end_layout

\begin_layout Plain Layout

# Type `stopServer()` or Ctrl-C when done.
\end_layout

\begin_layout Plain Layout

viewServer page
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
concat
\end_layout

\end_inset

 method of an array can be used to concatenate another array to it, similar
 to what the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

 operator does with strings.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
In the chapters after this one, elementary higher-order functions like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 will always be available from the Underscore library and will be used by
 code examples.
 Now and then, a new useful tool is explained and added to this.
 In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Modularity"

\end_inset

, we develop a more structured approach to this set of 
\begin_inset Quotes els
\end_inset

basic
\begin_inset Quotes ers
\end_inset

 functions.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
In some functional programming languages operators are functions, for example
 in Pure you can write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldl (+) 0 (1..10);
\end_layout

\end_inset

 the same in Coffee\SpecialChar \-
Script is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce [1..10], ((a, b) -> a + b), 0
\end_layout

\end_inset

.
 A way to shorten this is by defining an object that is indexed by an operator
 in a string:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

op = {
\end_layout

\begin_layout Plain Layout

       '+':   (a, b) -> a + b
\end_layout

\begin_layout Plain Layout

       '==':  (a, b) -> a == b
\end_layout

\begin_layout Plain Layout

       '!':   (a)    -> !a
\end_layout

\begin_layout Plain Layout

       # and so on
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

show reduce [1..10], op['+'], 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The list of operators is quite long, so it is questionable whether such
 a data structure improves readability compared to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

add = (a, b) -> a + b
\end_layout

\begin_layout Plain Layout

show reduce [1..10], add, 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And what if we need something like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeAddFunction
\end_layout

\end_inset

, in which one of the arguments already has a value? In that case we are
 back to writing a new function again.
\end_layout

\begin_layout Standard
For cases like that, something called 
\begin_inset Quotes els
\end_inset

partial application
\begin_inset Quotes ers
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
partial application
\end_layout

\end_inset

 is useful.
 You want to create a new function that already knows some of its arguments,
 and treats any additional arguments it is passed as coming after these
 fixed arguments.
 A simple version of this could be:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

partial = (func, a...) ->
\end_layout

\begin_layout Plain Layout

  (b...) -> func a..., b...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f = (a,b,c,d) -> show "#{a} #{b} #{c} #{d}"
\end_layout

\begin_layout Plain Layout

g = partial f, 1, 2
\end_layout

\begin_layout Plain Layout

g 3, 4
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The return value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

partial
\end_layout

\end_inset

 is a function where the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a...
\end_layout

\end_inset

 arguments have been applied.
 When the returned function is called the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b...
\end_layout

\end_inset

 arguments are appended to the arguments of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

equals10 = partial op['=='], 10
\end_layout

\begin_layout Plain Layout

show map [1, 10, 100], equals10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike traditional functional definitions, Underscore defines the order
 of its arguments as array before action.
 That means we can not simply say: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

square = (x) -> x * x
\end_layout

\begin_layout Plain Layout

show map [[10, 100], [12, 16], [0, 1]],
\end_layout

\begin_layout Plain Layout

         partial map, square # Incorrect
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the square function needs to be the second argument of the inner map.
 But we can define another partial function that reverses its arguments:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

partialReverse = (func, a) -> (b) -> func b, a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mapSquared = partialReverse map, square
\end_layout

\begin_layout Plain Layout

show map [[10, 100], [12, 16], [0, 1]], mapSquared
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However it is again worthwhile to consider whether the intent of the program
 is clearer when the functions are defined directly:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show map [[10, 100], [12, 16], [0, 1]],
\end_layout

\begin_layout Plain Layout

  (sublist) -> map sublist, (x) -> x * x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
A trick that can be useful when you want to combine functions is function
 composition
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
function composition
\end_layout

\end_inset

.
 At the start of this chapter I showed a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

negate
\end_layout

\end_inset

, which applies the boolean 
\emph on
not
\emph default
 operator to the result of calling a function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

negate = (func) ->
\end_layout

\begin_layout Plain Layout

  (args...) -> not func args...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a special case of a general pattern: call function A, and then apply
 function B to the result.
 Composition is a common concept in mathematics.
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
compose
\end_layout

\end_inset

It can be caught in a higher-order function like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

compose = (func1, func2) ->
\end_layout

\begin_layout Plain Layout

  (args...) -> func1 func2 args...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isUndefined = (value) -> value is undefined
\end_layout

\begin_layout Plain Layout

isDefined = compose ((v) -> not v), isUndefined
\end_layout

\begin_layout Plain Layout

show 'isDefined Math.PI  = ' + isDefined Math.PI
\end_layout

\begin_layout Plain Layout

show 'isDefined Math.PIE = ' + isDefined Math.PIE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isDefined
\end_layout

\end_inset

 we are defining a new function without naming it.
 This can be useful when you need to create a simple function to give to,
 for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.
 However, when a function becomes more complex than this example, it is
 usually shorter and clearer to define it by itself and name it.
\end_layout

\begin_layout Chapter
Searching
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Searching
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Searching"

\end_inset


\end_layout

\begin_layout Standard
This chapter introduces new functional programming concepts and their use
 in problem solving.
 We will go through the solution of two problems, discussing some interesting
 algorithms and techniques along the way.
 To make it pleasant to work with the functional abstractions, the functions
 in the Underscore library are made directly available for use in the examples.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require './prelude'
\end_layout

\begin_layout Plain Layout

globalize _
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using global functions is fine in an isolated environment, later when you
 build reusable libraries or work in a project you should however fully
 qualify all functions, this is explained in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Modularity"

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Let me introduce our first problem.
 Take a look at this map.
 It shows Hiva Oa, a small tropical island in the Pacific Ocean.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/Hiva Oa.png
	lyxscale 70
	width 100text%
	BoundingBox 0bp 60bp 1024bp 730bp
	clip

\end_inset


\end_layout

\begin_layout Standard
The black lines are roads, and the numbers next to them are the lengths
 of these roads.
 Imagine we need a program that finds the shortest route between two points
 on Hiva Oa.
 How could we approach that? Think about this for a moment.
\end_layout

\begin_layout Standard
No really.
 Do not just steamroll on to the next paragraph.
 Try to seriously think of some ways you could do this, and consider the
 issues you would come up against.
 When reading a technical book, it is way too easy to just zoom over the
 text, nod solemnly, and promptly forget what you have read.
 If you make a sincere effort to solve a problem, it becomes 
\emph on
your
\emph default
 problem, and its solution will be more meaningful.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The first aspect of this problem is, again, representing our data.
 The information in the picture does not mean much to our computer.
 We could try writing a program that looks at the map and extracts the informati
on in it\SpecialChar \ldots{}
 but that can get complicated.
 If we had twenty-thousand maps to interpret, this would be a good idea,
 in this case we will do the interpretation ourself and transcribe the map
 into a more computer-friendly format.
\end_layout

\begin_layout Standard
What does our program need to know? It has to be able to look up which locations
 are connected, and how long the roads between them are.
 The places and roads on the island form a graph
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
graph
\end_layout

\end_inset

, as mathematicians call it.
 There are many ways to store graphs.
 A simple possibility is to just store an array of road objects, each of
 which contains properties naming its two endpoints and its length\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

roads = [
\end_layout

\begin_layout Plain Layout

  { point1: 'Point Kiukiu', point2: 'Hanaiapa', length: 19 }
\end_layout

\begin_layout Plain Layout

  { point1: 'Point Kiukiu', point2: 'Mt Feani', length: 15 }
\end_layout

\begin_layout Plain Layout

] # and so on
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, it turns out that the program, as it is working out a route, will
 very often need to get a list of all the roads that start at a certain
 location, like a person standing on a crossroads will look at a signpost
 and read 
\begin_inset Quotes eld
\end_inset

Hanaiapa: 19km, Mount Feani: 15km
\begin_inset Quotes erd
\end_inset

.
 It would be nice if this was easy (and quick) to do.
\end_layout

\begin_layout Standard
With the representation given above, we have to sift through the whole list
 of roads, picking out the relevant ones, every time we want this signpost
 list.
 A better approach would be to store this list directly.
 For example, use an object that associates place-names with signpost lists:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

roads =
\end_layout

\begin_layout Plain Layout

  'Point Kiukiu': [ {to: 'Hanaiapa', distance: 19}
\end_layout

\begin_layout Plain Layout

                    {to: 'Mt Feani', distance: 15}
\end_layout

\begin_layout Plain Layout

                    {to: 'Taaoa', distance: 15} ]
\end_layout

\begin_layout Plain Layout

  'Taaoa':        [ ] # et cetera
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When we have this object, getting the roads that leave from Point Kiukiu
 is just a matter of looking at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

roads['Point Kiukiu']
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
However, this new representation does contain duplicate information: The
 road between A and B is listed both under A and under B.
 The first representation was already a lot of work to type in, this one
 is even worse.
\end_layout

\begin_layout Standard
Fortunately, we have at our command the computer
\begin_inset Quotes ers
\end_inset

s talent for repetitive work.
 We can specify the roads once, and have the correct data structure be generated
 by the computer.
 First, initialise an empty object called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

roads
\end_layout

\end_inset

, and write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeRoad
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

roads = {}
\end_layout

\begin_layout Plain Layout

makeRoad = (from, to, length) ->
\end_layout

\begin_layout Plain Layout

  addRoad = (from, to) ->
\end_layout

\begin_layout Plain Layout

    roads[from] = [] if not (from of roads)
\end_layout

\begin_layout Plain Layout

    roads[from].push to: to, distance: length
\end_layout

\begin_layout Plain Layout

  addRoad from, to
\end_layout

\begin_layout Plain Layout

  addRoad to, from
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nice, huh? Notice how the inner function, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRoad
\end_layout

\end_inset

, uses the same names (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

from
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

to
\end_layout

\end_inset

) for its parameters as the outer function.
 These will not interfere: inside 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRoad
\end_layout

\end_inset

 they refer to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRoad
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

s parameters, and outside it they refer to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeRoad
\end_layout

\end_inset


\begin_inset Quotes ers
\end_inset

s parameters.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statement in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRoad
\end_layout

\end_inset

 makes sure that there is an array of destinations associated with the location
 named by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

from
\end_layout

\end_inset

, if there is not one it puts in an empty array.
 This way, the next line can assume there is such an array and safely push
 the new road onto it.
\end_layout

\begin_layout Standard
Now the map information looks like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

makeRoad 'Point Kiukiu', 'Hanaiapa', 19
\end_layout

\begin_layout Plain Layout

makeRoad 'Point Kiukiu', 'Mt Feani', 15
\end_layout

\begin_layout Plain Layout

makeRoad 'Point Kiukiu', 'Taaoa', 15
\end_layout

\begin_layout Plain Layout

show roads
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In the above description, the string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'Point Kiukiu'
\end_layout

\end_inset

 still occurs three times in a row.
 We could make our description even more succinct by allowing multiple roads
 to be specified in one line.
\end_layout

\begin_layout Plain Layout
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeRoads
\end_layout

\end_inset

 that takes any uneven number of arguments.
 The first argument is always the starting point of the roads, and every
 pair of arguments after that gives an ending point and a distance.
\end_layout

\begin_layout Plain Layout
Do not duplicate the functionality of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeRoad
\end_layout

\end_inset

, but have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeRoads
\end_layout

\end_inset

 call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeRoad
\end_layout

\end_inset

 to do the actual road-making.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

makeRoads = (start) ->
\end_layout

\begin_layout Plain Layout

  for i in [1...arguments.length] by 2
\end_layout

\begin_layout Plain Layout

    makeRoad start, arguments[i], arguments[i + 1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This function uses one named parameter, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

start
\end_layout

\end_inset

, and gets the other parameters from the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arguments
\end_layout

\end_inset

 (quasi-) array.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i
\end_layout

\end_inset

 starts at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 because it has to skip this first parameter.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

by 2
\end_layout

\end_inset

 skips the distances.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can verify the solution with this code that builds a data structure
 matching the map of Hiva Oa.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

roads = {}
\end_layout

\begin_layout Plain Layout

makeRoads 'Point Kiukiu',
\end_layout

\begin_layout Plain Layout

  'Hanaiapa', 19, 'Mt Feani', 15, 'Taaoa', 15
\end_layout

\begin_layout Plain Layout

makeRoads 'Airport',
\end_layout

\begin_layout Plain Layout

  'Hanaiapa', 6, 'Mt Feani', 5,
\end_layout

\begin_layout Plain Layout

  'Atuona', 4, 'Mt Ootua', 11
\end_layout

\begin_layout Plain Layout

makeRoads 'Mt Temetiu',
\end_layout

\begin_layout Plain Layout

  'Mt Feani', 8, 'Taaoa', 4
\end_layout

\begin_layout Plain Layout

makeRoads 'Atuona',
\end_layout

\begin_layout Plain Layout

  'Taaoa', 3, 'Hanakee pearl lodge', 1
\end_layout

\begin_layout Plain Layout

makeRoads 'Cemetery',
\end_layout

\begin_layout Plain Layout

  'Hanakee pearl lodge', 6, 'Mt Ootua', 5
\end_layout

\begin_layout Plain Layout

makeRoads 'Hanapaoa',
\end_layout

\begin_layout Plain Layout

  'Mt Ootua', 3
\end_layout

\begin_layout Plain Layout

makeRoads 'Puamua',
\end_layout

\begin_layout Plain Layout

  'Mt Ootua', 13, 'Point Teohotepapapa', 14
\end_layout

\begin_layout Plain Layout

show 'Roads from the Airport:'
\end_layout

\begin_layout Plain Layout

show roads['Airport']
\end_layout

\end_inset

We managed to considerably shorten our description of the road in\SpecialChar \-
for\SpecialChar \-
ma\SpecialChar \-
tion
 by defining some convenient operations.
 You could say we expressed the information more succinctly by expanding
 our vocabulary.
 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
domain-specific language
\end_layout

\end_inset

Defining a 
\begin_inset Quotes els
\end_inset

little language
\begin_inset Quotes ers
\end_inset

 like this is often a very powerful technique — when, at any time, you find
 yourself writing repetitive or redundant code, stop and try to come up
 with a vocabulary that makes it shorter and denser.
\end_layout

\begin_layout Standard
Redundant code is not only a bore to write, it is also error-prone, people
 pay less attention when doing something that does not require them to think.
 On top of that, repetitive code is hard to change, because structure that
 is repeated a hundred times has to be changed a hundred times when it turns
 out to be incorrect or suboptimal.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
If you ran all the pieces of code above, you should now have a variable
 named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

roads
\end_layout

\end_inset

 that contains all the roads on the island.
 When we need the roads starting from a certain place, we could just do
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

roads[place]
\end_layout

\end_inset

.
 But then, when someone makes a typo in a place name, which is not unlikely
 with these names, he will get 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 instead of the array he expects, and strange errors will follow.
 Instead, we will use a function that retrieves the road arrays, and yells
 at us when we give it an unknown place name:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

roadsFrom = (place) ->
\end_layout

\begin_layout Plain Layout

  found = roads[place]
\end_layout

\begin_layout Plain Layout

  return found if found?
\end_layout

\begin_layout Plain Layout

  throw new Error "No place named '#{place}' found."
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

  show roadsFrom "Hanaiapa"
\end_layout

\begin_layout Plain Layout

  show roadsFrom "Hanalapa"
\end_layout

\begin_layout Plain Layout

catch error
\end_layout

\begin_layout Plain Layout

  show "Oops #{error}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Here is a first stab at a path-finding algorithm, the gambler
\begin_inset Quotes ers
\end_inset

s method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

gamblerPath = (from, to) ->
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  randomInteger = (below) ->
\end_layout

\begin_layout Plain Layout

    Math.floor Math.random() * below
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  randomDirection = (from) ->
\end_layout

\begin_layout Plain Layout

    options = roadsFrom from
\end_layout

\begin_layout Plain Layout

    options[randomInteger(options.length)].to
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  path = []
\end_layout

\begin_layout Plain Layout

  loop
\end_layout

\begin_layout Plain Layout

    path.push from
\end_layout

\begin_layout Plain Layout

    break if from == to
\end_layout

\begin_layout Plain Layout

    from = randomDirection from
\end_layout

\begin_layout Plain Layout

  path
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show gamblerPath 'Hanaiapa', 'Mt Feani'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At every split in the road, the gambler rolls his dice to decide which road
 he shall take.
 If the dice sends him back the way he came, so be it.
 Sooner or later, he will arrive at his destination, since all places on
 the island are connected by roads.
\end_layout

\begin_layout Standard
The most confusing line is probably the one containing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.random
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Math.random
\end_layout

\end_inset

.
 This function returns a pseudo-random
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Computers are deterministic machines: They always react in the same way
 to the input they receive, so they can not produce truly random values.
 Therefore, we have to make do with series of numbers that look random,
 but are in fact the result of some complicated deterministic computation.
\end_layout

\end_inset

 number between 0 and 1.
 Try calling it a few times from the console, it will (most likely) give
 you a different number every time.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

randomInteger
\end_layout

\end_inset

 multiplies this number by the argument it is given, and rounds the result
 down with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math.floor
\end_layout

\end_inset

.
 Thus, for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

randomInteger 3
\end_layout

\end_inset

 will produce the number 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The gambler
\begin_inset Quotes ers
\end_inset

s method is the way to go for those who abhor structure and planning, who
 desperately search for adventure.
 We set out to write a program that could find the 
\emph on
shortest
\emph default
 route between places though, so something else will be needed.
\end_layout

\begin_layout Standard
A very straightforward approach to solving such a problem is called 
\begin_inset Quotes els
\end_inset

generate and test
\begin_inset Quotes ers
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
generate and test
\end_layout

\end_inset

.
 It goes like this:
\end_layout

\begin_layout Enumerate
Generate all possible routes.
\end_layout

\begin_layout Enumerate
In this set, find the shortest one that actually connects the start point
 to the end point.
\end_layout

\begin_layout Standard
Step two is not hard.
 Step one is a little problematic.
 If you allow routes with circles in them, there is an infinite amount of
 routes.
 Of course, routes with circles in them are unlikely to be the shortest
 route to anywhere, and routes that do not start at the start point do not
 have to be considered either.
 For a small graph like Hiva Oa, it should be possible to generate all non-cycli
c (circle-free) routes starting from a certain point.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
But first, we will need to expand our vocabulary so we can deal with the
 problem in a natural way.
 The words we need exist in CoffeeScript and in the Underscore library,
 but we will go through how they can be implemented, so it is clear how
 they function and what they do.
 The example implementations will be named with an underscore in front of
 their names to show they are internal and not used in the rest of the book.
 You can compare with the implementations in the literate documentation
 of the Underscore library in 
\begin_inset listings
lstparams "language=bash,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

src/docs
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The first is a function named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_member
\end_layout

\end_inset

, which is used to determine whether an element is found within an array.
 The route will be kept as an array of names, and when arriving at a new
 place, the algorithm could logically call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_member
\end_layout

\end_inset

 to check whether we have been at that place already.
 It could look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

_member = (array, value) ->
\end_layout

\begin_layout Plain Layout

  found = false
\end_layout

\begin_layout Plain Layout

  array.forEach (element) ->
\end_layout

\begin_layout Plain Layout

    if element == value
\end_layout

\begin_layout Plain Layout

      found = true
\end_layout

\begin_layout Plain Layout

  found
\end_layout

\begin_layout Plain Layout

show _member [6, 7, "Bordeaux"], 7
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, this will go over the whole array, even if the value is found immediate
ly at the first position.
 What wastefulness.
 When using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 loop, you can use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 statement to jump out of it, but in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 construct this will not work, because the body of the loop is a function,
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 statements do not jump out of functions.
 One solution could be to adjust 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 to recognise a certain kind of exceptions as signalling a break.
 Something like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_forEach
\end_layout

\end_inset

 here:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

_break = toString: -> "Break"
\end_layout

\begin_layout Plain Layout

_forEach = (array, action) ->
\end_layout

\begin_layout Plain Layout

  try
\end_layout

\begin_layout Plain Layout

    for element in array
\end_layout

\begin_layout Plain Layout

      action element
\end_layout

\begin_layout Plain Layout

  catch exception
\end_layout

\begin_layout Plain Layout

    if exception != _break
\end_layout

\begin_layout Plain Layout

      throw exception
\end_layout

\begin_layout Plain Layout

show _forEach [1..3], (n) -> n*n
\end_layout

\begin_layout Plain Layout

# Which btw could in CoffeeScript be written as
\end_layout

\begin_layout Plain Layout

show (i*i for i in [1..3])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

action
\end_layout

\end_inset

 function throws 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_break
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_forEach
\end_layout

\end_inset

 will absorb the exception and stop looping.
 The object stored in the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_break
\end_layout

\end_inset

 is used purely as a thing to compare with.
 The only reason I gave it a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toString
\end_layout

\end_inset

 property is that this might be useful to figure out what kind of strange
 value you are dealing with if you somehow end up with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_break
\end_layout

\end_inset

 exception outside of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_forEach
\end_layout

\end_inset

.
 Now 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_member
\end_layout

\end_inset

 can be defined as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

_member = (array, value) ->
\end_layout

\begin_layout Plain Layout

  found = false
\end_layout

\begin_layout Plain Layout

  _forEach array, (element) ->
\end_layout

\begin_layout Plain Layout

    if element == value
\end_layout

\begin_layout Plain Layout

      found = true
\end_layout

\begin_layout Plain Layout

      throw _Break
\end_layout

\begin_layout Plain Layout

  found
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course we could also have defined 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_member
\end_layout

\end_inset

 without using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_forEach
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

_member = (array, value) ->
\end_layout

\begin_layout Plain Layout

  found = false
\end_layout

\begin_layout Plain Layout

  for element in array
\end_layout

\begin_layout Plain Layout

    if element == value
\end_layout

\begin_layout Plain Layout

      found = true
\end_layout

\begin_layout Plain Layout

      break
\end_layout

\begin_layout Plain Layout

  found
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function exists in Underscore as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

include
\end_layout

\end_inset

 aka 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contains
\end_layout

\end_inset

.
 But it is such a common operation that it is in fact built into CoffeeScript
 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

in
\end_layout

\end_inset

 operator (outside of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 \SpecialChar \ldots{}
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

in
\end_layout

\end_inset

).
 Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

in
\end_layout

\end_inset

 is the preferred way to test for array membership.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

show 7 in [6, 7, "Bordeaux"] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Having a way to break out of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_forEach
\end_layout

\end_inset

 loops can be very useful, but in the case of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_member
\end_layout

\end_inset

 function the result is still rather ugly, because you need to specifically
 store the result and later return it.
 We could add yet another kind of exception, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_return
\end_layout

\end_inset

, which can be given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

value
\end_layout

\end_inset

 property, and have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_forEach
\end_layout

\end_inset

 return this value when such an exception is thrown, but this would be terribly
 ad-hoc and messy.
 What we really need is a whole new higher-order function, called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

any
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
any
\end_layout

\end_inset

 (or sometimes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

some
\end_layout

\end_inset

).
 It exists in Underscore under both names.
 A definition more or less looks like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

_any = (array, test) ->
\end_layout

\begin_layout Plain Layout

  for element in array
\end_layout

\begin_layout Plain Layout

    if test element
\end_layout

\begin_layout Plain Layout

      return true
\end_layout

\begin_layout Plain Layout

  false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Using Underscore
\end_layout

\begin_layout Plain Layout

show any [3, 4, 0, -3, 2, 1], (n) -> n < 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Redefining member with any
\end_layout

\begin_layout Plain Layout

_member = (array, value) ->
\end_layout

\begin_layout Plain Layout

  partial = (func, a...) -> (b...) -> func a..., b...
\end_layout

\begin_layout Plain Layout

  any array, partial ((a,b) -> a == b), value
\end_layout

\begin_layout Plain Layout

show _member ["Fear", "Loathing"], "Denial"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

any
\end_layout

\end_inset

 goes over the elements in an array, from left to right, and applies the
 test function to them.
 The first time this returns a true-ish value, it returns that value.
 If no true-ish value is found, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 is returned.
 Calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

any(test, array)
\end_layout

\end_inset

 is more or less equivalent to doing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

test(array[0]) ||
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

test(array[1]) || ...
\end_layout

\end_inset

 etcetera.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Just like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&&
\end_layout

\end_inset

 is the companion of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

any
\end_layout

\end_inset

 has a companion called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

every
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
every
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

_every = (array, test) ->
\end_layout

\begin_layout Plain Layout

  for element in array
\end_layout

\begin_layout Plain Layout

    if not test element
\end_layout

\begin_layout Plain Layout

      return false
\end_layout

\begin_layout Plain Layout

  true
\end_layout

\begin_layout Plain Layout

show every [1, 2, -1], (n) -> n != 0 # Using Underscore
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Another function we will need is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

.
 This function takes an array of arrays, and puts the elements of the arrays
 together in one big array.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

_flatten = (array) ->
\end_layout

\begin_layout Plain Layout

  result = []
\end_layout

\begin_layout Plain Layout

  for element in array
\end_layout

\begin_layout Plain Layout

    if isArray element
\end_layout

\begin_layout Plain Layout

      result = result.concat _flatten element
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      result.push element
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Using Underscore
\end_layout

\begin_layout Plain Layout

show flatten [[1], [2, [3, 4]], [5, 6]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Before starting to generate routes, we need one more higher-order function.
 This one is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
filter
\end_layout

\end_inset

 (in Underscore it is also named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

select
\end_layout

\end_inset

).
 Like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, it takes a function and an array as arguments, and produces a new array,
 but instead of putting the results of calling the function in the new array,
 it produces an array with only those values from the old array for which
 the given function returns a true-like value.
 Write a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_filter
\end_layout

\end_inset

 function that shows how it works.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

_filter = (array, test) ->
\end_layout

\begin_layout Plain Layout

  result = []
\end_layout

\begin_layout Plain Layout

  for element in array
\end_layout

\begin_layout Plain Layout

    if test element
\end_layout

\begin_layout Plain Layout

      result.push element
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show _filter [0, 4, 8, 12], (n) -> n < 5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

isOdd = (n) -> n % 2 != 0
\end_layout

\begin_layout Plain Layout

show filter [0..6], isOdd # Using Underscore
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Imagine what an algorithm to generate routes would look like — it starts
 at the starting location, and starts to generate a route for every road
 leaving there.
 At the end of each of these roads it continues to generate more routes.
 It does not run along one road, it branches out.
 Because of this, recursion
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
recursion
\end_layout

\end_inset

 is a natural way to model it.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

possibleRoutes = (from, to) ->
\end_layout

\begin_layout Plain Layout

  findRoutes = (route) ->
\end_layout

\begin_layout Plain Layout

    notVisited = (road) ->
\end_layout

\begin_layout Plain Layout

      not (road.to in route.places)
\end_layout

\begin_layout Plain Layout

    continueRoute = (road) ->
\end_layout

\begin_layout Plain Layout

      findRoutes 
\end_layout

\begin_layout Plain Layout

        places: route.places.concat([road.to]),
\end_layout

\begin_layout Plain Layout

        length: route.length + road.distance
\end_layout

\begin_layout Plain Layout

    end = route.places[route.places.length - 1]
\end_layout

\begin_layout Plain Layout

    if end == to
\end_layout

\begin_layout Plain Layout

      [route]
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      flatten map filter(roadsFrom(end), notVisited),
\end_layout

\begin_layout Plain Layout

                  continueRoute
\end_layout

\begin_layout Plain Layout

  findRoutes {places: [from], length: 0}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show (possibleRoutes 'Point Teohotepapapa',
\end_layout

\begin_layout Plain Layout

                     'Point Kiukiu').length
\end_layout

\begin_layout Plain Layout

show possibleRoutes 'Hanapaoa', 'Mt Ootua' 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function returns an array of route objects, each of which contains an
 array of places that the route passes, and a length.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findRoutes
\end_layout

\end_inset

 recursively continues a route, returning an array with every possible extension
 of that route.
 When the end of a route is the place where we want to go, it just returns
 that route, since continuing past that place would be pointless.
 If it is another place, we must go on.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 line is probably the hardest to read.
 This is what it says: 
\begin_inset Quotes els
\end_inset

Take all the roads going from the current location, discard the ones that
 go to places that this route has already visited.
 Continue each of these roads, which will give an array of finished routes
 for each of them, then put all these routes into a single big array that
 we return.
\begin_inset Quotes ers
\end_inset


\end_layout

\begin_layout Standard
That line does a lot.
 This is why good abstractions help: They allow you to say complicated things
 without typing pages of code.
\end_layout

\begin_layout Standard
Does this not recurse forever, seeing how it calls itself (via 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

continueRoute
\end_layout

\end_inset

)? No, at some point, all outgoing roads will go to places that a route
 has already passed, and the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 will be an empty array.
 Mapping over an empty array produces an empty array, and flattening that
 still gives an empty array.
 So calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findRoutes
\end_layout

\end_inset

 on a dead end produces an empty array, meaning 
\begin_inset Quotes els
\end_inset

there are no ways to continue this route
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
Notice that places are appended to routes by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
concat
\end_layout

\end_inset

, not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

push
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
push
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 method creates a new array, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

push
\end_layout

\end_inset

 modifies the existing array.
 Because the function might branch off several routes from a single partial
 route, we must not modify the array that represents the original route,
 because it must be used several times.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Now that we have all possible routes, let us try to find the shortest one.
 Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shortestRoute
\end_layout

\end_inset

 that, like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

possibleRoutes
\end_layout

\end_inset

, takes the names of a starting and ending location as arguments.
 It returns a single route object, of the type that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

possibleRoutes
\end_layout

\end_inset

 produces.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

shortestRoute = (from, to) ->
\end_layout

\begin_layout Plain Layout

  currentShortest = null
\end_layout

\begin_layout Plain Layout

  forEach possibleRoutes(from, to), (route) ->
\end_layout

\begin_layout Plain Layout

    if not currentShortest or
\end_layout

\begin_layout Plain Layout

       currentShortest.length > route.length
\end_layout

\begin_layout Plain Layout

      currentShortest = route 
\end_layout

\begin_layout Plain Layout

  currentShortest
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The tricky thing in 
\begin_inset Quotes els
\end_inset

minimising
\begin_inset Quotes ers
\end_inset

 or 
\begin_inset Quotes els
\end_inset

maximising
\begin_inset Quotes ers
\end_inset

 algorithms is to not screw up when given an empty array.
 In this case, we happen to know that there is at least one road between
 every two places, so we could just ignore it.
 But that would be a bit lame.
 What if the road from Puamua to Mount Ootua, which is steep and muddy,
 is washed away by a rainstorm? It would be a shame if this caused our function
 to break as well, so it takes care to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 when no routes are found.
\end_layout

\begin_layout Plain Layout
Then, the very functional, abstract-everything-we-can approach:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

minimise = (func, array) ->
\end_layout

\begin_layout Plain Layout

  minScore = null
\end_layout

\begin_layout Plain Layout

  found = null
\end_layout

\begin_layout Plain Layout

  forEach array, ( (element) ->
\end_layout

\begin_layout Plain Layout

    score = func element
\end_layout

\begin_layout Plain Layout

    if minScore == null || score < minScore
\end_layout

\begin_layout Plain Layout

      minScore = score
\end_layout

\begin_layout Plain Layout

      found = element )
\end_layout

\begin_layout Plain Layout

  found
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

getProperty = (propName) ->
\end_layout

\begin_layout Plain Layout

  (object) -> object[propName]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

shortestRoute = (from, to) ->
\end_layout

\begin_layout Plain Layout

  minimise getProperty('length'),
\end_layout

\begin_layout Plain Layout

           possibleRoutes(from, to)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Unfortunately, it is two times longer than the other version.
 In programs where you need to minimise several things it might be a good
 idea to write the generic algorithm like this, so you can re-use it.
 In most cases the first version is probably good enough.
\end_layout

\begin_layout Plain Layout
Note the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getProperty
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
getProperty
\end_layout

\end_inset

 function though, it is often useful when doing functional programming with
 objects.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us see what route our algorithm comes up with between Point Kiukiu and
 Point Teohotepapapa\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show (shortestRoute 'Point Kiukiu',
\end_layout

\begin_layout Plain Layout

  'Point Teohotepapapa').places
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
On a small island like Hiva Oa, it is not too much work to generate all
 possible routes.
 If you try to do that on a reasonably detailed map of, say, Belgium, it
 is going to take an absurdly long time, not to mention an absurd amount
 of memory.
 Still, you have probably seen those online route-planners.
 These give you a more or less optimal route through a gigantic maze of
 roads in just a few seconds.
 How do they do it?
\end_layout

\begin_layout Standard
If you are paying attention, you may have noticed that it is not necessary
 to generate all routes all the way to the end.
 If we start comparing routes 
\emph on
while
\emph default
 we are building them, we can avoid building this big set of routes, and,
 as soon as we have found a single route to our destination, we can stop
 extending routes that are already longer than that route.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
To try this out, we will use a 20 by 20 grid as our map:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/height.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
What you see here is an elevation map of a mountain landscape.
 The yellowish spots are the peaks, and the dark spots the valleys.
 The area is divided into squares with a size of a hundred meters.
 We have at our disposal a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

heightAt
\end_layout

\end_inset

, which can give us the height, in meters, of any square on that map, where
 squares are represented by objects with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 properties.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show heightAt x:  0, y:  0
\end_layout

\begin_layout Plain Layout

show heightAt x: 11, y: 18
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
We want to cross this landscape, on foot, from the top left to the bottom
 right.
 A grid can be approached like a graph.
 Every square is a node, which is connected to the squares around it.
\end_layout

\begin_layout Standard
We do not like wasting energy, so we would prefer to take the easiest route
 possible.
 Going uphill is heavier than going downhill, and going downhill is heavier
 than going level
\begin_inset Foot
status open

\begin_layout Plain Layout
No really, it is.
\end_layout

\end_inset

.
 This function calculates the amount of 
\begin_inset Quotes els
\end_inset

weighted meters
\begin_inset Quotes ers
\end_inset

, between two adjacent squares, which represents how tired you get from
 walking (or climbing) between them.
 Going uphill is counted as twice as heavy as going downhill.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

weightedDistance = (pointA, pointB) ->
\end_layout

\begin_layout Plain Layout

  heightDifference =
\end_layout

\begin_layout Plain Layout

    heightAt(pointB) - heightAt(pointA)
\end_layout

\begin_layout Plain Layout

  climbFactor = if heightDifference < 0 then 1 else 2
\end_layout

\begin_layout Plain Layout

  flatDistance =
\end_layout

\begin_layout Plain Layout

    if pointA.x == pointB.x or pointA.y == pointB.y
\end_layout

\begin_layout Plain Layout

      100
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      141
\end_layout

\begin_layout Plain Layout

  flatDistance + climbFactor * Math.abs heightDifference
\end_layout

\begin_layout Plain Layout

show weightedDistance (x: 0, y: 0), (x: 1, y: 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatDistance
\end_layout

\end_inset

 calculation.
 If the two points are on the same row or column, they are right next to
 each other, and the distance between them is a hundred meters.
 Otherwise, they are assumed to be diagonally adjacent, and the diagonal
 distance between two squares of this size is a hundred times the square
 root of two, which is approximately 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

141
\end_layout

\end_inset

.
 One is not allowed to call this function for squares that are further than
 one step apart.
 (It could double-check this\SpecialChar \ldots{}
 but it is too lazy.)
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Points on the map are represented by objects containing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 properties.
 These three functions are useful when working with such objects:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

point = (x, y) -> {x, y} # Same as {x: x, y: y}
\end_layout

\begin_layout Plain Layout

addPoints = (a, b) -> point a.x + b.x, a.y + b.y
\end_layout

\begin_layout Plain Layout

samePoint = (a, b) -> a.x == b.x and a.y == b.y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show samePoint addPoints(point(10, 10), point(4, -2)),
\end_layout

\begin_layout Plain Layout

                         point(14, 8)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
If we are going to find routes through this map, we will again need a function
 to create 
\begin_inset Quotes els
\end_inset

signposts
\begin_inset Quotes ers
\end_inset

, lists of directions that can be taken from a given point.
 Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

possibleDirections
\end_layout

\end_inset

, which takes a point object as argument and returns an array of nearby
 points.
 We can only move to adjacent points, both straight and diagonally, so squares
 have a maximum of eight neighbours.
 Take care not to return squares that lie outside of the map.
 For all we know the edge of the map might be the edge of the world.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

possibleDirections = (from) ->
\end_layout

\begin_layout Plain Layout

  mapSize = 20
\end_layout

\begin_layout Plain Layout

  insideMap = (point) ->
\end_layout

\begin_layout Plain Layout

    point.x >= 0 and point.x < mapSize and
\end_layout

\begin_layout Plain Layout

    point.y >= 0 and point.y < mapSize
\end_layout

\begin_layout Plain Layout

  directions = [ point(-1,  0), point( 1,  0)
\end_layout

\begin_layout Plain Layout

                 point( 0, -1), point( 0,  1)
\end_layout

\begin_layout Plain Layout

                 point(-1, -1), point(-1,  1)
\end_layout

\begin_layout Plain Layout

                 point( 1,  1), point( 1, -1)]
\end_layout

\begin_layout Plain Layout

  partial = (func, a...) -> (b...) -> func a..., b...
\end_layout

\begin_layout Plain Layout

  filter (map directions,
\end_layout

\begin_layout Plain Layout

              partial addPoints, from), insideMap
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show possibleDirections point 0, 0
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
I created a variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapSize
\end_layout

\end_inset

, for the sole purpose of not having to write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

 two times.
 If, at some other time, we want to use this same function for another map,
 it would be clumsy if the code was full of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

s, which all have to be changed.
 We could even go as far as making the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapSize
\end_layout

\end_inset

 an argument to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

possibleDirections
\end_layout

\end_inset

, so we can use the function for different maps without changing it.
 I judged that that was not necessary in this case, such things can be changed
 when the need arises.
 Then why did I not add a variable to hold the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, which also occurs two times? I assumed that maps always start at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, so this one is unlikely to ever change, and using a variable for it only
 adds noise.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To find a route on this map without having our browser cut off the program
 because it takes too long to finish, we have to stop our amateurish attempts
 and implement a serious algorithm.
 A lot of work has gone into problems like this in the past, and many solutions
 have been designed (some brilliant, others useless).
 A very popular and efficient one is called A*
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
A*
\end_layout

\end_inset

 (pronounced A-star).
 We will spend the rest of the chapter implementing an A* route-finding
 function for our map.
\end_layout

\begin_layout Standard
Before I get to the algorithm itself, let me tell you a bit more about the
 problem it solves.
 The trouble with searching routes through graphs is that, in big graphs,
 there are an awful lot of them.
 Our Hiva Oa path-finder showed that, when the graph is small, all we needed
 to do was to make sure our paths did not revisit points they had already
 passed.
 On our new map, this is not enough anymore.
\end_layout

\begin_layout Standard
The fundamental problem is that there is too much room for going in the
 wrong direction.
 Unless we somehow manage to steer our exploration of paths towards the
 goal, a choice we make for continuing a given path is more likely to go
 in the wrong direction than in the right direction.
 If you keep generating paths like that, you end up with an enormous amount
 of paths, and even if one of them accidentally reaches the end point, you
 do not know whether that is the shortest path.
\end_layout

\begin_layout Standard
So what you want to do is explore directions that are likely to get you
 to the end point first.
 On a grid like our map, you can get a rough estimate of how good a path
 is by checking how long it is and how close its end is to the end point.
 By adding path length and an estimate of the distance it still has to go,
 you can get a rough idea of which paths are promising.
 If you extend promising paths first, you are less likely to waste time
 on useless ones.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
But that still is not enough.
 If our map was of a perfectly flat plane, the path that looked promising
 would almost always be the best one, and we could use the above method
 to walk right to our goal.
 But we have valleys and hillsides blocking our paths, so it is hard to
 tell in advance which direction will be the most efficient path.
 Because of this, we still end up having to explore way too many paths.
\end_layout

\begin_layout Standard
To correct this, we can make clever use of the fact that we are constantly
 exploring the most promising path first.
 Once we have determined that path A is the best way to get to point X,
 we can remember that.
 When, later on, path B also gets to point X, we know that it is not the
 best route, so we do not have to explore it further.
 This can prevent our program from building a lot of pointless paths.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The algorithm, then, goes something like this\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
There are two pieces of data to keep track of.
 The first one is called the open list, it contains the partial routes that
 must still be explored.
 Each route has a score, which is calculated by adding its length to its
 estimated distance from the goal.
 This estimate must always be optimistic, it should never overestimate the
 distance.
 The second is a set of nodes that we have seen, together with the shortest
 partial route that got us there.
 This one we will call the reached list.
 We start by adding a route that contains only the starting node to the
 open list, and recording it in the reached list.
\end_layout

\begin_layout Standard
Then, as long as there are any nodes in the open list, we take out the one
 that has the lowest (best) score, and find the ways in which it can be
 continued (by calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

possibleDirections
\end_layout

\end_inset

).
 For each of the nodes this returns, we create a new route by appending
 it to our original route, and adjusting the length of the route using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

weightedDistance
\end_layout

\end_inset

.
 The endpoint of each of these new routes is then looked up in the reached
 list.
\end_layout

\begin_layout Standard
If the node is not in the reached list yet, it means we have not seen it
 before, and we add the new route to the open list and record it in the
 reached list.
 If we 
\emph on
had
\emph default
 seen it before, we compare the score of the new route to the score of the
 route in the reached list.
 If the new route is shorter, we replace the existing route with the new
 one.
 Otherwise, we discard the new route, since we have already seen a better
 way to get to that point.
\end_layout

\begin_layout Standard
We continue doing this until the route we fetch from the open list ends
 at the goal node, in which case we have found our route, or until the open
 list is empty, in which case we have found out that there is no route.
 In our case the map contains no unsurmountable obstacles, so there is always
 a route.
\end_layout

\begin_layout Standard
How do we know that the first full route that we get from the open list
 is also the shortest one? This is a result of the fact that we only look
 at a route when it has the lowest score.
 The score of a route is its actual length plus an 
\emph on
optimistic
\emph default
 estimate of the remaining length.
 This means that if a route has the lowest score in the open list, it is
 always the best route to its current endpoint — it is impossible for another
 route to later find a better way to that point, because if it were better,
 its score would have been lower.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Try not to get frustrated when the fine points of why this works are still
 eluding you.
 When thinking about algorithms like this, having seen 
\begin_inset Quotes els
\end_inset

something like it
\begin_inset Quotes ers
\end_inset

 before helps a lot, it gives you a point of reference to compare the approach
 to.
 Beginning programmers have to do without such a point of reference, which
 makes it rather easy to get lost.
 Just realise that this is advanced stuff, globally read over the rest of
 the chapter, and come back to it later when you feel like a challenge.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
I am afraid that, for one aspect of the algorithm, I am going to have to
 invoke magic again.
 The open list needs to be able to hold a large amount of routes, and to
 quickly find the route with the lowest score among them.
 Storing them in a normal array, and searching through this array every
 time, is way too slow, so I give you a data structure called a binary heap
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
binary heap
\end_layout

\end_inset

.
 You create them with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

, just like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset

 objects, giving them a function that is used to 
\begin_inset Quotes els
\end_inset

score
\begin_inset Quotes ers
\end_inset

 its elements as argument.
 The resulting object has the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

push
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pop
\end_layout

\end_inset

, just like an array, but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pop
\end_layout

\end_inset

 always gives you the element with the lowest score, instead of the one
 that was 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

push
\end_layout

\end_inset

ed last.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

bh = require './A2-BinaryHeap'
\end_layout

\begin_layout Plain Layout

globalize bh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

heap = new BinaryHeap()
\end_layout

\begin_layout Plain Layout

forEach [2, 4, 5, 1, 6, 3], (number) ->
\end_layout

\begin_layout Plain Layout

  heap.push number
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while heap.size() > 0
\end_layout

\begin_layout Plain Layout

  show heap.pop()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Binary-Heaps"

\end_inset

 discusses the implementation of this data structure, which is quite interesting.
 After you have read 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

, you might want to take a look at it.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The need to squeeze out as much efficiency as we can has another effect.
 The Hiva Oa algorithm used arrays of locations to store routes, and copied
 them with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 method when it extended them.
 This time, we can not afford to copy arrays, since we will be exploring
 lots and lots of routes.
 Instead, we use a 
\begin_inset Quotes els
\end_inset

chain
\begin_inset Quotes ers
\end_inset

 of objects to store a route.
 Every object in the chain has some properties, such as a point on the map,
 and the length of the route so far, and it also has a property that points
 at the previous object in the chain.
 Something like this:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/objectchain.png
	lyxscale 70
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Where the blue circles are the relevant objects, and the lines represent
 properties — the end points are the values of the property.
 Object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is the start of a route here.
 Object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is used to build a new route, which continues from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 It has a property, which we will call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

from
\end_layout

\end_inset

, pointing at the route it is based on.
 When we need to reconstruct a route later, we can follow these properties
 to find all the points that the route passed.
 Note that object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is part of two routes, one that ends in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 and one that ends in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

E
\end_layout

\end_inset

.
 When there are a lot of routes, this can save us much storage space — every
 new route only needs one new object for itself, the rest is shared with
 other routes that started the same way.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

estimatedDistance
\end_layout

\end_inset

 that gives an optimistic estimate of the distance between two points.
 It does not have to look at the height data, but can assume a flat map.
 Remember that we are only travelling straight and diagonally, and that
 we are counting the diagonal distance between two squares as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

141
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

estimatedDistance = (pointA, pointB) ->
\end_layout

\begin_layout Plain Layout

  dx = Math.abs pointA.x - pointB.x
\end_layout

\begin_layout Plain Layout

  dy = Math.abs pointA.y - pointB.y
\end_layout

\begin_layout Plain Layout

  if dx > dy
\end_layout

\begin_layout Plain Layout

    (dx - dy) * 100 + dy * 141
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    (dy - dx) * 100 + dx * 141
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show estimatedDistance point(3,3), point(9,6)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The strange formulae are used to decompose the path into a straight and
 a diagonal part.
 If you have a path like this\SpecialChar \ldots{}

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/diagonalpath.png
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\SpecialChar \ldots{}
 the path is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

6
\end_layout

\end_inset

 squares wide and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset

 high, so you get 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

6 - 3 = 3
\end_layout

\end_inset

 straight moves, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset

 diagonal ones.
\end_layout

\begin_layout Plain Layout
If you wrote a function that just computes the straight 
\begin_inset Quotes els
\end_inset

Pythagorean
\begin_inset Quotes ers
\end_inset

 distance between the points, that would also work.
 What we need is an optimistic estimate, and assuming you can go straight
 to the goal is certainly optimistic.
 However, the closer the estimate is to the real distance, the less useless
 paths our program has to try out.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We will use a binary heap for the open list.
 What would be a good data structure for the reached list? This one will
 be used to look up routes, given a pair of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 coordinates.
 Preferably in a way that is fast.
 Write three functions, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeReachedList
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

storeReached
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findReached
\end_layout

\end_inset

.
 The first one creates your data structure, the second one, given a reached
 list, a point, and a route, stores a route in it, and the last one, given
 a reached list and point, retrieves a route or returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 to indicate that no route was found for that point.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
One reasonable idea would be to use an object with objects in it.
 One of the coordinates in the points, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, is used as a property name for the outer object, and the other, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, for the inner object.
 This does require some bookkeeping to handle the fact that, sometimes,
 the inner object we are looking for is not there (yet).
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

makeReachedList = -> {}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

storeReached = (list, point, route) ->
\end_layout

\begin_layout Plain Layout

  inner = list[point.x]
\end_layout

\begin_layout Plain Layout

  if inner is undefined
\end_layout

\begin_layout Plain Layout

    inner = {}
\end_layout

\begin_layout Plain Layout

    list[point.x] = inner
\end_layout

\begin_layout Plain Layout

  inner[point.y] = route
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

findReached = (list, point) ->
\end_layout

\begin_layout Plain Layout

  inner = list[point.x]
\end_layout

\begin_layout Plain Layout

  if inner is undefined
\end_layout

\begin_layout Plain Layout

    undefined
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    inner[point.y]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Another possibility is to merge the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 of the point into a single property name, and use that to store routes
 in a single object.
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pointID = (point) ->
\end_layout

\begin_layout Plain Layout

  point.x + '-' + point.y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

makeReachedList = -> {}
\end_layout

\begin_layout Plain Layout

storeReached = (list, point, route) ->
\end_layout

\begin_layout Plain Layout

  list[pointID(point)] = route
\end_layout

\begin_layout Plain Layout

findReached = (list, point) ->
\end_layout

\begin_layout Plain Layout

  list[pointID(point)]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
encapsulation
\end_layout

\end_inset

Defining a type of data structure by providing a set of functions to create
 and manipulate such structures is a useful technique.
 It makes it possible to 
\begin_inset Quotes els
\end_inset

isolate
\begin_inset Quotes ers
\end_inset

 the code that makes use of the structure from the details of the structure
 itself.
 Note that, no matter which of the above two implementations is used, code
 that needs a reached list works in exactly the same way.
 It does not care what kind of objects are used, as long as it gets the
 results it expected.
\end_layout

\begin_layout Standard
This will be discussed in much more detail in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

, where we will learn to make object types like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BinaryHeap
\end_layout

\end_inset

, which are created using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 and have methods to manipulate them.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Here we finally have the actual path-finding function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

findRoute = (from, to) ->
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  routeScore = (route) ->
\end_layout

\begin_layout Plain Layout

    if route.score is undefined
\end_layout

\begin_layout Plain Layout

      route.score = route.length +
\end_layout

\begin_layout Plain Layout

        estimatedDistance route.point, to
\end_layout

\begin_layout Plain Layout

    route.score
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  addOpenRoute = (route) ->
\end_layout

\begin_layout Plain Layout

    open.push route
\end_layout

\begin_layout Plain Layout

    storeReached reached, route.point, route
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  open = new BinaryHeap routeScore
\end_layout

\begin_layout Plain Layout

  reached = makeReachedList()
\end_layout

\begin_layout Plain Layout

  addOpenRoute point: from, length: 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  while open.size() > 0
\end_layout

\begin_layout Plain Layout

    route = open.pop()
\end_layout

\begin_layout Plain Layout

    if samePoint route.point, to
\end_layout

\begin_layout Plain Layout

      return route
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    forEach possibleDirections(route.point),
\end_layout

\begin_layout Plain Layout

      (direction) ->
\end_layout

\begin_layout Plain Layout

        known = findReached reached, direction
\end_layout

\begin_layout Plain Layout

        newLength = route.length +
\end_layout

\begin_layout Plain Layout

          weightedDistance route.point, direction
\end_layout

\begin_layout Plain Layout

        if not known or known.length > newLength
\end_layout

\begin_layout Plain Layout

          if known
\end_layout

\begin_layout Plain Layout

            open.remove known
\end_layout

\begin_layout Plain Layout

          addOpenRoute
\end_layout

\begin_layout Plain Layout

            point:  direction,
\end_layout

\begin_layout Plain Layout

            from:   route,
\end_layout

\begin_layout Plain Layout

            length: newLength
\end_layout

\begin_layout Plain Layout

  return null
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First, it creates the data structures it needs, one open list and one reached
 list.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

routeScore
\end_layout

\end_inset

 is the scoring function given to the binary heap.
 Note how it stores its result in the route object, to prevent having to
 re-calculate it multiple times.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addOpenRoute
\end_layout

\end_inset

 is a convenience function that adds a new route to both the open list and
 the reached list.
 It is immediately used to add the start of the route.
 Note that route objects always have the properties 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

point
\end_layout

\end_inset

, which holds the point at the end of the route, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

, which holds the current length of the route.
 Routes which are more than one square long also have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

from
\end_layout

\end_inset

 property, which points at their predecessors.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 loop, as was described in the algorithm, keeps taking the lowest-scoring
 route from the open list and checks whether this gets us to the goal point.
 If it does not, we must continue by expanding it.
 This is what the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 takes care of.
 It looks up this new point in the reached list.
 If it is not found there, or the node found has a longer length that the
 new route, a new route object is created and added to the open list and
 reached list, and the existing route (if any) is removed from the open
 list.
\end_layout

\begin_layout Standard
What if the route in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

known
\end_layout

\end_inset

 is not on the open list? It has to be, because routes are only removed
 from the open list when they have been found to be the most optimal route
 to their endpoint.
 If we try to remove a value from a binary heap that is not on it, it will
 throw an exception, so if my reasoning is wrong, we will probably see an
 exception when running the function.
\end_layout

\begin_layout Standard
When code gets complex enough to make you doubt certain things about it,
 it is a good idea to add some checks that raise exceptions when something
 goes wrong.
 That way, you know that there are no weird things happening 
\begin_inset Quotes els
\end_inset

silently
\begin_inset Quotes ers
\end_inset

, and when you break something, you immediately see what you broke.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Note that this algorithm does not use recursion, but still manages to explore
 all those branches.
 The open list more or less takes over the role that the function call stack
 played in the recursive solution to the Hiva Oa problem — it keeps track
 of the paths that still have to be explored.
 Every recursive algorithm can be rewritten in a non-recursive way by using
 a data structure to store the 
\begin_inset Quotes els
\end_inset

things that must still be done
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Well, let us try our path-finder:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

route = findRoute point(0, 0), point(19, 19)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you ran all the code above, and did not introduce any errors, that call,
 though it might take an instant to run, should give us a route object.
 This object is rather hard to read.
 That can be helped by using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

showRoute
\end_layout

\end_inset

 function which will show a route as a list of coordinates.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

showRoute route
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also pass multiple routes to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

showRoute
\end_layout

\end_inset

, which can be useful when you are, for example, trying to plan a scenic
 route, which must include the beautiful viewpoint at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

11
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

17
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

showRoute findRoute(point( 0,  0), point(11, 17)),
\end_layout

\begin_layout Plain Layout

          findRoute(point(11, 17), point(19, 19))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/scenic.png
	lyxscale 70
	scale 40

\end_inset


\end_layout

\begin_layout Standard
You can also display routes on a map with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

renderRoute
\end_layout

\end_inset

.
 A web page with the map is served to your browser, then the route points
 are transferred via WebSockets to a snippet of CoffeeScript on the page
 that uses a canvas to draw the points on top of the map.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

renderRoute findRoute(point( 0,  0), point(11, 17)),
\end_layout

\begin_layout Plain Layout

            findRoute(point(11, 17), point(19, 19))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Variations on the theme of search
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
search
\end_layout

\end_inset

ing an optimal route through a graph can be applied to many problems, many
 of which are not at all related to finding a physical path.
 For example, a program that needs to solve a puzzle of fitting a number
 of blocks into a limited space could do this by exploring the various 
\begin_inset Quotes els
\end_inset

paths
\begin_inset Quotes ers
\end_inset

 it gets by trying to put a certain block in a certain place.
 The paths that ends up with insufficient room for the last blocks are dead
 ends, and the path that manages to fit in all blocks is the solution.
\end_layout

\begin_layout Chapter
Object-oriented Programming
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Object Orientation
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Object-orientation"

\end_inset


\end_layout

\begin_layout Standard
In the early nineties, a thing called object-oriented programming
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
object-oriented programming
\end_layout

\end_inset

 stirred up the software industry.
 Most of the ideas behind it were not really new at the time, but they had
 finally gained enough momentum to start rolling, to become fashionable.
 Books were being written, courses given, programming languages developed.
 All of a sudden, everybody was extolling the virtues of object-orientation,
 enthusiastically applying it to every problem, convincing themselves they
 had finally found the 
\emph on
right way to write programs
\emph default
.
\end_layout

\begin_layout Standard
These things happen a lot.
 When a process is hard and confusing, people are always on the lookout
 for a magic solution.
 When something looking like such a solution presents itself, they are prepared
 to become devoted followers.
 For many programmers — even today — object-orientation (or their view of
 it) is the gospel.
 When a program is not 
\begin_inset Quotes els
\end_inset

truly object-oriented
\begin_inset Quotes ers
\end_inset

, whatever that means, it is considered decidedly inferior.
\end_layout

\begin_layout Standard
Few fads have managed to stay popular for as long as this one, though.
 Object-orientation
\begin_inset Quotes ers
\end_inset

s longevity can largely be explained by the fact that the ideas at its core
 are very solid and useful.
 In this chapter, we will discuss these ideas, along with Coffee\SpecialChar \-
Script
\begin_inset Quotes ers
\end_inset

s (rather succinct) take on them.
 The above paragraphs are by no means meant to discredit these ideas.
 What I want to do is warn the reader against developing an unhealthy attachment
 to them.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
As the name suggests, object-oriented programming is related to objects.
 The central ideas are encapsulation, inheritance, and higher-order programming
 (polymorphism).
 So far, we have used objects as loose aggregations of values, adding and
 altering their properties whenever we saw fit.
 In an object-oriented approach, objects are viewed as little worlds of
 their own, and the outside world may touch them only through a limited
 and well-defined interface
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
interface
\end_layout

\end_inset

, a number of specific methods and properties.
 The 
\begin_inset Quotes els
\end_inset

reached list
\begin_inset Quotes ers
\end_inset

 we used at the end of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Searching"

\end_inset

 is an example of this: We used only three functions, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeReachedList
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

storeReached
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findReached
\end_layout

\end_inset

 to interact with it.
 These three functions form an interface for such objects.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Error
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BinaryHeap
\end_layout

\end_inset

 objects we have seen also work like this.
 Instead of providing regular functions for working with the objects, they
 provide a way to create such objects, using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 keyword, and a number of methods and properties that provide the rest of
 the interface.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
One way to give an object methods is to attach function values to it.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

rabbit = {}
\end_layout

\begin_layout Plain Layout

rabbit.speak = (line) ->
\end_layout

\begin_layout Plain Layout

  show "The rabbit says '#{line}'"
\end_layout

\begin_layout Plain Layout

rabbit.speak "Well, now you're asking me."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In most cases, the method will need to know 
\emph on
who
\emph default
 it should act on.
 For example, if there are different rabbits, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

speak
\end_layout

\end_inset

 method must indicate which rabbit is speaking.
 For this purpose, there is a special variable called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
this
\end_layout

\end_inset

, which is always present when a function is called, and which points at
 the relevant object when the function is called as a method.
 A function is called as a method when it is looked up as a property, and
 immediately called, as in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object.method()
\end_layout

\end_inset

.
 Since it is very common to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset

 inside an object, it can be abbreviated from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this.property
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this.method()
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@property
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@method()
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

speak = (line) ->
\end_layout

\begin_layout Plain Layout

  show "The #{this.adjective} rabbit says '#{line}'"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

whiteRabbit = adjective: "white", speak: speak
\end_layout

\begin_layout Plain Layout

fatRabbit = adjective: "fat", speak: speak
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

whiteRabbit.speak "Oh my ears and whiskers, " +
\end_layout

\begin_layout Plain Layout

                  "how late it's getting!"
\end_layout

\begin_layout Plain Layout

fatRabbit.speak "I could sure use a carrot right now."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
I can now clarify the mysterious first argument to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

apply
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
apply
\end_layout

\end_inset

 method, for which we always used 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

.
 This argument can be used to specify the object that the function must
 be applied to.
 For non-method functions, this is irrelevant, hence the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

speak.apply fatRabbit, ['Yum.']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Functions also have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

call
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
call
\end_layout

\end_inset

 method, which is similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

apply
\end_layout

\end_inset

, but you can give the arguments for the function separately instead of
 as an array:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

speak.call fatRabbit, 'Burp.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
It is common in object oriented terminology to refer to instances of something
 as an object.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

whiteRabbit
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fatRabbit
\end_layout

\end_inset

 can be seen as different instances of a more general 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rabbit
\end_layout

\end_inset

 concept.
 In CoffeeScript such concepts are termed a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
class
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "showstringspaces=false,string={[b]\&quot;},tabsize=2"
inline false
status open

\begin_layout Plain Layout

class Rabbit
\end_layout

\begin_layout Plain Layout

  constructor: (@adjective) ->
\end_layout

\begin_layout Plain Layout

  speak: (line) ->
\end_layout

\begin_layout Plain Layout

    show "The #{@adjective} rabbit says '#{line}'"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

whiteRabbit = new Rabbit "white"
\end_layout

\begin_layout Plain Layout

fatRabbit = new Rabbit "fat"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

whiteRabbit.speak "Hurry!"
\end_layout

\begin_layout Plain Layout

fatRabbit.speak "Tasty!"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is a convention, among Coffee\SpecialChar \-
Script programmers, to start the names of
 classes with a capital letter.
 This makes it easy to distinguish them from object instances and functions.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
new
\end_layout

\end_inset

 keyword provides a convenient way of creating new objects.
 When a function is called with the word 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 in front of it, its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
this
\end_layout

\end_inset

 variable will point at a 
\emph on
new
\emph default
 object, which it will automatically return (unless it explicitly returns
 something else).
 Functions used to create new objects like this are called constructor
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
constructor
\end_layout

\end_inset

s.
\end_layout

\begin_layout Standard
The constructor for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rabbit
\end_layout

\end_inset

 class is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

constructor: (@adjective) ->
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@adjective
\end_layout

\end_inset

 argument to the constructor does two things: It declares 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

adjective
\end_layout

\end_inset

 as a property on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset

 and it uses 
\begin_inset Quotes els
\end_inset

pattern matching
\begin_inset Quotes ers
\end_inset

 i.e.
 the same name to assign the argument named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

adjective
\end_layout

\end_inset

 to a property on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset

 that is also named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

adjective
\end_layout

\end_inset

.
 It could have been written in full form as 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

constructor: (adjective) -> this.adjective = adjective
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

killerRabbit = new Rabbit 'killer'
\end_layout

\begin_layout Plain Layout

killerRabbit.speak 'GRAAAAAAAAAH!'
\end_layout

\begin_layout Plain Layout

show killerRabbit
\end_layout

\end_inset

When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new Rabbit
\end_layout

\end_inset

 is called with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'killer'
\end_layout

\end_inset

 argument, the argument is assigned to a property named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

adjective
\end_layout

\end_inset

.
 So 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show killerRabbit
\end_layout

\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{adjective: 'killer'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Why is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 keyword even necessary? After all, we could have simply written this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

makeRabbit = (adjective) ->
\end_layout

\begin_layout Plain Layout

  adjective: adjective
\end_layout

\begin_layout Plain Layout

  speak: (line) -> show adjective + ': ' + line
\end_layout

\begin_layout Plain Layout

blackRabbit = makeRabbit 'black'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But that is not entirely the same.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new
\end_layout

\end_inset

 does a few things behind the scenes.
 For one thing, our 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

killerRabbit
\end_layout

\end_inset

 has a property called 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

constructor
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
constructor
\end_layout

\end_inset

, which points at the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rabbit
\end_layout

\end_inset

 function that created it.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blackRabbit
\end_layout

\end_inset

 also has such a property, but it points at the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Object
\end_layout

\end_inset

 function.
 They even have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

name
\end_layout

\end_inset

 properties so we can check them: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show killerRabbit.constructor.name
\end_layout

\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rabbit
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show blackRabbit.constructor.name
\end_layout

\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The objects that are created, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

whiteRabbit
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fatRabbit
\end_layout

\end_inset

, are specific instances.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

whiteRabbit
\end_layout

\end_inset

 is not all kinds of white rabbits just a single one that happen to have
 the name whiteRabbit.
 If you want to create a class of say weight conscious rabbits then the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extends
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
extends
\end_layout

\end_inset

 keyword can help you accomplish that.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

class WeightyRabbit extends Rabbit
\end_layout

\begin_layout Plain Layout

  constructor: (adjective, @weight) ->
\end_layout

\begin_layout Plain Layout

    super adjective
\end_layout

\begin_layout Plain Layout

  adjustedWeight: (relativeGravity) ->
\end_layout

\begin_layout Plain Layout

    (@weight * relativeGravity).toPrecision 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

tinyRabbit = new WeightyRabbit "tiny", 1.01
\end_layout

\begin_layout Plain Layout

jumboRabbit = new WeightyRabbit "jumbo", 7.47
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

moonGravity = 1/6
\end_layout

\begin_layout Plain Layout

jumboRabbit.speak "Carry me, I weigh 
\end_layout

\begin_layout Plain Layout

#{jumboRabbit.adjustedWeight(moonGravity)} stones"
\end_layout

\begin_layout Plain Layout

tinyRabbit.speak "He ain't heavy, he is my brother"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The call 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

super adjective
\end_layout

\end_inset

 passes the argument on to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rabbit
\end_layout

\end_inset

 constructor.
 A method in a derived class can with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

super
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
super
\end_layout

\end_inset

 call upon a method of the same name in its parent class.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Inheritance is useful because different types can share a single implementation
 of an algorithm.
 But it comes with a price-tag: the derived classes become tightly coupled
 to the parent class.
 Normally you make each part of a system as independent as possible, for
 example avoiding global variables and using arguments instead.
 That way you can read and understand each part in isolation and you can
 change them with little risk of breaking other parts of the system.
\end_layout

\begin_layout Standard
Due to the tight coupling that inheritance introduces it can be difficult
 to change a parent class without inadvertently risk breaking derived classes.
 This is called the fragile base class
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fragile base class
\end_layout

\end_inset

 problem.
 A class that has no child classes and is only used through its published
 methods and properties can normally be changed quite freely — as long as
 the published methods and properties stay the same.
 When a class derives from it, then the child class may depend on the internal
 behaviour of the parent and it becomes problematic to change the base class.
\end_layout

\begin_layout Standard
To understand a derived class you will often have to understand the parent
 first.
 The implementation is distributed, instead of reading down through a function,
 you may have to look in different places where a class and its parent and
 their parent\SpecialChar \ldots{}
 implement each their part of the combined logic.
 Lets look at an example that matters — the balance on your bank account.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

class Account
\end_layout

\begin_layout Plain Layout

  constructor: -> @balance = 0
\end_layout

\begin_layout Plain Layout

  transfer: (amount) -> @balance += amount
\end_layout

\begin_layout Plain Layout

  getBalance: -> @balance
\end_layout

\begin_layout Plain Layout

  batchTransfer: (amtList) ->
\end_layout

\begin_layout Plain Layout

    for amount in amtList
\end_layout

\begin_layout Plain Layout

      @transfer amount
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

yourAccount = new Account()
\end_layout

\begin_layout Plain Layout

oldBalance = yourAccount.getBalance()
\end_layout

\begin_layout Plain Layout

yourAccount.transfer salary = 1000
\end_layout

\begin_layout Plain Layout

newBalance = yourAccount.getBalance()
\end_layout

\begin_layout Plain Layout

show "Books balance:
\end_layout

\begin_layout Plain Layout

 #{salary == newBalance - oldBalance}."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hopefully this only shows the principle of how your bank has implemented
 its accounts.
 An account starts out with a zero balance, money can be credited (positive
 transfer) and debited (negative transfer), the balance can be shown and
 multiple transfers can be handled.
\end_layout

\begin_layout Standard
Other parts of the system can balance the books by checking that transfers
 match the differences on the accounts.
 Those parts of the system were unfortunately not known to the developer
 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AccountWithFee
\end_layout

\end_inset

 class.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

class AccountWithFee extends Account
\end_layout

\begin_layout Plain Layout

  fee: 5
\end_layout

\begin_layout Plain Layout

  transfer: (amount) ->
\end_layout

\begin_layout Plain Layout

    super amount - @fee
\end_layout

\begin_layout Plain Layout

    # feeAccount.transfer @fee
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

yourAccount = new AccountWithFee()
\end_layout

\begin_layout Plain Layout

oldBalance = yourAccount.getBalance()
\end_layout

\begin_layout Plain Layout

yourAccount.transfer salary = 1000
\end_layout

\begin_layout Plain Layout

newBalance = yourAccount.getBalance()
\end_layout

\begin_layout Plain Layout

show "Books balance:
\end_layout

\begin_layout Plain Layout

 #{salary == newBalance - oldBalance}."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The books no longer balance.
 The issue is that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AccountWithFee
\end_layout

\end_inset

 class has violated what is called the substitution principle
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
substitution principle
\end_layout

\end_inset

.
 It is a patch of the existing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Account
\end_layout

\end_inset

 class and it breaks programs that assume that all account classes behave
 in a certain way.
 In a system with thousands of classes such patches can cause severe problems.
 To avoid this kind of problem it is up to the developer to ensure that
 inherited classes can fully substitute their parent classes.
\end_layout

\begin_layout Standard
To avoid excessive fraudulent transactions when a card is lost or stolen,
 the bank has implemented a system which checks that withdrawals do not
 exceed a daily limit.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LimitedAccount
\end_layout

\end_inset

 class checks each 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

transfer
\end_layout

\end_inset

, reduces the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@dailyLimit
\end_layout

\end_inset

 and reports an error if it is exceeded.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class LimitedAccount extends Account
\end_layout

\begin_layout Plain Layout

  constructor: -> super; @resetLimit()
\end_layout

\begin_layout Plain Layout

  resetLimit: -> @dailyLimit = 50
\end_layout

\begin_layout Plain Layout

  transfer: (amount) ->
\end_layout

\begin_layout Plain Layout

    if amount < 0 and (@dailyLimit += amount) < 0
\end_layout

\begin_layout Plain Layout

      throw new Error "You maxed out!"
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      super amount
\end_layout

\begin_layout Plain Layout

lacc = new LimitedAccount()
\end_layout

\begin_layout Plain Layout

lacc.transfer 50
\end_layout

\begin_layout Plain Layout

show "Start balance #{lacc.getBalance()}"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try lacc.batchTransfer [-1..-10]
\end_layout

\begin_layout Plain Layout

catch error then show error.message
\end_layout

\begin_layout Plain Layout

show "After batch balance #{lacc.getBalance()}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Your bank is so successful that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

batchTransfer
\end_layout

\end_inset

 has to be speeded up (a real version would involve database updates).
 The developer, that got the task of making 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

batchTransfer
\end_layout

\end_inset

 faster, had been on vacation when the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LimitedAccount
\end_layout

\end_inset

 class was implemented and did not see it among the thousands of other classes
 in the system.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Account
\end_layout

\begin_layout Plain Layout

  constructor: -> @balance = 0
\end_layout

\begin_layout Plain Layout

  transfer: (amount) -> @balance += amount
\end_layout

\begin_layout Plain Layout

  getBalance: -> @balance
\end_layout

\begin_layout Plain Layout

  batchTransfer: (amtList) ->
\end_layout

\begin_layout Plain Layout

    add = (a,b) -> a+b
\end_layout

\begin_layout Plain Layout

    sum = (list) -> reduce list, add, 0
\end_layout

\begin_layout Plain Layout

    @balance += sum amtList
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class LimitedAccount extends Account
\end_layout

\begin_layout Plain Layout

  constructor: -> super; @resetLimit()
\end_layout

\begin_layout Plain Layout

  resetLimit: -> @dailyLimit = 50
\end_layout

\begin_layout Plain Layout

  transfer: (amount) ->
\end_layout

\begin_layout Plain Layout

    if amount < 0 and (@dailyLimit += amount) < 0
\end_layout

\begin_layout Plain Layout

      throw new Error "You maxed out!"
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      super amount
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lacc = new LimitedAccount()
\end_layout

\begin_layout Plain Layout

lacc.transfer 50
\end_layout

\begin_layout Plain Layout

show "Starting with #{lacc.getBalance()}"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try lacc.batchTransfer [-1..-10]
\end_layout

\begin_layout Plain Layout

catch error then show error.message
\end_layout

\begin_layout Plain Layout

show "After batch balance #{lacc.getBalance()}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of the previous implementation that called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

transfer
\end_layout

\end_inset

 each time, the whole batch is added together and the balance is directly
 updated.
 That made 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

batchTransfer
\end_layout

\end_inset

 much faster, but it also broke the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LimitedAccount
\end_layout

\end_inset

 class.
 It is an example of the fragile base class
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fragile base class
\end_layout

\end_inset

 problem.
 In this limited example it is easy to spot the issue, in a large system
 it can cause considerable headache.
\end_layout

\begin_layout Standard
Using inheritance in the right way requires careful and thoughtful programming.
 If your child classes are type compatible with their parent then you are
 adhering to the substitution principle.
 Usually using ownership is more appropriate, that is when a class has an
 instance of another class inside it and uses its public interface.
\end_layout

\begin_layout Standard
It is a common convention in CoffeeScript to use an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_
\end_layout

\end_inset

 in front of methods that are to be considered private.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Where did the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

constructor
\end_layout

\end_inset

 property come from? It is part of the prototype
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
prototype
\end_layout

\end_inset

 of a rabbit.
 Prototypes are a powerful, if somewhat confusing, part of the way Coffee\SpecialChar \-
Script
 objects work.
 Every object is based on a prototype, which gives it a set of inherent
 properties.
 Simple objects are based on the most basic prototype, which is associated
 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

 constructor.
 In fact, typing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset

 is equivalent to typing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new Object()
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

simpleObject = {}
\end_layout

\begin_layout Plain Layout

show simpleObject.constructor
\end_layout

\begin_layout Plain Layout

show simpleObject.toString
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toString
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
toString
\end_layout

\end_inset

 is a method that is part of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

 prototype.
 This means that all simple objects have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toString
\end_layout

\end_inset

 method, which converts them to a string.
 Our rabbit objects are based on the prototype associated with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rabbit
\end_layout

\end_inset

 constructor.
 You can use a constructor
\begin_inset Quotes ers
\end_inset

s 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prototype
\end_layout

\end_inset

 property to get access to, well, their prototype:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show Rabbit.prototype
\end_layout

\begin_layout Plain Layout

show Rabbit.prototype.constructor.name
\end_layout

\begin_layout Plain Layout

Rabbit.prototype.speak 'I am generic' 
\end_layout

\begin_layout Plain Layout

Rabbit::speak 'I am not initialized'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Rabbit.prototype.speak
\end_layout

\end_inset

 you can write 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

Rabbit::speak
\end_layout

\end_inset

.
 Every function automatically gets a 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

prototype
\end_layout

\end_inset

 property, whose 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline true
status open

\begin_layout Plain Layout

constructor
\end_layout

\end_inset

 property points back at the function.
 Because the rabbit prototype is itself an object, it is based on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

 prototype, and shares its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toString
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show killerRabbit.toString == simpleObject.toString
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Even though objects seem to share the properties of their prototype, this
 sharing is one-way.
 The properties of the prototype influence the object based on it, but the
 properties of this object never change the prototype.
\end_layout

\begin_layout Standard
The precise rules are this: When looking up the value of a property, Coffee\SpecialChar \-
Scrip
t first looks at the properties that the object 
\emph on
itself
\emph default
 has.
 If there is a property that has the name we are looking for, that is the
 value we get.
 If there is no such property, it continues searching the prototype of the
 object, and then the prototype of the prototype, and so on.
 If no property is found, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 is given.
 On the other hand, when 
\emph on
setting
\emph default
 the value of a property, Coffee\SpecialChar \-
Script never goes to the prototype, but
 always sets the property in the object itself.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Rabbit::teeth = 'small'
\end_layout

\begin_layout Plain Layout

show killerRabbit.teeth
\end_layout

\begin_layout Plain Layout

killerRabbit.teeth = 'long, sharp, and bloody'
\end_layout

\begin_layout Plain Layout

show killerRabbit.teeth
\end_layout

\begin_layout Plain Layout

show Rabbit::teeth
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This does mean that the prototype can be be used at any time to add new
 properties and methods to all objects based on it.
 For example, it might become necessary for our rabbits to dance.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

Rabbit::dance = ->
\end_layout

\begin_layout Plain Layout

  show "The #{@adjective} rabbit dances a jig."
\end_layout

\begin_layout Plain Layout

killerRabbit.dance()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And, as you might have guessed, the prototypical rabbit is the perfect place
 for values that all rabbits have in common, such as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

speak
\end_layout

\end_inset

 method.
 Here is a new approach to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rabbit
\end_layout

\end_inset

 constructor:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

Rabbit = (adjective) ->
\end_layout

\begin_layout Plain Layout

  @adjective = adjective
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rabbit::speak = (line) ->
\end_layout

\begin_layout Plain Layout

  show "The #{@adjective} rabbit says '#{line}'"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

hazelRabbit = new Rabbit "hazel"
\end_layout

\begin_layout Plain Layout

hazelRabbit.speak "Good Frith!"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The fact that all objects have a prototype and receive some properties from
 this prototype can be tricky.
 It means that using an object to store a set of things, such as the cats
 from 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

, can go wrong.
 If, for example, we wondered whether there is a cat called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'constructor'
\end_layout

\end_inset

, we would have checked it like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

noCatsAtAll = {}
\end_layout

\begin_layout Plain Layout

if "constructor" of noCatsAtAll
\end_layout

\begin_layout Plain Layout

  show "Yes, there is a cat called 'constructor'."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is problematic.
 A related problem is that it can often be practical to extend the prototypes
 of standard constructors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 with new useful functions.
 For example, we could give all objects a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

allProperties
\end_layout

\end_inset

, which returns an array with the names of the (non-hidden) properties that
 the object has:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Object::allProperties = ->
\end_layout

\begin_layout Plain Layout

  for property of this
\end_layout

\begin_layout Plain Layout

    property
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

test = x: 10, y: 3
\end_layout

\begin_layout Plain Layout

show test.allProperties()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And that immediately shows the problem.
 Now that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

 prototype has a property called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

allProperties
\end_layout

\end_inset

, looping over the properties of any object, using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
of
\end_layout

\end_inset

, will also give us that shared property, which is generally not what we
 want.
 We are interested only in the properties that the object itself has.
\end_layout

\begin_layout Standard
Fortunately, there is a way to find out whether a property belongs to the
 object itself or to one of its prototypes.
 Every object has a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hasOwnProperty
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
hasOwnProperty
\end_layout

\end_inset

, which tells us whether the object has a property with a given name.
 When looping over the properties of an object CoffeeScript provides a keyword
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

own
\end_layout

\end_inset

 so we are saved from using a clumsy 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 test on each property.
 Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

own
\end_layout

\end_inset

, we can write an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ownProperties
\end_layout

\end_inset

 method like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Object::ownProperties = ->
\end_layout

\begin_layout Plain Layout

  for own property of this
\end_layout

\begin_layout Plain Layout

    property
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

test = 'Fat Igor': true, 'Fireball': true
\end_layout

\begin_layout Plain Layout

show test.ownProperties()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
forEachOf
\end_layout

\end_inset

And of course, we can abstract that into a higher-order function.
 Note that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

action
\end_layout

\end_inset

 function is called with both the name of the property and the value it
 has in the object.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

forEachOf = (object, action) ->
\end_layout

\begin_layout Plain Layout

  for own property, value of object
\end_layout

\begin_layout Plain Layout

    action property, value
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

chimera = head: "lion", body: "goat", tail: "snake"
\end_layout

\begin_layout Plain Layout

forEachOf chimera, (name, value) ->
\end_layout

\begin_layout Plain Layout

  show "The #{name} of a #{value}."
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But, what if we find a cat named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hasOwnProperty
\end_layout

\end_inset

? (You never know.) It will be stored in the object, and the next time we
 want to go over the collection of cats, calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object.hasOwnProperty
\end_layout

\end_inset

 will fail, because that property no longer points at a function value.
 This can be solved by doing something ugly:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

forEachIn = (object, action) ->
\end_layout

\begin_layout Plain Layout

  for property of object
\end_layout

\begin_layout Plain Layout

    if (Object::hasOwnProperty.call(object, property))
\end_layout

\begin_layout Plain Layout

      action property, object[property]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

test = name: "Mordecai", hasOwnProperty: "Uh-oh"
\end_layout

\begin_layout Plain Layout

forEachIn test, (name, value) ->
\end_layout

\begin_layout Plain Layout

  show "Property #{name} = #{value}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, instead of using the method found in the object itself, we get the
 method from the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

 prototype, and then use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

call
\end_layout

\end_inset

 to apply it to the right object.
 Unless someone actually messes with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object.prototype
\end_layout

\end_inset

 method (do not do that), this should work correctly.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

for own property, value of test
\end_layout

\begin_layout Plain Layout

  show "Property #{property} = #{value}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fortunately the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

own
\end_layout

\end_inset

 keyword saves the day even in this situation, so it is the right thing
 to use.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hasOwnProperty
\end_layout

\end_inset

 can also be used in those situations where we have been using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
of
\end_layout

\end_inset

 operator to see whether an object has a specific property.
 There is one more catch, however.
 We saw in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

 that some properties, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toString
\end_layout

\end_inset

, are 
\begin_inset Quotes els
\end_inset

hidden
\begin_inset Quotes ers
\end_inset

, and do not show up when going over properties with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset

.
 It turns out that browsers in the Gecko family (Firefox, most importantly)
 give every object a hidden property named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

__proto__
\end_layout

\end_inset

, which points to the prototype of that object.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hasOwnProperty
\end_layout

\end_inset

 will return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 for this one, even though the program did not explicitly add it.
 Having access to the prototype of an object can be very convenient, but
 making it a property like that was not a very good idea.
 Still, Firefox is a widely used browser, so when you write a program for
 the web you have to be careful with this.
\end_layout

\begin_layout Standard
The advice here is 
\emph on
not
\emph default
 to name any of your own properties with double underscore since they then
 can clash with system specific details like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

__proto__
\end_layout

\end_inset

.
 As mentioned before identifiers beginning with one underscore is fine and
 used to indicate something private to your implementation.
 There is a method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

propertyIsEnumerable
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
propertyIsEnumerable
\end_layout

\end_inset

, which returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 for hidden properties, and which can be used to filter out strange things
 like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

__proto__
\end_layout

\end_inset

.
 An expression such as this one can be used to reliably work around this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

obj = foo: 'bar'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# This test is needed to avoid hidden properties ...
\end_layout

\begin_layout Plain Layout

show Object::hasOwnProperty.call(obj, 'foo') and
\end_layout

\begin_layout Plain Layout

     Object::propertyIsEnumerable.call(obj, 'foo')
\end_layout

\begin_layout Plain Layout

# ...
 because this returns true ...
\end_layout

\begin_layout Plain Layout

show Object::hasOwnProperty.call(obj, '__proto__')
\end_layout

\begin_layout Plain Layout

# ...
 this is required to get false.
\end_layout

\begin_layout Plain Layout

show Object::hasOwnProperty.call(obj, '__proto__') and
\end_layout

\begin_layout Plain Layout

     Object::propertyIsEnumerable.call(obj, '__proto__')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nice and simple, no? This is one of the not-so-well-designed aspects of
 the system underlying Coffee\SpecialChar \-
Script (recondite Java\SpecialChar \-
Script).
 Objects play both the role of 
\begin_inset Quotes els
\end_inset

values with methods
\begin_inset Quotes ers
\end_inset

, for which prototypes work great, and 
\begin_inset Quotes els
\end_inset

sets of properties
\begin_inset Quotes ers
\end_inset

, for which prototypes only get in the way.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Writing the above kind of expression every time you need to check whether
 a property is present in an object is unworkable.
 We could put it into a function, but a better approach is to write a constructo
r and a prototype specifically for situations like this, where we want to
 approach an object as just a set of properties.
 Because you can use it to look things up by name, we will call it a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dictionary
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Dictionary
\end_layout

\begin_layout Plain Layout

  constructor: (@values = {}) ->
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  store: (name, value) ->
\end_layout

\begin_layout Plain Layout

    @values[name] = value
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  lookup: (name) ->
\end_layout

\begin_layout Plain Layout

    @values[name]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  contains: (name) ->
\end_layout

\begin_layout Plain Layout

    Object::hasOwnProperty.call(@values, name) and
\end_layout

\begin_layout Plain Layout

    Object::propertyIsEnumerable.call(@values, name)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  each: (action) ->
\end_layout

\begin_layout Plain Layout

    for own property, value of @values
\end_layout

\begin_layout Plain Layout

      action property, value
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

colours = new Dictionary
\end_layout

\begin_layout Plain Layout

  Grover: 'blue'
\end_layout

\begin_layout Plain Layout

  Elmo:   'orange'
\end_layout

\begin_layout Plain Layout

  Bert:   'yellow'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show colours.contains 'Grover'
\end_layout

\begin_layout Plain Layout

colours.each (name, colour) ->
\end_layout

\begin_layout Plain Layout

  show name + ' is ' + colour
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now the whole mess related to approaching objects as plain sets of properties
 has been 
\begin_inset Quotes els
\end_inset

encapsulated
\begin_inset Quotes ers
\end_inset

 in a convenient interface: one constructor and four methods.
 Note that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

values
\end_layout

\end_inset

 property of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dictionary
\end_layout

\end_inset

 object is not part of this interface, it is an internal detail, and when
 you are using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dictionary
\end_layout

\end_inset

 objects you do not need to directly use it.
\end_layout

\begin_layout Standard
Whenever you write an interface, it is a good idea to add a comment with
 a quick sketch of what it does and how it should be used.
 This way, when someone, possibly yourself three months after you wrote
 it, wants to work with the interface, they can quickly see how to use it,
 and do not have to study the whole program.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/sketch.png
	lyxscale 60
	width 80text%

\end_inset


\end_layout

\begin_layout Standard
Using a piece of paper, a whiteboard or as here a pen and tablet can be
 effective to sketch your designs.
 Using a notation roughly similar to UML (Unified Modeling Language) can
 help in communicating your design to others.
 Usually you do not need a tool
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A few integrated development environments automatically generate diagrams
 as you are writing your code, for example Visual Studio Ultimate, but it
 is neither cheap nor compatible with CoffeeScript.
\end_layout

\end_inset

 — unless you really want to or work in a large administrative setting.
 You can find a quick reference to UML notation via web search.
 The most useful diagram is the interaction or sequence diagram.
 Use it to specify how objects talk to each other — especially in distributed
 systems.
 The class diagram shown above presents a static view of the system so it
 is mostly for initial designs.
\end_layout

\begin_layout Standard
Most of the time, when you are designing an interface, you will soon find
 some limitations and problems in whatever you came up with, and change
 it.
 To prevent wasting your time, it is advisable to document your interfaces
 only 
\emph on
after
\emph default
 they have been used in a few real situations and proven themselves to be
 practical.
 — Of course, this might make it tempting to forget about documentation
 altogether.
 Personally, I treat writing documentation as a 
\begin_inset Quotes els
\end_inset

finishing touch
\begin_inset Quotes ers
\end_inset

 to add to a system.
 When it feels ready, it is time to write something about it, and to see
 if it sounds as good in English (or whatever language) as it does in Coffee\SpecialChar \-
Scri
pt (or whatever programming language).
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The distinction between the external interface of an object and its internal
 details is important for two reasons.
 Firstly, having a small, clearly described interface makes an object easier
 to use.
 You only have to keep the interface in mind, and do not have to worry about
 the rest unless you are changing the object itself.
\end_layout

\begin_layout Standard
Secondly, it often turns out to be necessary or practical to change something
 about the internal implementation of a class, to make it more efficient,
 for example, or to fix some problem.
 When outside code is accessing every single property and detail in the
 object, you can not change any of them without also updating a lot of other
 code.
 If outside code only uses a small interface, you can do what you want,
 as long as you do not change the interface.
\end_layout

\begin_layout Standard
Some people go very far in this.
 They will, for example, never include properties in the interface of object,
 only methods — if their object type has a length, it will be accessible
 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getLength
\end_layout

\end_inset

 method, not the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 property.
 This way, if they ever want to change their object in such a way that it
 no longer has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 property, for example because it now has some internal array whose length
 it must return, they can update the function without changing the interface.
\end_layout

\begin_layout Standard
My own take is that in most cases this is not worth it.
 Adding a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getLength
\end_layout

\end_inset

 method which only contains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return this.length
\end_layout

\end_inset

 mostly just adds meaningless code, and, in most situations, I consider
 meaningless code a bigger problem than the risk of having to occasionally
 change the interface to my objects.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Adding new methods to existing prototypes can be very convenient.
 Especially the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 prototypes in Coffee\SpecialChar \-
Script could use a few more basic methods.
 We could, for example, replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forEach
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 with methods on arrays, and make the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startsWith
\end_layout

\end_inset

 function we wrote in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

 a method on strings.
\end_layout

\begin_layout Standard
However, if your code has to run as a library used by others or as a program
 on a web-page together with another program (either written by you or by
 someone else) which uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset

 naively — the way we have been using it so far — then adding things to
 prototypes, especially the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 prototype, will definitely break something, because these loops will suddenly
 start seeing those new properties.
 For this reason, some people prefer not to touch these prototypes at all.
 Of course, if you are careful, and you do not expect your code to have
 to coexist with badly-written code, adding methods to standard prototypes
 is a perfectly good technique.
\end_layout

\begin_layout Chapter
Regular Expressions
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Regular Expressions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Regular-Expressions"

\end_inset


\end_layout

\begin_layout Standard
At various points in the previous chapters, we had to look for patterns
 in string values.
 In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

 we extracted date values from strings by writing out the precise positions
 at which the numbers that were part of the date could be found.
 Later, in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

, we saw some particularly ugly pieces of code for finding certain types
 of characters in a string, for example the characters that had to be escaped
 in 
\shape smallcaps
\size small
HTML
\shape default
\size default
 output.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
regular expression
\end_layout

\end_inset

Regular expressions are a language for describing patterns in strings.
 They form a small, separate language, which is embedded inside Coffee\SpecialChar \-
Script
 (and in various other programming languages, in one way or another).
 It is not a very readable language — big regular expressions tend to be
 quite unreadable.
 To make them more readable Coffee\SpecialChar \-
Script has extended regular expressions
 where you can generously add comments to the different parts.
 Examples of these are shown later.
 Still regular expressions are difficult to read, but they are a useful
 tool that can really simplify string-processing programs.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Just like strings get written between quotes, regular expression patterns
 get written between slashes (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
/
\end_layout

\end_inset

).
 This means that slashes inside the expression have to be escaped.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

slash = /
\backslash
//;
\end_layout

\begin_layout Plain Layout

show 'AC/DC'.search slash
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

search
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
search
\end_layout

\end_inset

 method resembles 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

indexOf
\end_layout

\end_inset

, but it searches for a regular expression instead of a string.
 Patterns specified by regular expressions can do a few things that strings
 can not do.
 For a start, they allow some of their elements to match more than a single
 character.
 In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

, when extracting mark-up from a document, we needed to find the first asterisk
 or opening brace in a string.
 That could be done like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

asteriskOrBrace = /[
\backslash
{
\backslash
*]/
\end_layout

\begin_layout Plain Layout

story = 'We noticed the *giant sloth*, ' +
\end_layout

\begin_layout Plain Layout

        'hanging from a giant branch.';
\end_layout

\begin_layout Plain Layout

show story.search asteriskOrBrace
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

 characters have a special meaning inside a regular expression.
 They can enclose a set of characters, and they mean 
\begin_inset Quotes els
\end_inset

any of these characters
\begin_inset Quotes ers
\end_inset

.
 Most non-alphanumeric characters have some special meaning inside a regular
 expression, so it is a good idea to always escape them with a backslash
\begin_inset Foot
status open

\begin_layout Plain Layout
In this case, the backslashes were not really necessary, because the characters
 occur between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

, but it is easier to just escape them anyway, so you will not have to think
 about it.
\end_layout

\end_inset

 when you use them to refer to the actual characters.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
There are a few shortcuts for sets of characters that are needed often.
 The dot (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.
\end_layout

\end_inset

) can be used to mean 
\begin_inset Quotes els
\end_inset

any character that is not a newline
\begin_inset Quotes ers
\end_inset

, an escaped 
\begin_inset Quotes els
\end_inset

d
\begin_inset Quotes ers
\end_inset

 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
d
\end_layout

\end_inset

) means 
\begin_inset Quotes els
\end_inset

any digit
\begin_inset Quotes ers
\end_inset

, an escaped 
\begin_inset Quotes els
\end_inset

w
\begin_inset Quotes ers
\end_inset

 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
w
\end_layout

\end_inset

) matches any alphanumeric character (including underscores, for some reason),
 and an escaped 
\begin_inset Quotes els
\end_inset

s
\begin_inset Quotes ers
\end_inset

 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
s
\end_layout

\end_inset

) matches any white-space (tab, newline, space) character.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

digitSurroundedBySpace = /
\backslash
s
\backslash
d
\backslash
s/
\end_layout

\begin_layout Plain Layout

show '1a 2 3d'.search digitSurroundedBySpace
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The escaped 
\begin_inset Quotes els
\end_inset

d
\begin_inset Quotes ers
\end_inset

, 
\begin_inset Quotes els
\end_inset

w
\begin_inset Quotes ers
\end_inset

, and 
\begin_inset Quotes els
\end_inset

s
\begin_inset Quotes ers
\end_inset

 can be replaced by their capital letter to mean their opposite.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
S
\end_layout

\end_inset

 matches any character that is 
\emph on
not
\emph default
 white-space.
 When using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

, a pattern can be inverted by starting with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

^
\end_layout

\end_inset

 character:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

notABC = /[^ABC]/
\end_layout

\begin_layout Plain Layout

show 'ABCBACCBBADABC'.search notABC
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, the way regular expressions use characters to express patterns
 makes them A) very short, and B) very hard to read.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a regular expression that matches a date in the format 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'XX/XX/XXXX'
\end_layout

\end_inset

, where the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

s are digits.
 Test it against the string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'born 15/11/2003 (mother Spot): White Fang'
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

datePattern = /
\backslash
d
\backslash
d
\backslash
/
\backslash
d
\backslash
d
\backslash
/
\backslash
d
\backslash
d
\backslash
d
\backslash
d/
\end_layout

\begin_layout Plain Layout

show 'born 15/11/2003 (mother Spot): White Fang'
\backslash

\end_layout

\begin_layout Plain Layout

.search datePattern
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The backslash after the string continues the line after the line break.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sometimes you need to make sure a pattern starts at the beginning of a string,
 or ends at its end.
 For this, the special characters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

^
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$
\end_layout

\end_inset

 can be used.
 The first matches the start of the string, the second the end.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show /a+/.test 'blah'
\end_layout

\begin_layout Plain Layout

show /^a+$/.test 'blah'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first regular expression matches any string that contains an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 character, the second only those strings that consist entirely of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

 characters.
\end_layout

\begin_layout Standard
Note that regular expressions are objects, and have methods.
 Their 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

test
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
test
\end_layout

\end_inset

 method returns a boolean indicating whether the given string matches the
 expression.
\end_layout

\begin_layout Standard
The code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
b
\end_layout

\end_inset

 matches a 
\begin_inset Quotes els
\end_inset

word boundary
\begin_inset Quotes ers
\end_inset

, which can be punctuation, white-space, or the start or end of the string.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show /cat/.test 'concatenate'
\end_layout

\begin_layout Plain Layout

show /
\backslash
bcat
\backslash
b/.test 'concatenate'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Parts of a pattern can be allowed to be repeated a number of times.
 Putting an asterisk (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

) after an element allows it to be repeated any number of times, including
 zero.
 A plus (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

) does the same, but requires the pattern to occur at least one time.
 A question mark (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?
\end_layout

\end_inset

) makes an element 
\begin_inset Quotes els
\end_inset

optional
\begin_inset Quotes ers
\end_inset

 — it can occur zero or one times.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

parenthesizedText = /
\backslash
(.*
\backslash
)/
\end_layout

\begin_layout Plain Layout

show "Its (the sloth's) claws were gigantic!"
\backslash

\end_layout

\begin_layout Plain Layout

.search parenthesizedText
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When necessary, braces can be used to be more precise about the amount of
 times an element may occur.
 A number between braces (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{4}
\end_layout

\end_inset

) gives the exact amount of times it must occur.
 Two numbers with a comma between them (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{3,10}
\end_layout

\end_inset

) indicate that the pattern must occur at least as often as the first number,
 and at most as often as the second one.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{2,}
\end_layout

\end_inset

 means two or more occurrences, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{,4}
\end_layout

\end_inset

 means four or less.
\end_layout

\begin_layout Standard
To make big regular expressions more readable Coffee\SpecialChar \-
Script has extended
 regular expressions.
 They are delimited by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

///
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
///
\end_layout

\end_inset

 and allow comments to be added to the different parts.
 They ignore formatting, so they can be split over several lines and placed
 in a column.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

datePattern = /
\backslash
d{1,2}
\backslash
/
\backslash
d
\backslash
d?
\backslash
/
\backslash
d{4}/
\end_layout

\begin_layout Plain Layout

show 'born 15/11/2003 (mother Spot): White Fang'
\backslash

\end_layout

\begin_layout Plain Layout

.search datePattern
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

datePattern = ///
\end_layout

\begin_layout Plain Layout

  
\backslash
d{1,2}   # day
\end_layout

\begin_layout Plain Layout

  /         # separator
\end_layout

\begin_layout Plain Layout

  
\backslash
d
\backslash
d?     # month
\end_layout

\begin_layout Plain Layout

  /         # separator
\end_layout

\begin_layout Plain Layout

  
\backslash
d{4}     # year
\end_layout

\begin_layout Plain Layout

///
\end_layout

\begin_layout Plain Layout

show 'born 15/11/2003 (mother Spot): White Fang'
\backslash

\end_layout

\begin_layout Plain Layout

.search datePattern
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The pieces 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/
\backslash
d{1,2}/
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/
\backslash
d
\backslash
d?/
\end_layout

\end_inset

 both express 
\begin_inset Quotes els
\end_inset

one or two digits
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a pattern that matches e-mail addresses.
 For simplicity, assume that the parts before and after the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@
\end_layout

\end_inset

 can contain only alphanumeric characters and the characters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-
\end_layout

\end_inset

 (dot and dash), while the last part of the address, the country code or
 top level domain after the last dot, may only contain alphanumeric characters,
 and must be two or three characters long.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mailAddress = /
\backslash
b[
\backslash
w
\backslash
.-]+@[
\backslash
w
\backslash
.-]+
\backslash
.
\backslash
w{2,3}
\backslash
b/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mailAddress = ///
\end_layout

\begin_layout Plain Layout

  
\backslash
b[
\backslash
w
\backslash
.-]+  # username
\end_layout

\begin_layout Plain Layout

  @
\end_layout

\begin_layout Plain Layout

  [
\backslash
w
\backslash
.-]+
\backslash
   # provider
\end_layout

\begin_layout Plain Layout

  .
\end_layout

\begin_layout Plain Layout

  
\backslash
w{2,3}
\backslash
b   # domain
\end_layout

\begin_layout Plain Layout

///
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show mailAddress.test 'kenny@test.net'
\end_layout

\begin_layout Plain Layout

show mailAddress.test 'I mailt kenny@tets.nets, ' +
\end_layout

\begin_layout Plain Layout

                      'but it didn wrok!'
\end_layout

\begin_layout Plain Layout

show mailAddress.test 'the_giant_sloth@gmail.com'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
b
\end_layout

\end_inset

s at the start and end of the pattern make sure that the second string does
 not match.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Part of a regular expression can be grouped together with parentheses.
 This allows us to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

 and such on more than one character.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

cartoonCrying = /boo(hoo+)+/i
\end_layout

\begin_layout Plain Layout

show "Then, he exclaimed 'Boohoooohoohooo'"
\backslash

\end_layout

\begin_layout Plain Layout

.search cartoonCrying
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where did the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i
\end_layout

\end_inset

 at the end of that regular expression come from? After the closing slash,
 
\begin_inset Quotes els
\end_inset

options
\begin_inset Quotes ers
\end_inset

 may be added to a regular expression.
 An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i
\end_layout

\end_inset

, here, means the expression is case-insensitive, which allows the lower-case
 B in the pattern to match the upper-case one in the string.
\end_layout

\begin_layout Standard
A pipe character (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

|
\end_layout

\end_inset

) is used to allow a pattern to make a choice between two elements.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

holyCow = /(sacred|holy) (cow|bovine|bull|taurus)/i
\end_layout

\begin_layout Plain Layout

show holyCow.test 'Sacred bovine!'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Often, looking for a pattern is just a first step in extracting something
 from a string.
 In previous chapters, this extraction was done by calling a string
\begin_inset Quotes ers
\end_inset

s 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

indexOf
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

slice
\end_layout

\end_inset

 methods a lot.
 Now that we are aware of the existence of regular expressions, we can use
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 method instead.
 When a string is matched against a regular expression, the result will
 be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 if the match failed, or an array of matched strings if it succeeded.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show 'No'.match /Yes/
\end_layout

\begin_layout Plain Layout

show '...
 yes'.match /yes/
\end_layout

\begin_layout Plain Layout

show 'Giant Ape'.match /giant (
\backslash
w+)/i
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first element in the returned array is always the part of the string
 that matched the pattern.
 As the last example shows, when there are parenthesized parts in the pattern,
 the parts they match are also added to the array.
 Often, this makes extracting pieces of a string very easy.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

quote = "My mind is a swirling miasma " +
\end_layout

\begin_layout Plain Layout

        "(a poisonous fog thought to " +
\end_layout

\begin_layout Plain Layout

        "cause illness) of titilating " +
\end_layout

\begin_layout Plain Layout

        "thoughts and turgid ideas."
\end_layout

\begin_layout Plain Layout

parenthesized = quote.match ///
\end_layout

\begin_layout Plain Layout

  (
\backslash
w+)    # Word
\end_layout

\begin_layout Plain Layout

  
\backslash
s*      # Whitespace
\end_layout

\begin_layout Plain Layout

  
\backslash
((.*)
\backslash
) # Explanation
\end_layout

\begin_layout Plain Layout

///
\end_layout

\begin_layout Plain Layout

if parenthesized isnt null
\end_layout

\begin_layout Plain Layout

  show "Word: #{parenthesized[1]} " +
\end_layout

\begin_layout Plain Layout

       "Explanation: #{parenthesized[2]}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Re-write the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extractDate
\end_layout

\end_inset

 that we wrote in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Data-Structures"

\end_inset

.
 When given a string, this function looks for something that follows the
 date format we saw earlier.
 If it can find such a date, it puts the values into a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Date
\end_layout

\end_inset

 object.
 Otherwise, it throws an exception.
 Make it accept dates in which the day or month are written with only one
 digit.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

extractDate = (string) ->
\end_layout

\begin_layout Plain Layout

  found = string.match /(
\backslash
d
\backslash
d?)
\backslash
/(
\backslash
d
\backslash
d?)
\backslash
/(
\backslash
d{4})/
\end_layout

\begin_layout Plain Layout

  if found == null
\end_layout

\begin_layout Plain Layout

    throw new Error "No date found in '#{string}'."
\end_layout

\begin_layout Plain Layout

  new Date Number(found[3]),
\end_layout

\begin_layout Plain Layout

           Number(found[2]) - 1,
\end_layout

\begin_layout Plain Layout

           Number(found[1])
\end_layout

\begin_layout Plain Layout

show extractDate 
\backslash

\end_layout

\begin_layout Plain Layout

  "born 5/2/2007 (mother Noog): Long-ear Johnson"
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This version is slightly longer than the previous one, but it has the advantage
 of actually checking what it is doing, and shouting out when it is given
 nonsensical input.
 This was a lot harder without regular expressions — it would have taken
 a lot of calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

indexOf
\end_layout

\end_inset

 to find out whether the numbers had one or two digits, and whether the
 dashes were in the right places.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

replace
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
replace
\end_layout

\end_inset

 method of string values, which we saw in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

, can be given a regular expression as its first argument.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show 'Borobudur'.replace /[ou]/g, 'a'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 character after the regular expression.
 It stands for 
\begin_inset Quotes els
\end_inset

global
\begin_inset Quotes ers
\end_inset

, and means that every part of the string that matches the pattern should
 be replaced.
 When this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 is omitted, only the first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'o'
\end_layout

\end_inset

 would be replaced.
\end_layout

\begin_layout Standard
Sometimes it is necessary to keep parts of the replaced strings.
 For example, we have a big string containing the names of people, one name
 per line, in the format 
\begin_inset Quotes eld
\end_inset

Lastname, Firstname
\begin_inset Quotes erd
\end_inset

.
 We want to swap these names, and remove the comma, to get a simple 
\begin_inset Quotes eld
\end_inset

Firstname Lastname
\begin_inset Quotes erd
\end_inset

 format.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

names = '''Picasso, Pablo
\end_layout

\begin_layout Plain Layout

Gauguin, Paul
\end_layout

\begin_layout Plain Layout

Van Gogh, Vincent'''
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show names.replace /([
\backslash
w ]+), ([
\backslash
w ]+)/g, '$2 $1'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show names.replace ///
\end_layout

\begin_layout Plain Layout

  ([
\backslash
w ]+)         # Lastname
\end_layout

\begin_layout Plain Layout

  ,
\end_layout

\begin_layout Plain Layout

  ([
\backslash
w ]+)         # Firstname
\end_layout

\begin_layout Plain Layout

///g, '$2 $1'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$2
\end_layout

\end_inset

 the replacement string refer to the parenthesized parts in the pattern.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$1
\end_layout

\end_inset

 is replaced by the text that matched against the first pair of parentheses,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$2
\end_layout

\end_inset

 by the second, and so on, up to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$9
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If you have more than 9 parentheses parts in your pattern, this will no
 longer work.
 But there is one more way to replace pieces of a string, which can also
 be useful in some other tricky situations.
 When the second argument given to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

replace
\end_layout

\end_inset

 method is a function value instead of a string, this function is called
 every time a match is found, and the matched text is replaced by whatever
 the function returns.
 The arguments given to the function are the matched elements, similar to
 the values found in the arrays returned by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

: The first one is the whole match, and after that comes one argument for
 every parenthesized part of the pattern.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

eatOne = (match, amount, unit) ->
\end_layout

\begin_layout Plain Layout

  amount = Number(amount) - 1
\end_layout

\begin_layout Plain Layout

  if amount == 1
\end_layout

\begin_layout Plain Layout

    unit = unit.slice 0, unit.length - 1
\end_layout

\begin_layout Plain Layout

  else if amount == 0
\end_layout

\begin_layout Plain Layout

    unit = unit + 's'
\end_layout

\begin_layout Plain Layout

    amount = 'no'
\end_layout

\begin_layout Plain Layout

  amount + ' ' + unit
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stock = '1 lemon, 2 cabbages, and 101 eggs'
\end_layout

\begin_layout Plain Layout

stock = stock.replace /(
\backslash
d+) (
\backslash
w+)/g, eatOne
\end_layout

\begin_layout Plain Layout

show stock
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exercise
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
stepcounter{ExNum} 
\backslash
arabic{ExNum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
That last trick can be used to make the HTML-escaper from 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

 more efficient.
 You may remember that it looked like this:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

escapeHTML = (text) ->
\end_layout

\begin_layout Plain Layout

  replacements = [[/&/g, '&amp;']
\end_layout

\begin_layout Plain Layout

                  [/"/g, '&quot;']
\end_layout

\begin_layout Plain Layout

                  [/</g, '&lt;']
\end_layout

\begin_layout Plain Layout

                  [/>/g, '&gt;']]
\end_layout

\begin_layout Plain Layout

  forEach replacements, (replace) ->
\end_layout

\begin_layout Plain Layout

    text = text.replace replace[0], replace[1]
\end_layout

\begin_layout Plain Layout

  text
\end_layout

\begin_layout Plain Layout

show escapeHTML '< " & " >'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Write a new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

escapeHTML
\end_layout

\end_inset

, which does the same thing, but only calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

replace
\end_layout

\end_inset

 once.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Solutions
status open

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

escapeHTML = (text) ->
\end_layout

\begin_layout Plain Layout

  replacements =
\end_layout

\begin_layout Plain Layout

    "<":  "&lt;"
\end_layout

\begin_layout Plain Layout

    ">":  "&gt;"
\end_layout

\begin_layout Plain Layout

    "&":  "&amp;"
\end_layout

\begin_layout Plain Layout

    "
\backslash
"": "&quot;"
\end_layout

\begin_layout Plain Layout

  text.replace /[<>&"]/g, (character) ->
\end_layout

\begin_layout Plain Layout

    replacements[character]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show escapeHTML "The 'pre-formatted' tag " +
\end_layout

\begin_layout Plain Layout

                "is written 
\backslash
"<pre>
\backslash
"."
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

replacements
\end_layout

\end_inset

 object is a quick way to associate each character with its escaped version.
 Using it like this is safe (i.e.
 no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dictionary
\end_layout

\end_inset

 object is needed), because the only properties that will be used are those
 matched by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

/[<>&"]/
\end_layout

\end_inset

 expression.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are cases where the pattern you need to match against is not known
 while you are writing the code.
 Say we are writing a (very simple-minded) obscenity filter for a message
 board.
 We only want to allow messages that do not contain obscene words.
 The administrator of the board can specify a list of words that he or she
 considers unacceptable.
\end_layout

\begin_layout Standard
The most efficient way to check a piece of text for a set of words is to
 use a regular expression.
 If we have our word list as an array, we can build the regular expression
 like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

badWords = ['ape', 'monkey', 'simian',
\end_layout

\begin_layout Plain Layout

            'gorilla', 'evolution']
\end_layout

\begin_layout Plain Layout

pattern = new RegExp badWords.join('|'), 'i'
\end_layout

\begin_layout Plain Layout

isAcceptable = (text) ->
\end_layout

\begin_layout Plain Layout

  !pattern.test text
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show isAcceptable 'Mmmm, grapes.'
\end_layout

\begin_layout Plain Layout

show isAcceptable 'No more of that monkeybusiness, now.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We could add 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
b
\end_layout

\end_inset

 patterns around the words, so that the thing about grapes would not be
 classified as unacceptable.
 That would also make the second one acceptable, though, which is probably
 not correct.
 Obscenity filters are hard to get right (and usually way too annoying to
 be a good idea).
\end_layout

\begin_layout Standard
The first argument to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RegExp
\end_layout

\end_inset

 constructor is a string containing the pattern, the second argument can
 be used to add case-insensitivity or globalness.
 When building a string to hold the pattern, you have to be careful with
 backslashes.
 Because, normally, backslashes are removed when a string is interpreted,
 any backslashes that must end up in the regular expression itself have
 to be escaped:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

digits = new RegExp '
\backslash

\backslash
d+'
\end_layout

\begin_layout Plain Layout

show digits.test '101'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
The most important thing to know about regular expressions is that they
 exist, and can greatly enhance the power of your string-mangling code.
 They are so cryptic that you will probably have to look up the details
 on them the first ten times you want to make use of them.
 Persevere, and you will soon be off-handedly writing expressions that look
 like occult gibberish.
\end_layout

\begin_layout Standard
When your tasks become too complex for regular expressions then have a look
 at how CoffeeScript is implemented.
 It uses 
\begin_inset CommandInset href
LatexCommand href
name "Jison"
target "http://github.com/zaach/jison"

\end_inset

, a parser generator.
 With it you define a grammar for the language you want your program to
 be able to read i.e.
 parse.
 Jison then generates a module that can read data in that format.
 You integrate the module in your program and can then perform appropriate
 actions when different parts of the data is read.
 It is an advanced tool, that begins where regular expressions leave off.
\end_layout

\begin_layout Chapter
Modularity
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Modularity
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Modularity"

\end_inset


\end_layout

\begin_layout Standard
This chapter deals with the process of organising programs.
 In small programs, organisation rarely becomes a problem.
 As a program grows, however, it can reach a size where its structure and
 interpretation become hard to keep track of.
 Easily enough, such a program starts to look like a bowl of spaghetti,
 an amorphous mass in which everything seems to be connected to everything
 else.
\end_layout

\begin_layout Standard
In top down design you look at the overall structure of your application
 and divide it into smaller parts.
 There are many ways to do this, one way is to distinguish between technical
 and application specific areas.
 For example instead of inserting statements that write application activity
 in files in various places, the technical part — writing in a file, checking
 for errors and handling daily log roll-overs — can be placed in a logging
 utility as a technical service.
\end_layout

\begin_layout Standard
A useful technique is to use a layered approach, where lower layers do not
 know of higher layers.
 For example when communicating between processes, lower level protocols
 can be encapsulated in a layer and when data arrives — instead of a lower
 layer directly calling a function to handle the data in a higher layer
 — the lower layer raises an event
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The system underlying standard CoffeeScript has an EventEmitter to help
 you do this.
 Search for event in the documentation for the runtime system you use to
 learn more.
\end_layout

\end_inset

 that an interested higher layer can be listening to.
 It is analogue to what we saw in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Error-Handling"

\end_inset

 where a failing function does not have any knowledge of who or how an exception
 will be handled.
\end_layout

\begin_layout Standard
When structuring a program in CoffeeScript, we do two things.
 We separate it into smaller parts, called module
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
module
\end_layout

\end_inset

s, each of which has a specific role, and we specify the relations between
 these parts.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Searching"

\end_inset

, while finding routes, we made use of a number of functions described in
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

.
 The chapter also defined some concepts that had nothing in particular to
 do with route planning, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

partial
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BinaryHeap
\end_layout

\end_inset

 type.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BinaryHeap
\end_layout

\end_inset

 was treated as a black box, we only had to know how to use it, we did not
 have to know how it internally works.
 That kind of encapsulation is the essence of modularity and of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Object-orientation"

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 function was reused from the Underscore library.
 We needed the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

partial
\end_layout

\end_inset

 function in a few places and haphazardly just added it to the environment
 where we needed it.
 It would have been easy to simply add 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

partial
\end_layout

\end_inset

 to the Underscore library, but that would mean that we had to add it every
 time a new version of Underscore is released.
\end_layout

\begin_layout Standard
We could create our own module instead and place the missing parts there,
 then we would have to refer to two libraries whenever we are using fundamental
 functions.
 Or we could create a module with our functions that include Underscore
 and use the functions from it to build our own.
 Our module would then depend on Underscore.
 When a module depend
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
depend
\end_layout

\end_inset

s on another module, it uses functions or variables from that module, and
 will only work when the module is loaded.
\end_layout

\begin_layout Standard
It is a good idea to make sure dependencies never form a circle.
 Not only do circular dependencies create a practical problem (if module
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 depend on each other, which one should be loaded first?), it also makes
 the relation between the modules less straightforward, and can result in
 a modularised version of the spaghetti I mentioned earlier.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Most modern programming languages have some kind of module system built
 in.
 In Coffee\SpecialChar \-
Script it sort of depends\SpecialChar \ldots{}
 In the standard CoffeeScript environment
 we have a module system based on CommonJS 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

require
\end_layout

\end_inset

.
 When using CoffeeScript in other environments, such as on a page in a web
 browser, then we do not have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

require
\end_layout

\end_inset

 and must rely on system specific services or once again invent something
 ourselves
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Projects such as 
\begin_inset CommandInset href
LatexCommand href
name "browserify"
target "http://substack.net/posts/24ab8c/browserify-browser-side-require-for-your-node-js"

\end_inset

 is aiming at bringing 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

require
\end_layout

\end_inset

 to the browser.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The most obvious way to start is to put every module in a different file.
 This makes it clear which code belongs to which module.
 In this chapter we will return to the 
\emph on
Seed of Life
\emph default
 example you saw in the 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Foreword"

\end_inset

 and make a server controlled, animated version of it.
 For this purpose I have extracted the mathematical calculations behind
 the drawing and placed them in a file, 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'10-MathFix.coffee'
\end_layout

\end_inset

.
 It contains a 
\begin_inset listings
lstparams "language=bash,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

CircularPosition
\end_layout

\end_inset

 class we can use to get positions about a 
\begin_inset Formula $\nicefrac{1}{6}$
\end_inset

 apart on a unit circle and a fix for a floating point rounding error.
 It also uses the prelude and has a small print utility at the end.
 It is not a module yet, we will stepwise refine it so it can be used in
 both a server and a browser environment.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

require "./prelude"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pi2 = Math.PI*2
\end_layout

\begin_layout Plain Layout

# Create an array with angles on the unit circle.
\end_layout

\begin_layout Plain Layout

angles = (angle for angle in [0...Pi2] by 1/3*Math.PI)
\end_layout

\begin_layout Plain Layout

# Remove the last element if 2*PI were included
\end_layout

\begin_layout Plain Layout

# due to floating point rounding on additions.
\end_layout

\begin_layout Plain Layout

epsilon = 1e-14
\end_layout

\begin_layout Plain Layout

lastAngle = angles[angles.length - 1]
\end_layout

\begin_layout Plain Layout

# Use an interval to test floating point value
\end_layout

\begin_layout Plain Layout

if Pi2 - epsilon < lastAngle < Pi2 + epsilon
\end_layout

\begin_layout Plain Layout

  angles.length = angles.length - 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Encapsulation of a pair of (x, y) coordinates
\end_layout

\begin_layout Plain Layout

class Point
\end_layout

\begin_layout Plain Layout

  constructor: (@x, @y) ->
\end_layout

\begin_layout Plain Layout

  toString: -> "{x:#{@x.toPrecision 4}," +
\end_layout

\begin_layout Plain Layout

               " y:#{@y.toPrecision 4}}"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Math class that returns points on the unit
\end_layout

\begin_layout Plain Layout

# circle, offset by step if given non-zero.
\end_layout

\begin_layout Plain Layout

class CircularPosition
\end_layout

\begin_layout Plain Layout

  constructor: (@_step = 0) -> @_count = 0
\end_layout

\begin_layout Plain Layout

  nextPoint: ->
\end_layout

\begin_layout Plain Layout

    index = @_count % angles.length 
\end_layout

\begin_layout Plain Layout

    angle = angles[index] + @_step * @_count++
\end_layout

\begin_layout Plain Layout

    new Point Math.cos(angle), Math.sin(angle)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

circ = new CircularPosition 0.01
\end_layout

\begin_layout Plain Layout

for i in [0...6]
\end_layout

\begin_layout Plain Layout

  show "#{i}: #{circ.nextPoint()}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first thing is to remove the print utility at the end
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
How to use a separate test module is shown in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Binary-Heaps"

\end_inset

.
\end_layout

\end_inset

.
 The next is the 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

require './prelude'
\end_layout

\end_inset

, while the prelude has served us well in the course of this book, it is
 not intended for modules.
 The prelude includes a variety of definitions so we have been free to focus
 on each aspect of CoffeeScript without distraction.
 However it pulls these definitions into a shared namespace either directly
 or via the 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

globalize
\end_layout

\end_inset

 function.
 This namespace is shared between all modules that a program consists of
 and since the purpose of a module is for us to be able to reuse it in various
 projects, a module should not 
\begin_inset Quotes els
\end_inset

pollute
\begin_inset Quotes ers
\end_inset

 this scarce, shared resource.
 In other words, you can use the prelude, when you are experimenting with
 a new algorithm, but do not use it when you create a reusable module.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
When much code is loaded into an environment, it will use many top-level
 variable names.
 Once there is more code than you can really keep track of, it becomes very
 easy to accidentally use a name that was already used for something else.
 This will break the code that used the original value.
 The proliferation of top-level variables is called name-space pollution
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
name-space pollution
\end_layout

\end_inset

, and it has been a rather severe problem in Java\SpecialChar \-
Script — the language will
 not warn you when you redefine an existing variable.
\end_layout

\begin_layout Standard
Coffee\SpecialChar \-
Script greatly reduces this problem by automatically encapsulating
 modules.
 You only have to avoid directly using top-level variables.
 In particular modules should not use top-level variables for values that
 are not part of their external interface.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
In Coffee\SpecialChar \-
Script, 
\begin_inset Quotes els
\end_inset

top-level
\begin_inset Quotes ers
\end_inset

 variables all live together in a single place.
 In browsers, this place is an object that can be found under the name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

window
\end_layout

\end_inset

.
 The name is somewhat odd, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

environment
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

top
\end_layout

\end_inset

 would have made more sense, but since browsers associate an environment
 with a window or a 
\begin_inset Quotes els
\end_inset

frame
\begin_inset Quotes ers
\end_inset

, someone decided that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

window
\end_layout

\end_inset

 was a logical name.
 In the standard Coffee\SpecialChar \-
Script environment it is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

global
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

show global.process.argv[0]
\end_layout

\begin_layout Plain Layout

show global.console.log == console.log
\end_layout

\begin_layout Plain Layout

show global.global.global.global.global.console
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the third line shows, the name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

global
\end_layout

\end_inset

 is merely a property of this environment object, pointing at itself.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Not being able to define any internal functions and variables at all in
 your modules is, of course, not very practical.
 Fortunately, there is a trick to get around this.
 We could write all the code for the module inside a function, and then
 add the variables that are part of the module
\begin_inset Quotes ers
\end_inset

s interface to the top-level object.
 Because they were created in the same parent function, all the functions
 of the module can see each other, but code outside of the module can not.
 The wrapping in a function is done by Coffee\SpecialChar \-
Script automatically.
 In the server environment, instead of assigning directly to the top-level
 environment our module will export its definitions.
 In the browser we have to assign to the top-level 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

window
\end_layout

\end_inset

, which when a module is loaded by a browser is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset

.
 All we have to do is append this one line to our math module:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(exports ? this).CircularPosition = CircularPosition
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exports
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
exports
\end_layout

\end_inset

 is defined then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CircularPosition
\end_layout

\end_inset

 is added to it otherwise it is added to the top-level environment object.
 This change has been done in 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'10-Circular.coffee'
\end_layout

\end_inset

 and the module is now usable from another module.
 The other definitions such as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Point
\end_layout

\end_inset

 class are not visible to other modules.
 Objects of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Point
\end_layout

\end_inset

 type are of course visible as they are returned by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

nextPoint
\end_layout

\end_inset

.
 You can use this modular information hiding when creating classes, if you
 want some definitions to be more private than simply naming them with an
 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'_'
\end_layout

\end_inset

 in front.
 We can verify this in an ad-hoc test, this one is called 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'10-CircularTest.coffee'
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

cp = require "./10-Circular"
\end_layout

\begin_layout Plain Layout

show = console.log
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

circ = new cp.CircularPosition 0.01
\end_layout

\begin_layout Plain Layout

for i in [0...6]
\end_layout

\begin_layout Plain Layout

  show "#{i}: #{circ.nextPoint()}"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

  show "Instantiating a new Point:"
\end_layout

\begin_layout Plain Layout

  p = new cp.Point 0, 0
\end_layout

\begin_layout Plain Layout

  show "Created a Point"
\end_layout

\begin_layout Plain Layout

catch e then show e.message
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show "CircularPosition namespace:"
\end_layout

\begin_layout Plain Layout

show cp
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The show function was defined in the prelude, so we no longer have access
 to it.
 In the underlying environment there is a function 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

console.log
\end_layout

\end_inset

 that can be used for output.
 Instead of using 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

console.log
\end_layout

\end_inset

 directly, defining 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 as an alias for it makes it easy to copy such code into another environment,
 the browser were 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

console.log
\end_layout

\end_inset

 does not exist.
 When we have many 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

show
\end_layout

\end_inset

 calls, we only have to change in one place to redirect them to 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

alert
\end_layout

\end_inset

 or debug output.
\end_layout

\begin_layout Standard
The process that we have been through — identifying a rounding error, extracting
 the implementation into a separate module where it is fixed — is called
 refactoring and it is an essential part of developing applications.
 Looking through code and finding places where it can be improved in functionali
ty or in clarity results in a better overall system.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Designing an interface for a module or an object type is one of the subtler
 aspects of programming.
 On the one hand, you do not want to expose too many details.
 They will only get in the way when using the module.
 On the other hand, you do not want to be 
\emph on
too
\emph default
 simple and general, because that might make it impossible to use the module
 in complex or specialised situations.
\end_layout

\begin_layout Standard
Sometimes the solution is to provide two interfaces, a detailed 
\begin_inset Quotes els
\end_inset

low-level
\begin_inset Quotes ers
\end_inset

 one for complicated things, and a simple 
\begin_inset Quotes els
\end_inset

high-level
\begin_inset Quotes ers
\end_inset

 one for straightforward situations.
 The second one can usually be built very easily using the tools provided
 by the first one.
\end_layout

\begin_layout Standard
In other cases, you just have to find the right idea around which to base
 your interface.
 The best way to learn the value of good interface design is, unfortunately,
 to use bad interfaces.
 Once you get fed up with them, you will figure out a way to improve them,
 and learn a lot in the process.
 Try not to assume that a lousy interface is 
\begin_inset Quotes els
\end_inset

just the way it is
\begin_inset Quotes ers
\end_inset

.
 Fix it, or wrap it in a new interface that is better.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Just like an object type, a module has an interface.
 In collection-of-func\SpecialChar \-
tions modules such as Underscore, the interface usually
 consists of all the functions that are defined in the module.
 In other cases, the interface of the module is only a small part of the
 functions defined inside it.
\end_layout

\begin_layout Standard
For example, our manuscript-to-
\shape smallcaps
\size small
HTML
\shape default
\size default
 system from 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

 only needs an interface of a single function, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

renderFile
\end_layout

\end_inset

.
 The sub-system for building 
\shape smallcaps
\size small
HTML
\shape default
\size default
 would be a separate module.
 For modules which only define a single type of object, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Dictionary
\end_layout

\end_inset

, the object
\begin_inset Quotes ers
\end_inset

s interface is the same as the module
\begin_inset Quotes ers
\end_inset

s interface.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
There are cases where a module will export so many variables that it is
 a bad idea to put them all into the top-level environment.
 In cases like this, you can do what the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Math
\end_layout

\end_inset

 object does, and represent the module as a single object whose properties
 are the functions and values it exports.
 For example\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

HTML =
\end_layout

\begin_layout Plain Layout

  tag: (name, content, properties) ->
\end_layout

\begin_layout Plain Layout

    name: name
\end_layout

\begin_layout Plain Layout

    properties: properties
\end_layout

\begin_layout Plain Layout

    content: content
\end_layout

\begin_layout Plain Layout

  link: (target, text) ->
\end_layout

\begin_layout Plain Layout

    HTML.tag 'a', [text], {href: target}
\end_layout

\begin_layout Plain Layout

  # ...
 many more HTML-producing functions ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When you need the content of such a module so often that it becomes cumbersome
 to constantly type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HTML
\end_layout

\end_inset

, you can always move it into the top-level environment using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

globalize
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# As defined in the prelude
\end_layout

\begin_layout Plain Layout

globalize = (ns, target = global) ->
\end_layout

\begin_layout Plain Layout

  target[name] = ns[name] for name of ns
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

globalize HTML
\end_layout

\begin_layout Plain Layout

show link 'http://citeseerx.ist.psu.edu/viewdoc/' +
\end_layout

\begin_layout Plain Layout

  'download?doi=10.1.1.102.244&rep=rep1&type=pdf',
\end_layout

\begin_layout Plain Layout

  'What Every Computer Scientist Should Know ' +
\end_layout

\begin_layout Plain Layout

  'About Floating-Point Arithmetic'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can even combine the function and object approaches, by putting the
 internal variables of the module inside a function, and having this function
 return an object containing its external interface.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
When adding methods to standard prototypes, such as those of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Object
\end_layout

\end_inset

 a similar problem to name-space pollution occurs.
 If two modules decide to add a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array.prototype
\end_layout

\end_inset

, you might have a problem.
 If these two versions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 have the precise same effect, things will continue to work, but only by
 sheer luck.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
There are functions which require a lot of arguments.
 Sometimes this means they are just badly designed, and can easily be remedied
 by splitting them into a few more modest functions.
 But in other cases, there is no way around it.
 Typically, some of these arguments have a sensible 
\begin_inset Quotes els
\end_inset

default
\begin_inset Quotes ers
\end_inset

 value.
 We could, for example, write yet another extended version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

range
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

range = (start, end, stepSize, length) ->
\end_layout

\begin_layout Plain Layout

  if stepSize == undefined
\end_layout

\begin_layout Plain Layout

    stepSize = 1
\end_layout

\begin_layout Plain Layout

  if end == undefined
\end_layout

\begin_layout Plain Layout

    end = start + stepSize * (length - 1)
\end_layout

\begin_layout Plain Layout

  result = []
\end_layout

\begin_layout Plain Layout

  while start <= end
\end_layout

\begin_layout Plain Layout

    result.push start
\end_layout

\begin_layout Plain Layout

    start += stepSize
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

show range 0, undefined, 4, 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It can get hard to remember which argument goes where, not to mention the
 annoyance of having to pass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 as a second argument when a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 argument is used.
 We can make passing arguments to this unfriendly function more comprehensive
 by wrapping them in an object.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

defaultTo = (object, values) ->
\end_layout

\begin_layout Plain Layout

  for name, value of values
\end_layout

\begin_layout Plain Layout

    if not object.hasOwnProperty name
\end_layout

\begin_layout Plain Layout

      object[name] = value
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

range = (args) ->
\end_layout

\begin_layout Plain Layout

  defaultTo args, {start: 0, stepSize: 1}
\end_layout

\begin_layout Plain Layout

  if args.end == undefined
\end_layout

\begin_layout Plain Layout

    args.end = args.start +
\end_layout

\begin_layout Plain Layout

               args.stepSize * (args.length - 1)
\end_layout

\begin_layout Plain Layout

  result = [];
\end_layout

\begin_layout Plain Layout

  while args.start <= args.end
\end_layout

\begin_layout Plain Layout

    result.push args.start
\end_layout

\begin_layout Plain Layout

    args.start += args.stepSize
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

show range {stepSize: 4, length: 5}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

defaultTo
\end_layout

\end_inset

 function is useful for adding default values to an object.
 It copies the properties of its second argument into its first argument,
 skipping those that already have a value.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
For the 
\emph on
Seed of Life
\emph default
 from the 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Foreword"

\end_inset

, to use the 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'10-Circular.coffee'
\end_layout

\end_inset

 module in the web application, we have a few things to do.
 First we can replace the first line with 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

kup = require './prelude/coffeekup'
\end_layout

\end_inset

.
 The source code assigned to 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

webpage
\end_layout

\end_inset

 has a similar structure as the 
\shape smallcaps
\size small
HTML
\shape default
\size default
 we saw in 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Functional-Programming"

\end_inset

, but instead of being object attributes or text, it is CoffeeScript function
 calls.
\end_layout

\begin_layout Standard
It is like we have 
\shape smallcaps
\size small
HTML
\shape default
\size default
 embedded as a language extension in CoffeeScript.
 The correspondence between 
\shape smallcaps
\size small
HTML
\shape default
\size default
 and Coffeekup is practically 1:1, so when you know which 
\shape smallcaps
\size small
HTML
\shape default
\size default
 tag you want to use it is straightforward to write it in Coffeekup.
 You can find more information on the 
\begin_inset CommandInset href
LatexCommand href
name "CoffeeKup website"
target "http://coffeekup.org/"

\end_inset

 or even better take the time to read the source code, it is only a few
 hundred lines of CoffeeScript and quite readable.
 There are examples in its standard distribution and 
\begin_inset CommandInset href
LatexCommand href
name "A Beginner's Introduction to CoffeeKup by Mark Hahn"
target "https://github.com/mark-hahn/coffeekup-intro/raw/master/coffeekup-intro-pandoc/coffeekup-intro.pdf"

\end_inset

.
\end_layout

\begin_layout Standard
In 
\shape smallcaps
\size small
HTML5
\shape default
\size default
 there is a 
\begin_inset listings
lstparams "language=HTML,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

canvas
\end_layout

\end_inset

 tag with which you can create a drawing area.
 Then you can draw with vector graphics commands on the area.
 The commands are documented by W3C in 
\begin_inset CommandInset href
LatexCommand href
name "HTML Canvas 2D Context"
target "http://www.w3.org/TR/2dcontext/"

\end_inset

.
 If you are already familiar with vector graphics then the 
\begin_inset CommandInset href
LatexCommand href
name "HTML5 Canvas Cheat Sheet"
target "http://www.nihilogic.dk/labs/canvas_sheet/HTML5_Canvas_Cheat_Sheet.pdf"

\end_inset

 may be all you need to create your own drawings.
 When you choose the technologies that you base your application on, then
 look for vendor independent, standardized technologies first.
 They tend to have a long lifespan, so you learn something you can bring
 with you from task to task.
 An alternative to the W3C 
\begin_inset listings
lstparams "language=HTML,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

canvas
\end_layout

\end_inset

 is Adobe Flash.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
script
\end_layout

\end_inset

Browsers load Java\SpecialChar \-
Script files when they find a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<script>
\end_layout

\end_inset

 tag with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

src
\end_layout

\end_inset

 attribute in the 
\shape smallcaps
\size small
HTML
\shape default
\size default
 of a web page.
 The extension 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.js
\end_layout

\end_inset

 is usually used for files containing Java\SpecialChar \-
Script code.
 We could let the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

coffee
\end_layout

\end_inset

 command line compiler produce Java\SpecialChar \-
Script files for us.
 But then we have two files for every module and someone is bound to forget
 to compile a file someday, which could lead to strange behaviour and some
 difficult to find bugs.
 So instead let
\begin_inset Quotes ers
\end_inset

s keep our CoffeeScript files and have the server compile them on the fly.
 That means we let the web page request a CoffeeScript file, but we will
 send the browser the corresponding JavaScript.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

script src: './10-Circular.coffee'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Adding a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type: 'text/coffeescript'
\end_layout

\end_inset

 attribute would tell the client to expect and compile CoffeeScript code
 (if the CoffeeScript compiler was loaded in the client).
 While that may sound like a good idea, it has some problems.
 The biggest one is that the code is only available after the code under
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

coffeescript
\end_layout

\end_inset

 function has run.
 And that function is were we want to use the class from the imported module.
 So forget about that possibility and compile on the server instead.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

circ = new CircularPosition()
\end_layout

\begin_layout Plain Layout

for i in [0...6]
\end_layout

\begin_layout Plain Layout

  pt = circ.nextPoint()
\end_layout

\begin_layout Plain Layout

  circle ctx, x+100*pt.x, y+100*pt.y
\end_layout

\end_inset

Replacing the loop that used 
\begin_inset Formula $\pi$
\end_inset

 and trigonometric functions with the one above is the last step for the
 client side.
 It is only a few visible changes but we got rid of the rounding error,
 that fix would have bloated the client with irrelevant details.
 Here is the client from 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'10-SeedLife.coffee'
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

kup = require './prelude/coffeekup'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Client-side web page with canvas
\end_layout

\begin_layout Plain Layout

webpage = kup.render -> 
\end_layout

\begin_layout Plain Layout

  doctype 5
\end_layout

\begin_layout Plain Layout

  html ->
\end_layout

\begin_layout Plain Layout

    head ->
\end_layout

\begin_layout Plain Layout

      meta charset: 'utf-8'
\end_layout

\begin_layout Plain Layout

      title 'My drawing | My awesome website'
\end_layout

\begin_layout Plain Layout

      style '''
\end_layout

\begin_layout Plain Layout

        body {font-family: sans-serif}
\end_layout

\begin_layout Plain Layout

        header, nav, section, footer {display: block}
\end_layout

\begin_layout Plain Layout

      '''
\end_layout

\begin_layout Plain Layout

      # DO NOT USE: type: 'text/coffeescript'
\end_layout

\begin_layout Plain Layout

      script src: './10-Circular.coffee'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      coffeescript ->
\end_layout

\begin_layout Plain Layout

        draw = (ctx, x, y) ->
\end_layout

\begin_layout Plain Layout

          circle = (ctx, x, y) ->
\end_layout

\begin_layout Plain Layout

            ctx.beginPath()
\end_layout

\begin_layout Plain Layout

            ctx.arc x, y, 100, 0, 2*Math.PI, false
\end_layout

\begin_layout Plain Layout

            ctx.stroke()
\end_layout

\begin_layout Plain Layout

          ctx.strokeStyle = 'rgba(255,40,20,0.7)'
\end_layout

\begin_layout Plain Layout

          circle ctx, x, y
\end_layout

\begin_layout Plain Layout

          circ = new CircularPosition()
\end_layout

\begin_layout Plain Layout

          for i in [0...6]
\end_layout

\begin_layout Plain Layout

            pt = circ.nextPoint()
\end_layout

\begin_layout Plain Layout

            circle ctx, x+100*pt.x, y+100*pt.y
\end_layout

\begin_layout Plain Layout

        window.onload = ->
\end_layout

\begin_layout Plain Layout

          canvas = document.getElementById 'drawCanvas'
\end_layout

\begin_layout Plain Layout

          context = canvas.getContext '2d'
\end_layout

\begin_layout Plain Layout

          draw context, 300, 200
\end_layout

\begin_layout Plain Layout

    body ->
\end_layout

\begin_layout Plain Layout

      header -> h1 'Seed of Life'
\end_layout

\begin_layout Plain Layout

      canvas id: 'drawCanvas', width: 600, height: 400
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
It is possible not use a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

script
\end_layout

\end_inset

 tag, but to fetch the content of a file directly, and then use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eval
\end_layout

\end_inset

 function to execute it.
 This makes script loading instantaneous, and thus easier to deal with.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eval
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
eval
\end_layout

\end_inset

, short for 
\begin_inset Quotes els
\end_inset

evaluate
\begin_inset Quotes ers
\end_inset

, is an interesting function.
 You give it a string value, and it will execute the content of the string
 as code.
 The global function will however only accept Java\SpecialChar \-
Script, to get a usable
 Coffee\SpecialChar \-
Script 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eval
\end_layout

\end_inset

 function you need to refer to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'coffee-script'
\end_layout

\end_inset

 library.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

eval 'function IamJavaScript() {' +
\end_layout

\begin_layout Plain Layout

     '  console.log(
\backslash
"Repeat after me:' +
\end_layout

\begin_layout Plain Layout

     ' Give me more {();};.
\backslash
");};' +
\end_layout

\begin_layout Plain Layout

     ' IamJavaScript();'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cs = (require 'coffee-script').CoffeeScript
\end_layout

\begin_layout Plain Layout

cs.eval 'show ((a, b) -> a + b) 3, 4'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can imagine that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eval
\end_layout

\end_inset

 can be used to do some interesting things.
 Code can build new code, and run it.
 In most cases, however, problems that can be solved with creative uses
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eval
\end_layout

\end_inset

 can also be solved with creative uses of anonymous functions, and the latter
 is less likely to cause strange problems and security nightmares.
 When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eval
\end_layout

\end_inset

 is called inside a function, all new variables will become local to that
 function.
\end_layout

\begin_layout Standard
Notice the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

require
\end_layout

\end_inset

 statement — we are not interested in creating instances of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CoffeeScript
\end_layout

\end_inset

 class, only in calling its static 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eval
\end_layout

\end_inset

 method — so that line helps us avoid writing: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cs.CoffeeScript.eval
\end_layout

\end_inset

 \SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
A web server functions by responding to web browser (client) requests.
 The minimal implementation given in 
\emph on
Seed of Life
\emph default
 create a server that takes a function as an argument.
 Every time a request comes in, the function is called.
 Such a function is called an event handler or sometimes a callback.
 This function prints a message and creates a response by writing a header,
 describing the content of the response, and adding the web page as the
 response body.
 The server is started by giving it a port number to listen to.
 The server then goes to sleep, waiting for a client to request something
 of it.
 You can do that by typing 
\begin_inset listings
lstparams "language=bash,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

http://localhost:3389/
\end_layout

\end_inset

 in your web browser
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Depending on your operating system you can also use numerical IP addresses.
 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

127.0.0.1
\end_layout

\end_inset

 conventionally address your local machine.
 In a 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

hosts
\end_layout

\end_inset

 file you can map names into IP addresses, its location depend on your operating
 system.
\end_layout

\end_inset

.
 To stop the server press 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false"
inline true
status open

\begin_layout Plain Layout

CTRL-C
\end_layout

\end_inset

.
 It's similar to this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

# Server-side HTTP server
\end_layout

\begin_layout Plain Layout

http = require "http"
\end_layout

\begin_layout Plain Layout

server = http.createServer (req, res) ->
\end_layout

\begin_layout Plain Layout

  show "#{req.client.remoteAddress} " +
\end_layout

\begin_layout Plain Layout

       "#{req.method} #{req.url}"
\end_layout

\begin_layout Plain Layout

  res.writeHead 200, "Content-Type": "text/html"
\end_layout

\begin_layout Plain Layout

  res.write webpage
\end_layout

\begin_layout Plain Layout

  res.end()
\end_layout

\begin_layout Plain Layout

server.listen 3389
\end_layout

\begin_layout Plain Layout

show "Server running at"
\end_layout

\begin_layout Plain Layout

show server.address()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is a bit too minimal for our 
\emph on
Seed of Life
\emph default
 application because we have to send either the web page or our module depending
 on what the client will be asking for.
 We could replace our code with a web server framework but that is not very
 instructive, it only shows you that something can be done, not how it works
 internally.
\end_layout

\begin_layout Standard
Instead lets expand the server with the minimum of what is required to get
 it to work.
 You can reverse engineer the client / server communication by adding a
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

show req
\end_layout

\end_inset

 to the minimal server.
 Using the new web page we can see that three items are requested by the
 client: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'/'
\end_layout

\end_inset

 the web page, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'/10-Circular.coffee'
\end_layout

\end_inset

 the code module, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'/favicon.ico'
\end_layout

\end_inset

 that we can ignore.
 That is enough information to add some if statements to it.
\end_layout

\begin_layout Standard
For the module request we have to read the file, compile it with CoffeeScript
 (using the same module as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eval
\end_layout

\end_inset

) and return the compiled code, that the browser can understand, in the
 response.
 When a request is made for anything else then a simple response is 
\begin_inset Quotes els
\end_inset

not found
\begin_inset Quotes ers
\end_inset

, that's a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

404
\end_layout

\end_inset

 in 
\shape smallcaps
\size small
HTTP
\shape default
\size default
.
\end_layout

\begin_layout Standard
If you looked in the prelude how it was reading a file, then that is 
\emph on
not
\emph default
 the way to read a file in a server.
 The prelude uses a synchronous function, that means that everything stops
 until the file has been read.
 In the world of servers hard disks are slow, and one request should not
 stop other requests.
 Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

readFile
\end_layout

\end_inset

 solves this because its last argument is for a function that will only
 be run when the file has been read — the server can then process other
 requests in the meantime.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

# Server-side HTTP server
\end_layout

\begin_layout Plain Layout

show = console.log
\end_layout

\begin_layout Plain Layout

http = require "http"
\end_layout

\begin_layout Plain Layout

fs = require "fs"
\end_layout

\begin_layout Plain Layout

cs = require("coffee-script").CoffeeScript
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

server = http.createServer (req, res) ->
\end_layout

\begin_layout Plain Layout

  show "#{req.client.remoteAddress} " +
\end_layout

\begin_layout Plain Layout

       "#{req.method} #{req.url}"
\end_layout

\begin_layout Plain Layout

  if req.method is "GET"
\end_layout

\begin_layout Plain Layout

    if req.url is "/"
\end_layout

\begin_layout Plain Layout

      res.writeHead 200, "Content-Type": "text/html"
\end_layout

\begin_layout Plain Layout

      res.write webpage
\end_layout

\begin_layout Plain Layout

      res.end()
\end_layout

\begin_layout Plain Layout

      return
\end_layout

\begin_layout Plain Layout

    else if req.url is "/10-Circular.coffee"
\end_layout

\begin_layout Plain Layout

      fs.readFile ".#{req.url}", "utf8", (err, data) ->
\end_layout

\begin_layout Plain Layout

        if err then throw err
\end_layout

\begin_layout Plain Layout

        compiledContent = cs.compile data
\end_layout

\begin_layout Plain Layout

        res.writeHead 200,
\end_layout

\begin_layout Plain Layout

          "Content-Type": "application/javascript"
\end_layout

\begin_layout Plain Layout

        res.write compiledContent
\end_layout

\begin_layout Plain Layout

        res.end()
\end_layout

\begin_layout Plain Layout

      return
\end_layout

\begin_layout Plain Layout

  res.writeHead 404, "Content-Type": "text/html"
\end_layout

\begin_layout Plain Layout

  res.write "404 Not found"
\end_layout

\begin_layout Plain Layout

  res.end()
\end_layout

\begin_layout Plain Layout

server.listen 3389
\end_layout

\begin_layout Plain Layout

show "Server running at"
\end_layout

\begin_layout Plain Layout

show server.address()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I think you can see that this code practically begs to be abstracted and
 modularized.
 Instead of an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 chain, we could have a function with an object as argument where each attribute
 is a request and each value a function to handle the request.
 Then there is error handling, if the file is not found then the server
 throws an error and stops.
 The purpose of 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'10-SeedLife.coffee'
\end_layout

\end_inset

 is to show how you can use a module on a web page, so refactoring and beautifyi
ng the server is up to you
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
If you want to understand how to write your own 
\shape smallcaps
\size footnotesize
HTTP
\shape default
\size default
 server then Manuel Kiessling has a 
\begin_inset CommandInset href
LatexCommand href
name "tutorial"
target "http://www.nodebeginner.org/"

\end_inset

 that you can easily translate into your own CoffeeScript web server.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Building a program as a set of nice, small modules often means the program
 will use a lot of different files.
 When programming for the web, having lots of small code files on a page
 tend to make the page slower to load.
 This does not have to be a problem though.
 You can write and test your program as a number of small files, and put
 them all into a single big file when 
\begin_inset Quotes els
\end_inset

publishing
\begin_inset Quotes ers
\end_inset

 the program to the web.
 The CoffeeScript compiler has a join feature for this.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
A module or group of modules that can be useful in more than one program
 is usually called a library
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
library
\end_layout

\end_inset

.
 For many programming languages, there is a huge set of quality libraries
 available.
 This means programmers do not have to start from scratch all the time,
 which can make them a lot more productive.
\end_layout

\begin_layout Standard
For Coffee\SpecialChar \-
Script, unfortunately, the number of available libraries is not
 very large.
 But you can use JavaScript libraries as a stopgap.
 Underscore is an example of a good library with its 
\begin_inset Quotes els
\end_inset

basic
\begin_inset Quotes ers
\end_inset

 tools, things like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clone
\end_layout

\end_inset

.
 Other languages tend to provide such obviously useful things as built-in
 standard features, but with Coffee\SpecialChar \-
Script you will have to either build
 a collection of them for yourself or use a library.
\end_layout

\begin_layout Standard
Using a library is recommended: It is less work, and the code in a library
 has usually been tested more thoroughly than the things you write yourself.
 Some things to check when selecting a library is functionality, adequate
 documentation, and readable source code — and that the library is small
 enough that you can understand and fix bugs in it — if need be on your
 own.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Beyond the concept of modules and programs is the world of distributed programmi
ng where processes running on different machines collaborate on solving
 a task or interact with each other in near real time.
 One protocol that enables distributed programming is 
\begin_inset CommandInset href
LatexCommand href
name "WebSockets"
target "http://dev.w3.org/html5/websockets/"

\end_inset

.
\end_layout

\begin_layout Standard
A WebSocket is a bi-directional, full-duplex communications channel over
 a TCP socket.
 Possibly the same socket that a web server is using.
 With bi-directional, full-duplex support a server and its clients can send
 messages back and forth concurrently.
 It opens the door to many kinds of web applications that would have been
 difficult to implement over http.
\end_layout

\begin_layout Standard
Most of the latest web browsers have support for WebSockets.
 Some have it disabled by default because of potential security issues in
 the draft protocol, the prelude shows how to enable WebSocket support in
 Firefox and Opera.
 It is enabled in Chrome and Safari.
 To see if your web browser works with WebSockets you can run 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'10-TestWebSocket.coffee'
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
To connect a client to a WebSocket server, you create a 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

WebSocket
\end_layout

\end_inset

 object with a server as its endpoint.
 Note the 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

ws
\end_layout

\end_inset

 protocol instead of 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

http
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

websocket = new WebSocket 'ws://localhost:8080/'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can attach functions to a 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

WebSocket
\end_layout

\end_inset

 object, so your code can react when certain events occur.
 There are four of them: 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

onopen
\end_layout

\end_inset

, 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

onclose
\end_layout

\end_inset

, 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

onmessage
\end_layout

\end_inset

, and 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

onerror
\end_layout

\end_inset

.
 Sending a message to the server is done with 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

websocket.onopen = (evt) ->
\end_layout

\begin_layout Plain Layout

  writeToScreen 'CONNECTED'
\end_layout

\begin_layout Plain Layout

  websocket.send 'WebSocket works!'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is how simple it is with a client on a web page.
 In CoffeeScript's server-side environment there is not yet support for
 WebSockets, but that is easily fixed with the 
\family typewriter
ws
\family default
 library from Jacek Becela.
 It is less than 200 lines when translated into CoffeeScript.
 It is present in the prelude or you can use it directly from 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

prelude/ws.coffee
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To create a server you pass a function to its 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

createServer
\end_layout

\end_inset

 method and get a 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

websocket
\end_layout

\end_inset

 object as an argument where you can attach methods to listen for events.
 To send a message to a client, call its 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

write
\end_layout

\end_inset

 method with a string.
 Here is an abbreviated use of it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

wsHandler = (websocket) ->
\end_layout

\begin_layout Plain Layout

  websocket.on 'connect', (resource) ->
\end_layout

\begin_layout Plain Layout

    show 'connect: ' + resource
\end_layout

\begin_layout Plain Layout

    # ...
\end_layout

\begin_layout Plain Layout

  websocket.on 'data', (data) ->
\end_layout

\begin_layout Plain Layout

    show data                    # process data
\end_layout

\begin_layout Plain Layout

    websocket.write 'Cowabunga!' # respond
\end_layout

\begin_layout Plain Layout

  # ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

wsServer = ws.createServer wsHandler
\end_layout

\begin_layout Plain Layout

wsServer.listen 8080
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
So without further ado here follows an animated version of 
\emph on
Seed of Life
\emph default
\SpecialChar \ldots{}
 Find it in 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

'10-WebSocketLife.coffee'
\end_layout

\end_inset

 and change it any way you like.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

kup = require './prelude/coffeekup'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Web page with canvas and client-side WebSocket
\end_layout

\begin_layout Plain Layout

webpage = kup.render -> 
\end_layout

\begin_layout Plain Layout

  doctype 5
\end_layout

\begin_layout Plain Layout

  html ->
\end_layout

\begin_layout Plain Layout

    head ->
\end_layout

\begin_layout Plain Layout

      meta charset: 'utf-8'
\end_layout

\begin_layout Plain Layout

      title 'My animation | My awesome website'
\end_layout

\begin_layout Plain Layout

      style '''
\end_layout

\begin_layout Plain Layout

        body {font-family: sans-serif}
\end_layout

\begin_layout Plain Layout

        header, nav, section, footer {display: block}
\end_layout

\begin_layout Plain Layout

      '''
\end_layout

\begin_layout Plain Layout

      coffeescript ->
\end_layout

\begin_layout Plain Layout

        show = (msg) -> console.log msg
\end_layout

\begin_layout Plain Layout

        color = 'rgba(255,40,20,0.7)'
\end_layout

\begin_layout Plain Layout

        circle = (ctx, x, y) ->
\end_layout

\begin_layout Plain Layout

          ctx.strokeStyle = color
\end_layout

\begin_layout Plain Layout

          ctx.beginPath()
\end_layout

\begin_layout Plain Layout

          ctx.arc x, y, 100, 0, 2*Math.PI, false
\end_layout

\begin_layout Plain Layout

          ctx.stroke()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        addElement = (ni, num, text) ->
\end_layout

\begin_layout Plain Layout

          newdiv = document.createElement 'div'
\end_layout

\begin_layout Plain Layout

          newdiv.setAttribute 'id', 'div' + num
\end_layout

\begin_layout Plain Layout

          newdiv.innerHTML = text
\end_layout

\begin_layout Plain Layout

          ni.appendChild newdiv
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        wsUri = 'ws://localhost:8080/'
\end_layout

\begin_layout Plain Layout

        websocket = undefined
\end_layout

\begin_layout Plain Layout

        num = 0
\end_layout

\begin_layout Plain Layout

        socketClient = (buffer, ctx, x, y) ->
\end_layout

\begin_layout Plain Layout

          websocket = new WebSocket wsUri
\end_layout

\begin_layout Plain Layout

          websocket.onopen = (evt) ->
\end_layout

\begin_layout Plain Layout

            show 'Connected'
\end_layout

\begin_layout Plain Layout

          websocket.onclose = (evt) ->
\end_layout

\begin_layout Plain Layout

            show 'Closed'
\end_layout

\begin_layout Plain Layout

          websocket.onerror = (evt) ->
\end_layout

\begin_layout Plain Layout

            show 'Error: ' + evt.data
\end_layout

\begin_layout Plain Layout

          websocket.onmessage = (evt) ->
\end_layout

\begin_layout Plain Layout

            #show evt.data
\end_layout

\begin_layout Plain Layout

            addElement buffer, num++, evt.data
\end_layout

\begin_layout Plain Layout

            pt = JSON.parse evt.data
\end_layout

\begin_layout Plain Layout

            if pt.color? then color = pt.color
\end_layout

\begin_layout Plain Layout

            circle ctx, x+100*pt.x, y+100*pt.y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        window.onload = ->
\end_layout

\begin_layout Plain Layout

          canvas = document.getElementById 'drawCanvas'
\end_layout

\begin_layout Plain Layout

          context = canvas.getContext '2d'
\end_layout

\begin_layout Plain Layout

          buffer = document.getElementById 'message'
\end_layout

\begin_layout Plain Layout

          socketClient buffer, context, 300, 200
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        window.sendMessage = ->
\end_layout

\begin_layout Plain Layout

          msg = document.getElementById('entryfield').value
\end_layout

\begin_layout Plain Layout

          websocket.send msg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    body ->
\end_layout

\begin_layout Plain Layout

      header -> h1 'Seed of Life'
\end_layout

\begin_layout Plain Layout

      input id:'entryfield', value:'rgba(40,200,25,0.7)'
\end_layout

\begin_layout Plain Layout

      button type: 'button', onclick: 'sendMessage()'
\end_layout

\begin_layout Plain Layout

        'Change Color'
\end_layout

\begin_layout Plain Layout

      br
\end_layout

\begin_layout Plain Layout

      canvas id: 'drawCanvas', width: 600, height: 400
\end_layout

\begin_layout Plain Layout

      div id: 'message'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Server-side WebSocket server
\end_layout

\begin_layout Plain Layout

ws = require './prelude/ws'
\end_layout

\begin_layout Plain Layout

cp = require './10-Circular'
\end_layout

\begin_layout Plain Layout

wsHandler = (websocket) ->
\end_layout

\begin_layout Plain Layout

  websocket.on 'connect', (resource) ->
\end_layout

\begin_layout Plain Layout

    show 'connect: ' + resource
\end_layout

\begin_layout Plain Layout

    # close connection after 10s
\end_layout

\begin_layout Plain Layout

    setTimeout websocket.end, 10 * 1000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  websocket.on 'data', (data) ->
\end_layout

\begin_layout Plain Layout

    show data # process data
\end_layout

\begin_layout Plain Layout

    blue = 'rgba(40,20,255,0.7)'
\end_layout

\begin_layout Plain Layout

    websocket.write JSON.stringify
\end_layout

\begin_layout Plain Layout

      color: if data is '' then blue else data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  websocket.on 'close', ->
\end_layout

\begin_layout Plain Layout

    show 'closing'
\end_layout

\begin_layout Plain Layout

    process.exit 0 # Exit server completely
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  circ = new cp.CircularPosition 0.01
\end_layout

\begin_layout Plain Layout

  annoy = setInterval (->
\end_layout

\begin_layout Plain Layout

    websocket.write JSON.stringify circ.nextPoint()), 20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

wsServer = ws.createServer wsHandler
\end_layout

\begin_layout Plain Layout

wsServer.listen 8080
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Launch test server and client UI
\end_layout

\begin_layout Plain Layout

require './prelude'
\end_layout

\begin_layout Plain Layout

viewServer webpage
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Through the examples, exercises and explanations you have a foundation for
 your own projects: a collaborative web application, a multi-user game,
 a library with an aesthetically pleasing implementation, \SpecialChar \ldots{}

\end_layout

\begin_layout Standard
First choose what your project is going to be about, then look to 
\begin_inset CommandInset href
LatexCommand href
name "github"
target "https://github.com/languages/CoffeeScript"

\end_inset

 for supporting code and libraries.
 A couple of interesting ones for web applications are 
\begin_inset CommandInset href
LatexCommand href
name "Zappa"
target "https://github.com/mauricemach/zappa"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "SocketStream"
target "https://github.com/socketstream/socketstream"

\end_inset

.
\end_layout

\begin_layout Standard
If you would like a broader foundation in computer science then read: 
\begin_inset CommandInset href
LatexCommand href
name "Concepts, Techniques, and Models of Computer Programming"
target "http://cisnet.mit.edu/4i7o9/5cjhf/toc"

\end_inset

 by Peter van Roy and Seif Haridi.
 Not a word of CoffeeScript, but plenty of insight.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Quote

\emph on
Dimidium facti qui coepit habet: sapere aude, incipe
\end_layout

\begin_layout Quote

\emph on
He who has begun has half done.
 Dare to be wise; begin!
\end_layout

\begin_layout Dictum
\noindent

\family sans
\size footnotesize
Quintus Horatius Flaccus
\end_layout

\begin_layout Part
Appendix
\end_layout

\begin_layout Chapter
\start_of_appendix
Language extras
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Language Extras
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Language-extras"

\end_inset


\end_layout

\begin_layout Standard
Most of the Coffee\SpecialChar \-
Script language has been introduced in 
\family sans
Smooth Coffee\SpecialChar \-
Script.

\family default
 This appendix illustrates some extra language constructs and idioms that
 may come in handy.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
There is a statement called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
switch
\end_layout

\end_inset

 which can be used to choose which code to execute based on some value.
 Alternatives include a chain of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statements or an associative data structure.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

weatherAdvice = (weather) ->
\end_layout

\begin_layout Plain Layout

  show 'When it is ' + weather
\end_layout

\begin_layout Plain Layout

  switch weather
\end_layout

\begin_layout Plain Layout

    when 'sunny'
\end_layout

\begin_layout Plain Layout

      show 'Dress lightly.'
\end_layout

\begin_layout Plain Layout

      show 'Go outside.'
\end_layout

\begin_layout Plain Layout

    when 'cloudy'
\end_layout

\begin_layout Plain Layout

      show 'Go outside.'
\end_layout

\begin_layout Plain Layout

    when 'tornado', 'hurricane'
\end_layout

\begin_layout Plain Layout

      show 'Seek shelter'
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      show 'Unknown weather type: ' + weather
\end_layout

\begin_layout Plain Layout

weatherAdvice 'sunny'
\end_layout

\begin_layout Plain Layout

weatherAdvice 'cloudy'
\end_layout

\begin_layout Plain Layout

weatherAdvice 'tornado'
\end_layout

\begin_layout Plain Layout

weatherAdvice 'hailstorm'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inside the block opened by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset

, you can write a number of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

when
\end_layout

\end_inset

 labels.
 The program will jump to the label that corresponds to the value that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset

 was given or to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 if no matching value is found.
 Then it executes statements in the following block until it reaches the
 next 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

when
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 statement.
 Unlike some other languages there is no fall-through between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

when
\end_layout

\end_inset

 cases and no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 statement is therefore needed.
 You can have a comma-separated lists after a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

when
\end_layout

\end_inset

, any of the values is then used to find a match.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Closely related to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

, there is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

continue
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
continue
\end_layout

\end_inset

.
 They can be used in the same places.
 While 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 jumps 
\emph on
out
\emph default
 of a loop and causes the program to proceed after the loop, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

continue
\end_layout

\end_inset

 jumps to the next iteration of the loop.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for i in [20...30]
\end_layout

\begin_layout Plain Layout

  if i % 3 != 0
\end_layout

\begin_layout Plain Layout

    continue
\end_layout

\begin_layout Plain Layout

  show i + ' is divisible by three.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A similar effect can usually be produced using just 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

, but there are cases where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

continue
\end_layout

\end_inset

 looks nicer.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Pattern matching has been touched upon, a few more examples can clarify
 the scope of it.
 You can assign an object to an anonymous object with matching attribute
 names.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

class Point
\end_layout

\begin_layout Plain Layout

  constructor: (@x, @y) ->
\end_layout

\begin_layout Plain Layout

pt = new Point 3, 4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

{x, y} = pt
\end_layout

\begin_layout Plain Layout

show "x is #{x} and y is #{y}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Attribute names can be inferred from an anonymous object.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

firstName = "Alan"
\end_layout

\begin_layout Plain Layout

lastName = "Turing"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

name = {firstName, lastName}
\end_layout

\begin_layout Plain Layout

show name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A function can have an anonymous object as argument and extract the attributes
 as variables.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

decorate = ({firstName, lastName}) ->
\end_layout

\begin_layout Plain Layout

  show "Distinguished #{firstName} " +
\end_layout

\begin_layout Plain Layout

       "of the #{lastName} family."
\end_layout

\begin_layout Plain Layout

decorate name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Unicode can be used in identifiers.
 Letter forms that are very similar to characters in the western alphabets
 should be avoided.
 It can be difficult in internationally shared projects due to different
 keyboard layouts, but useful in teaching math or in a local language.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pi = π = Math.PI
\end_layout

\begin_layout Plain Layout

sphereSurfaceArea = (r) -> 4 * π * r * r
\end_layout

\begin_layout Plain Layout

radius = 1
\end_layout

\begin_layout Plain Layout

show '4 * π * r * r when r = ' + radius
\end_layout

\begin_layout Plain Layout

show sphereSurfaceArea radius
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Qualifying a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 statement with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

when
\end_layout

\end_inset

 clause can be used to filter array or object elements on a logical condition.
 Great for one-liners.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

evens = (n) -> i for i in [0..n] when i % 2 is 0
\end_layout

\begin_layout Plain Layout

show evens 6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

steppenwolf = 
\end_layout

\begin_layout Plain Layout

  title:   'Tonight at the Magic Theater'
\end_layout

\begin_layout Plain Layout

  warning: 'For Madmen only'
\end_layout

\begin_layout Plain Layout

  caveat:  'Price of Admittance: Your Mind.'
\end_layout

\begin_layout Plain Layout

  caution: 'Not for Everybody.'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stipulations = (text for key, text of steppenwolf 
\backslash

\end_layout

\begin_layout Plain Layout

  when key in ['warning', 'caveat'])
\end_layout

\begin_layout Plain Layout

show stipulations
\end_layout

\begin_layout Plain Layout

show ultimatum for ultimatum in stipulations 
\backslash

\end_layout

\begin_layout Plain Layout

  when ultimatum.match /Price/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Destructuring assignment can be used to swap or reassign variables.
 It is also handy for extracting values or returning multiple values from
 a function.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

tautounlogical = "the reason is because I say so"
\end_layout

\begin_layout Plain Layout

splitStringAt = (str, n) ->
\end_layout

\begin_layout Plain Layout

  [str.substring(0,n), str.substring(n)]
\end_layout

\begin_layout Plain Layout

[pre, post] = splitStringAt tautounlogical, 14
\end_layout

\begin_layout Plain Layout

[pre, post] = [post, pre] # swap
\end_layout

\begin_layout Plain Layout

show "#{pre} #{post}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

[re,mi,fa,sol,la,ti] = [1..6]
\end_layout

\begin_layout Plain Layout

[dal,ra...,mim] = [ti,re,fa,sol,la,mi]
\end_layout

\begin_layout Plain Layout

show "#{dal}, #{ra} and #{mim}"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[key, word] = if re > ti then [mi, fa] else [fa, mi]
\end_layout

\begin_layout Plain Layout

show "#{key} and #{word}"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
A function can be bound to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset

 value that is in effect when it is defined.
 This can be needed when you are using event handlers or callback based
 libraries e.g.
 jQuery.
 Instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

 use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 to bind 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In the following example the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a.display
\end_layout

\end_inset

 would show 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 when called in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Container
\end_layout

\end_inset

 if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

display
\end_layout

\end_inset

 was defined with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Widget
\end_layout

\begin_layout Plain Layout

  id: 'I am a widget'
\end_layout

\begin_layout Plain Layout

  display: => show @id
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Container
\end_layout

\begin_layout Plain Layout

  id: 'I am a container'
\end_layout

\begin_layout Plain Layout

  callback: (f) ->
\end_layout

\begin_layout Plain Layout

    show @id
\end_layout

\begin_layout Plain Layout

    f()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a = new Widget
\end_layout

\begin_layout Plain Layout

a.display()
\end_layout

\begin_layout Plain Layout

b = new Container
\end_layout

\begin_layout Plain Layout

b.callback a.display
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
With the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

do
\end_layout

\end_inset

 statement you can call a named or an anonymous function:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

n = 3
\end_layout

\begin_layout Plain Layout

f = -> show "Say: 'Yes!'"
\end_layout

\begin_layout Plain Layout

do f
\end_layout

\begin_layout Plain Layout

(do -> show "Yes!") while n-- > 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which is reminiscent of the syntax for a function that takes a function
 as its parameter.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "string={[b]\&quot;}"
inline false
status open

\begin_layout Plain Layout

echoEchoEcho = (msg) -> msg() + msg() + msg()
\end_layout

\begin_layout Plain Layout

show echoEchoEcho -> "No"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

do
\end_layout

\end_inset

 statement captures the environment, so it is available inside its block.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

setTimeout
\end_layout

\end_inset

 function calls the innermost function after the loop has finished.
 Without capture the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i
\end_layout

\end_inset

 variable is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

4
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for i in [1..3]
\end_layout

\begin_layout Plain Layout

  do (i) ->
\end_layout

\begin_layout Plain Layout

    setTimeout (-> show 'With do: ' + i), 0
\end_layout

\begin_layout Plain Layout

for i in [1..3]
\end_layout

\begin_layout Plain Layout

  setTimeout (-> show 'Without: ' + i), 0
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Binary Heaps
\begin_inset Argument
status collapsed

\begin_layout Plain Layout

\family sans
Binary Heaps
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Binary-Heaps"

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Searching"

\end_inset

, the binary heap
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
binary heap
\end_layout

\end_inset

 was introduced as a method to store a collection of objects in such a way
 that the smallest element can be quickly found.
 As promised, this appendix will explain the details behind this data structure.
\end_layout

\begin_layout Standard
Consider again the problem we needed to solve.
 The A* algorithm created large amounts of small objects, and had to keep
 these in an 
\begin_inset Quotes els
\end_inset

open list
\begin_inset Quotes ers
\end_inset

.
 It was also constantly removing the smallest element from this list.
 The simplest approach would be to just keep all the objects in an array,
 and search for the smallest one when we need it.
 But, unless we have a 
\emph on
lot
\emph default
 of time, this will not do.
 Finding the smallest element in an unsorted array requires going over the
 whole array, and checking each element.
\end_layout

\begin_layout Standard
The next solution would be, of course, to sort our array.
 Coffee\SpecialChar \-
Script arrays have a wonderful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sort
\end_layout

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
sort
\end_layout

\end_inset

 method, which can be used to do the heavy work.
 Unfortunately, re-sorting a whole array every time an element is removed
 is more work than searching for a minimum value in an unsorted array.
 Some tricks can be used, such as, instead of re-sorting the whole array,
 just making sure new values are inserted in the right place so that the
 array, which was sorted before, stays sorted.
 This is coming closer to the approach a binary heap uses already, but inserting
 a value in the middle of an array requires moving all the elements after
 it one place up, which is still just too slow.
\end_layout

\begin_layout Standard
Another approach is to not use an array at all, but to store the values
 in a set of interconnected objects.
 A simple form of this is to have every object hold one value and two (or
 less) links to other objects.
 There is one root object, holding the smallest value, which is used to
 access all the other objects.
 Links always point to objects holding greater values, so the whole structure
 looks something like this:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/tree.png
	lyxscale 60
	width 90text%
	clip

\end_inset


\end_layout

\begin_layout Standard
Such structures are usually called tree
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
tree
\end_layout

\end_inset

s, because of the way they branch.
 Now, when you need the smallest element, you just take off the top element
 and rearrange the tree so that one of the top element
\begin_inset Quotes ers
\end_inset

s children — the one with the lowest value — becomes the new top.
 When inserting new elements, you 
\begin_inset Quotes els
\end_inset

descend
\begin_inset Quotes ers
\end_inset

 the tree until you find an element less than the new element, and insert
 it there.
 This takes a lot less searching than a sorted array does, but it has the
 disadvantage of creating a lot of objects, which also slows things down.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
A binary heap, then, does make use of a sorted array, but it is only partially
 sorted, much like the tree above.
 Instead of objects, the positions in the array are used to form a tree,
 as this picture tries to show:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/heap.png
	lyxscale 40
	width 40text%
	BoundingBox 0bp 0bp 507bp 522bp
	clip

\end_inset


\end_layout

\begin_layout Standard
Array element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 is the root of the tree, array element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset

 are its children, and in general array element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 has children 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X * 2
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X * 2 + 1
\end_layout

\end_inset

.
 You can see why this structure is called a 
\begin_inset Quotes els
\end_inset

heap
\begin_inset Quotes ers
\end_inset

.
 Note that this array starts at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, while Coffee\SpecialChar \-
Script arrays start at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 The heap will always keep the smallest element in position 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, and make sure that for every element in the array at position 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, the element at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X / 2
\end_layout

\end_inset

 (round down) is smaller.
\end_layout

\begin_layout Standard
Finding the smallest element is now a matter of taking the element at position
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

.
 But when this element is removed, the heap must make sure that there are
 no holes left in the array.
 To do this, it takes the last element in the array and moves it to the
 start, and then compares it to its child elements at position 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset

.
 It is likely to be greater, so it is exchanged with one of them, and the
 process of comparing it with its children is repeated for the new position,
 and so on, until it comes to a position where its children are greater,
 or a position where it has no children.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[2, 3, 5, 4, 8, 7, 6]
\end_layout

\begin_layout Plain Layout

# Take out 2, move 6 to the front.
\end_layout

\begin_layout Plain Layout

[6, 3, 5, 4, 8, 7]
\end_layout

\begin_layout Plain Layout

# 6 is greater than its first child 3, so swap them.
\end_layout

\begin_layout Plain Layout

[3, 6, 5, 4, 8, 7]
\end_layout

\begin_layout Plain Layout

# Now 6 has children 4 and 8 (position 4 and 5).
\end_layout

\begin_layout Plain Layout

# It is greater than 4, so we swap again.
\end_layout

\begin_layout Plain Layout

[3, 4, 5, 6, 8, 7]
\end_layout

\begin_layout Plain Layout

# 6 is in position 4, and has no more children.
\end_layout

\begin_layout Plain Layout

# The heap is in order again.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similarly, when an element has to be added to the heap, it is put at the
 end of the array and allowed to 
\begin_inset Quotes els
\end_inset

bubble
\begin_inset Quotes ers
\end_inset

 up by repeatedly exchanging it with its parent, until we find a parent
 that is less than the new node.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[3, 4, 5, 6, 8, 7]
\end_layout

\begin_layout Plain Layout

# Element 2 gets added again, it starts at the back.
\end_layout

\begin_layout Plain Layout

[3, 4, 5, 6, 8, 7, 2]
\end_layout

\begin_layout Plain Layout

# 2 is in position 7, its parent is at 3, which
\end_layout

\begin_layout Plain Layout

# is a 5.
 5 is greater than 2, so we swap.
\end_layout

\begin_layout Plain Layout

[3, 4, 2, 6, 8, 7, 5]
\end_layout

\begin_layout Plain Layout

# The parent of position 3 is position 1.
\end_layout

\begin_layout Plain Layout

# Again, we swap.
\end_layout

\begin_layout Plain Layout

[2, 4, 3, 6, 8, 7, 5]
\end_layout

\begin_layout Plain Layout

# The element can not go further than position 1,
\end_layout

\begin_layout Plain Layout

# so we are done.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note how adding or inserting an element does not require it to be compared
 with every element in the array.
 In fact, because the jumps between parents and children get bigger as the
 array gets bigger, this advantage is especially large when we have a lot
 of elements
\begin_inset Foot
status open

\begin_layout Plain Layout
The amount of comparisons and swaps that are needed — in the worst case
 — can be approached by taking the logarithm (base 2) of the amount of elements
 in the heap.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
Here is the full code of a binary heap implementation.
 Two things to note are that, instead of directly comparing the elements
 put into the heap, a function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scoreFunction
\end_layout

\end_inset

) is first applied to them, so that it becomes possible to store objects
 that can not be directly compared.
 The default is the identity function.
\end_layout

\begin_layout Standard
Also, because Coffee\SpecialChar \-
Script arrays start at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, and the parent/child calculations use a system that starts at 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, there are a few strange calculations to compensate.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

class BinaryHeap
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # Public
\end_layout

\begin_layout Plain Layout

  #--------
\end_layout

\begin_layout Plain Layout

  constructor: (@scoreFunction = (x) -> x) ->
\end_layout

\begin_layout Plain Layout

    @content = []
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  push: (element) ->
\end_layout

\begin_layout Plain Layout

    # Add the new element to the end of the array.
\end_layout

\begin_layout Plain Layout

    @content.push element
\end_layout

\begin_layout Plain Layout

    # Allow it to bubble up.
\end_layout

\begin_layout Plain Layout

    @_bubbleUp @content.length - 1
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  pop: ->
\end_layout

\begin_layout Plain Layout

    # Store the first element so we can return it later.
\end_layout

\begin_layout Plain Layout

    result = @content[0]
\end_layout

\begin_layout Plain Layout

    # Get the element at the end of the array.
\end_layout

\begin_layout Plain Layout

    end = @content.pop()
\end_layout

\begin_layout Plain Layout

    # If there are any elements left, put the end
\end_layout

\begin_layout Plain Layout

    # element at the start, and let it sink down.
\end_layout

\begin_layout Plain Layout

    if @content.length > 0
\end_layout

\begin_layout Plain Layout

      @content[0] = end
\end_layout

\begin_layout Plain Layout

      @_sinkDown 0
\end_layout

\begin_layout Plain Layout

    result
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

  size: -> @content.length
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  remove: (node) ->
\end_layout

\begin_layout Plain Layout

    len = @content.length
\end_layout

\begin_layout Plain Layout

    # To remove a value, we must search through the
\end_layout

\begin_layout Plain Layout

    # array to find it.
\end_layout

\begin_layout Plain Layout

    for i in [0...len]
\end_layout

\begin_layout Plain Layout

      if @content[i] == node
\end_layout

\begin_layout Plain Layout

        # When it is found, the process seen in 'pop'
\end_layout

\begin_layout Plain Layout

        # is repeated to fill up the hole.
\end_layout

\begin_layout Plain Layout

        end = @content.pop()
\end_layout

\begin_layout Plain Layout

        if i != len - 1
\end_layout

\begin_layout Plain Layout

          @content[i] = end
\end_layout

\begin_layout Plain Layout

          if @scoreFunction(end) < @scoreFunction(node)
\end_layout

\begin_layout Plain Layout

            @_bubbleUp i
\end_layout

\begin_layout Plain Layout

          else
\end_layout

\begin_layout Plain Layout

            @_sinkDown i
\end_layout

\begin_layout Plain Layout

        return
\end_layout

\begin_layout Plain Layout

    throw new Error 'Node not found.'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # Private
\end_layout

\begin_layout Plain Layout

  #---------
\end_layout

\begin_layout Plain Layout

  _bubbleUp: (n) ->
\end_layout

\begin_layout Plain Layout

    # Fetch the element that has to be moved.
\end_layout

\begin_layout Plain Layout

    element = @content[n]
\end_layout

\begin_layout Plain Layout

    # When at 0, an element can not go up any further.
\end_layout

\begin_layout Plain Layout

    while n > 0
\end_layout

\begin_layout Plain Layout

      # Compute the parent element index, and fetch it.
\end_layout

\begin_layout Plain Layout

      parentN = Math.floor((n + 1) / 2) - 1
\end_layout

\begin_layout Plain Layout

      parent = @content[parentN]
\end_layout

\begin_layout Plain Layout

      # Swap the elements if the parent is greater.
\end_layout

\begin_layout Plain Layout

      if @scoreFunction(element) < @scoreFunction(parent)
\end_layout

\begin_layout Plain Layout

        @content[parentN] = element
\end_layout

\begin_layout Plain Layout

        @content[n] = parent
\end_layout

\begin_layout Plain Layout

        # Update 'n' to continue at the new position.
\end_layout

\begin_layout Plain Layout

        n = parentN
\end_layout

\begin_layout Plain Layout

      # Found a parent that is less,
\end_layout

\begin_layout Plain Layout

      # no need to move it further.
\end_layout

\begin_layout Plain Layout

      else
\end_layout

\begin_layout Plain Layout

        break
\end_layout

\begin_layout Plain Layout

    return
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

  _sinkDown: (n) ->
\end_layout

\begin_layout Plain Layout

    # Look up the target element and its score.
\end_layout

\begin_layout Plain Layout

    length = @content.length
\end_layout

\begin_layout Plain Layout

    element = @content[n]
\end_layout

\begin_layout Plain Layout

    elemScore = @scoreFunction element
\end_layout

\begin_layout Plain Layout

    loop
\end_layout

\begin_layout Plain Layout

      # Compute the indices of the child elements.
\end_layout

\begin_layout Plain Layout

      child2N = (n + 1) * 2
\end_layout

\begin_layout Plain Layout

      child1N = child2N - 1
\end_layout

\begin_layout Plain Layout

      # This is used to store the new position of
\end_layout

\begin_layout Plain Layout

      # the element, if any.
\end_layout

\begin_layout Plain Layout

      swap = null
\end_layout

\begin_layout Plain Layout

      # If the first child exists (is inside the array)...
\end_layout

\begin_layout Plain Layout

      if child1N < length
\end_layout

\begin_layout Plain Layout

        # Look it up and compute its score.
\end_layout

\begin_layout Plain Layout

        child1 = @content[child1N]
\end_layout

\begin_layout Plain Layout

        child1Score = this.scoreFunction child1
\end_layout

\begin_layout Plain Layout

        # If the score is less than our elements,
\end_layout

\begin_layout Plain Layout

        # we need to swap.
\end_layout

\begin_layout Plain Layout

        if child1Score < elemScore
\end_layout

\begin_layout Plain Layout

          swap = child1N
\end_layout

\begin_layout Plain Layout

      # Do the same checks for the other child.
\end_layout

\begin_layout Plain Layout

      if child2N < length
\end_layout

\begin_layout Plain Layout

        child2 = @content[child2N]
\end_layout

\begin_layout Plain Layout

        child2Score = @scoreFunction child2
\end_layout

\begin_layout Plain Layout

        compScore = if swap == null
\end_layout

\begin_layout Plain Layout

            elemScore
\end_layout

\begin_layout Plain Layout

          else
\end_layout

\begin_layout Plain Layout

            child1Score
\end_layout

\begin_layout Plain Layout

        if child2Score < compScore
\end_layout

\begin_layout Plain Layout

          swap = child2N
\end_layout

\begin_layout Plain Layout

      # If the element needs to be moved,
\end_layout

\begin_layout Plain Layout

      # swap it, and continue.
\end_layout

\begin_layout Plain Layout

      if swap != null
\end_layout

\begin_layout Plain Layout

        @content[n] = @content[swap]
\end_layout

\begin_layout Plain Layout

        @content[swap] = element
\end_layout

\begin_layout Plain Layout

        n = swap
\end_layout

\begin_layout Plain Layout

      # Otherwise, we are done.
\end_layout

\begin_layout Plain Layout

      else
\end_layout

\begin_layout Plain Layout

        break
\end_layout

\begin_layout Plain Layout

    return
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(exports ? this).BinaryHeap = BinaryHeap
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
And some test cases\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

sortByValue = (obj) -> sortBy obj, (n) -> n
\end_layout

\begin_layout Plain Layout

buildHeap = (c, a) ->
\end_layout

\begin_layout Plain Layout

    heap = new BinaryHeap
\end_layout

\begin_layout Plain Layout

    heap.push number for number in a
\end_layout

\begin_layout Plain Layout

    c.note heap
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

declare 'heap is created empty', [],
\end_layout

\begin_layout Plain Layout

  (c) -> c.assert (new BinaryHeap).size() == 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

declare 'heap pop is undefined when empty', [],
\end_layout

\begin_layout Plain Layout

  (c) -> c.assert isUndefined (new BinaryHeap).pop()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

declare 'heap contains number of inserted elements',
\end_layout

\begin_layout Plain Layout

  [arbArray(arbInt)], (c, a) ->
\end_layout

\begin_layout Plain Layout

    c.assert buildHeap(c, a).size() == a.length
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

declare 'heap contains inserted elements',
\end_layout

\begin_layout Plain Layout

  [arbArray(arbInt)], (c, a) ->
\end_layout

\begin_layout Plain Layout

    heap = buildHeap c, a
\end_layout

\begin_layout Plain Layout

    c.assert isEqual sortByValue(a), 
\backslash

\end_layout

\begin_layout Plain Layout

      sortByValue(heap.content)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

declare 'heap pops elements in sorted order',
\end_layout

\begin_layout Plain Layout

  [arbArray(arbInt)], (c, a) ->
\end_layout

\begin_layout Plain Layout

    heap = buildHeap c, a
\end_layout

\begin_layout Plain Layout

    for n in sortByValue a then c.assert n == heap.pop()
\end_layout

\begin_layout Plain Layout

    c.assert heap.size() == 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

declare 'heap does not remove non-existent elements',
\end_layout

\begin_layout Plain Layout

  [arbArray(arbInt), arbInt],
\end_layout

\begin_layout Plain Layout

  expectException (c, a, b) ->
\end_layout

\begin_layout Plain Layout

    if b in a then c.guard false
\end_layout

\begin_layout Plain Layout

    heap = buildHeap c, a
\end_layout

\begin_layout Plain Layout

    heap.remove b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

declare 'heap removes existing elements',
\end_layout

\begin_layout Plain Layout

  [arbArray(arbInt), arbInt], (c, a, b) ->
\end_layout

\begin_layout Plain Layout

    if not (b in a) then c.guard false
\end_layout

\begin_layout Plain Layout

    aSort = sortByValue without a, b
\end_layout

\begin_layout Plain Layout

    count = a.length - aSort.length
\end_layout

\begin_layout Plain Layout

    heap = buildHeap c, a
\end_layout

\begin_layout Plain Layout

    heap.remove b for i in [0...count]
\end_layout

\begin_layout Plain Layout

    for n in aSort then c.assert n == heap.pop()
\end_layout

\begin_layout Plain Layout

    c.assert heap.size() == 0
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Performance
\begin_inset Argument
status collapsed

\begin_layout Plain Layout
Performance
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Performance"

\end_inset


\end_layout

\begin_layout Standard
To give an idea of the relative performance of CoffeeScript for problem
 solving and number crunching we can compare it with CPython.
 First a small test of operations on a million floating point numbers.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\lang english
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},extendedchars=true,showstringspaces=false,string={[b]\&quot;},tabsize=2"
inline false
status open

\begin_layout Plain Layout

# CoffeeScript
\end_layout

\begin_layout Plain Layout

show = console.log
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

start = new Date()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N = 1000000
\end_layout

\begin_layout Plain Layout

a = Array(N)
\end_layout

\begin_layout Plain Layout

for i in [0...N]
\end_layout

\begin_layout Plain Layout

  a[i] = Math.random()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s = 0
\end_layout

\begin_layout Plain Layout

for v in a
\end_layout

\begin_layout Plain Layout

  s += v
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

t = 0
\end_layout

\begin_layout Plain Layout

for v in a
\end_layout

\begin_layout Plain Layout

  t += v*v
\end_layout

\begin_layout Plain Layout

t = Math.sqrt t
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

duration = new Date() - start
\end_layout

\begin_layout Plain Layout

show "N: #{N} in #{duration*0.001} s"
\end_layout

\begin_layout Plain Layout

show "Result: #{s} and #{t}"
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\lang english
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=Python,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

# CPython
\end_layout

\begin_layout Plain Layout

import time
\end_layout

\begin_layout Plain Layout

import random
\end_layout

\begin_layout Plain Layout

import math
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

start = time.clock()
\end_layout

\begin_layout Plain Layout

N = 1000000
\end_layout

\begin_layout Plain Layout

a = [random.random()
\end_layout

\begin_layout Plain Layout

  for i in range(N)]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s = 0
\end_layout

\begin_layout Plain Layout

for v in a:
\end_layout

\begin_layout Plain Layout

  s += v
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

t = 0
\end_layout

\begin_layout Plain Layout

for v in a:
\end_layout

\begin_layout Plain Layout

  t += v*v
\end_layout

\begin_layout Plain Layout

t = math.sqrt(t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

duration = time.clock() - start
\end_layout

\begin_layout Plain Layout

print 'N:', N, 'in', duration, 's'
\end_layout

\begin_layout Plain Layout

print 'Result:', s, 'and', t
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The source code and the results are quite similar.
 On my machine the time for CoffeeScript is about 0.41s and around 1.03s for
 CPython.
 You can try it yourself with 
\begin_inset listings
lstparams "language=bash,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

coffee A3-Microbench.coffee
\end_layout

\end_inset

 and if you have CPython installed 
\begin_inset listings
lstparams "language=bash,showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

python A3-Microtest.py
\end_layout

\end_inset

.
 C++ is 10
\begin_inset Formula ${\scriptstyle \times}$
\end_inset

 to 30
\begin_inset Formula ${\scriptstyle \times}$
\end_inset

 faster.
\end_layout

\begin_layout Standard
\paragraph_spacing other 0.5
\noindent
\align center
\begin_inset Formula $\circ\bullet\circ$
\end_inset


\end_layout

\begin_layout Standard
On the next page you can find implementations
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Background information on 
\begin_inset CommandInset href
LatexCommand href
name "8 queens puzzle"
target "http://en.wikipedia.org/wiki/Eight_queens_puzzle"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "implementation"
target "http://code.activestate.com/recipes/190465-generator-for-permutations-combinations-selections/"

\end_inset

 and 
\begin_inset CommandInset href
LatexCommand href
name "performance"
target "http://aminsblog.wordpress.com/2011/05/29/n-queen-problem-python-2-6-5-vs-pypy-1-5-0/"

\end_inset

.
\end_layout

\end_inset

 for the classic 8 queens problem.
 The objective is to place eight queens on a chessboard without any of the
 queens occupying the same row, column or diagonal.
 The two implementations use the same algorithm and produce the same results.
 Timing for CPython 0.27s and for CoffeeScript 0.06s.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\lang english
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily},extendedchars=true,showstringspaces=false,string={[b]\&quot;},tabsize=2"
inline false
status open

\begin_layout Plain Layout

# CoffeeScript encoding: utf-8
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

start = new Date()
\end_layout

\begin_layout Plain Layout

show = console.log
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Create variations to try
\end_layout

\begin_layout Plain Layout

permute = (L) ->
\end_layout

\begin_layout Plain Layout

  n = L.length
\end_layout

\begin_layout Plain Layout

  return ([elem] for elem in L) if n is 1
\end_layout

\begin_layout Plain Layout

  [a, L] = [ [L[0]], L.slice 1 ]
\end_layout

\begin_layout Plain Layout

  result = []
\end_layout

\begin_layout Plain Layout

  for p in permute L
\end_layout

\begin_layout Plain Layout

    for i in [0...n]
\end_layout

\begin_layout Plain Layout

      result.push p[...i].concat a, p[i...]
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Check a variation
\end_layout

\begin_layout Plain Layout

test = (p, n) ->
\end_layout

\begin_layout Plain Layout

  for i in [0...n - 1]
\end_layout

\begin_layout Plain Layout

    for j in [i + 1...n]
\end_layout

\begin_layout Plain Layout

      d = p[i] - p[j]
\end_layout

\begin_layout Plain Layout

      return true if j - i == d or i - j == d
\end_layout

\begin_layout Plain Layout

  false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# N queens solver
\end_layout

\begin_layout Plain Layout

nQueen = (n) ->
\end_layout

\begin_layout Plain Layout

  result = []
\end_layout

\begin_layout Plain Layout

  for p in permute [0...n]
\end_layout

\begin_layout Plain Layout

    result.push p unless test p, n
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Repeat a string a number of times
\end_layout

\begin_layout Plain Layout

rep = (s, n) -> (s for [0...n]).join ''
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Display a board with a solution
\end_layout

\begin_layout Plain Layout

printBoard = (solution) ->
\end_layout

\begin_layout Plain Layout

  board = "
\backslash
n"
\end_layout

\begin_layout Plain Layout

  end = solution.length
\end_layout

\begin_layout Plain Layout

  for pos, row in solution
\end_layout

\begin_layout Plain Layout

    board += "#{end - row} #{rep ' - ', pos} " +
\end_layout

\begin_layout Plain Layout

             "* #{rep ' - ', end - pos - 1}
\backslash
n"
\end_layout

\begin_layout Plain Layout

  # Using radix 18 hack!
\end_layout

\begin_layout Plain Layout

  board += '   ' + (n.toString 18 
\backslash

\end_layout

\begin_layout Plain Layout

    for n in [10...18]).join('  ').toUpperCase()
\end_layout

\begin_layout Plain Layout

  board + "
\backslash
n"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Find all solutions
\end_layout

\begin_layout Plain Layout

solve = (n) ->
\end_layout

\begin_layout Plain Layout

  for solution, count in nQueen n
\end_layout

\begin_layout Plain Layout

    show "Solution #{count+1}:"
\end_layout

\begin_layout Plain Layout

    show printBoard solution
\end_layout

\begin_layout Plain Layout

  count
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

solve 8 # Normal chessboard size
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

show "Timing: #{(new Date() - start)*0.001}s"
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\lang english
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily},language=Python,showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

# CPython encoding: utf-8
\end_layout

\begin_layout Plain Layout

import time
\end_layout

\begin_layout Plain Layout

t=time.clock()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def permute(L):
\end_layout

\begin_layout Plain Layout

    "Create variations to try"
\end_layout

\begin_layout Plain Layout

    n = len(L)
\end_layout

\begin_layout Plain Layout

    if n == 1:
\end_layout

\begin_layout Plain Layout

        for elem in L:
\end_layout

\begin_layout Plain Layout

            yield [elem]
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        a = [L.pop(0)]
\end_layout

\begin_layout Plain Layout

        for p in permute(L):
\end_layout

\begin_layout Plain Layout

            for i in range(n):
\end_layout

\begin_layout Plain Layout

                yield p[:i] + a + p[i:]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def test(p, n):
\end_layout

\begin_layout Plain Layout

    "Check a variation"
\end_layout

\begin_layout Plain Layout

    for i in range(n - 1):
\end_layout

\begin_layout Plain Layout

        for j in range(i + 1, n):
\end_layout

\begin_layout Plain Layout

            d = p[i] - p[j]
\end_layout

\begin_layout Plain Layout

            if j - i == d or i - j == d:
\end_layout

\begin_layout Plain Layout

                return True
\end_layout

\begin_layout Plain Layout

    return False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def n_queen(n):
\end_layout

\begin_layout Plain Layout

    "N queens solver"
\end_layout

\begin_layout Plain Layout

    for p in permute(range(n)):
\end_layout

\begin_layout Plain Layout

        if not test(p, n): yield p
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Start columns from A
\end_layout

\begin_layout Plain Layout

base_char = ord('A')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def print_board(solution):
\end_layout

\begin_layout Plain Layout

    "Display a board with a solution"
\end_layout

\begin_layout Plain Layout

    board = []
\end_layout

\begin_layout Plain Layout

    end = len(solution)
\end_layout

\begin_layout Plain Layout

    for row, pos in enumerate(solution):
\end_layout

\begin_layout Plain Layout

        board += ["
\backslash
n%s %s * %s" % ((end - row),
\end_layout

\begin_layout Plain Layout

          (' - ' * pos),
\end_layout

\begin_layout Plain Layout

          (' - ' * (end - pos - 1)))]
\end_layout

\begin_layout Plain Layout

    # Using character set hack!
\end_layout

\begin_layout Plain Layout

    board += '
\backslash
n   ' + 
\backslash

\end_layout

\begin_layout Plain Layout

      '  '.join([chr(base_char+i)
\end_layout

\begin_layout Plain Layout

        for i in range(0, end)])
\end_layout

\begin_layout Plain Layout

    return ''.join(board) + '
\backslash
n'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def solve(n):
\end_layout

\begin_layout Plain Layout

    "Find all solutions"
\end_layout

\begin_layout Plain Layout

    for count, solution in enumerate(n_queen(n)):
\end_layout

\begin_layout Plain Layout

        print "Solution %d:" % count
\end_layout

\begin_layout Plain Layout

        print print_board(solution)
\end_layout

\begin_layout Plain Layout

    return count
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

solve(8) # Normal chessboard size
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "Timing: ", time.clock()-t, "s"
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset space \hspace{}
\length 3.5em
\end_inset

Solution 1
\begin_inset space \hspace{}
\length 3.5em
\end_inset

 
\begin_inset space \rightarrowfill{}
\end_inset

 
\begin_inset space \hspace{}
\length 3.5em
\end_inset

Solution 92
\begin_inset space \hspace{}
\length 3.2em
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename img/queens.png
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Chapter
Command Line Utility
\begin_inset Argument
status collapsed

\begin_layout Plain Layout
Command Line Utility
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:CommandLine"

\end_inset


\end_layout

\begin_layout Standard
The utility used to remove solutions from source files is shown here.
 Partly as an example of a command line program, partly to make this book
 and its accompanying source code self-containing.
\end_layout

\begin_layout Standard
The program uses the asynchronous file system functions in the same manner
 as server programs.
 The synchronous functions are more conventional, but less illustrative.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},showstringspaces=false,string={[b]\&quot;},tabsize=2"
inline false
status open

\begin_layout Plain Layout

fs = require "fs"
\end_layout

\begin_layout Plain Layout

show = console.log
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

String::contains = (pattern) ->
\end_layout

\begin_layout Plain Layout

  ///#{pattern}///.test this
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

leadingWhitespace = (str) ->
\end_layout

\begin_layout Plain Layout

  (str.match /(
\backslash
s*)
\backslash
w/)[1] ? ""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

errorWrapper = (action) ->
\end_layout

\begin_layout Plain Layout

  (err, args...) ->
\end_layout

\begin_layout Plain Layout

    if err then throw err
\end_layout

\begin_layout Plain Layout

    action args...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ifFileExists = (filename, action) ->
\end_layout

\begin_layout Plain Layout

  fs.stat filename, errorWrapper (stat) ->
\end_layout

\begin_layout Plain Layout

    if stat.isFile() then action()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

getFileAsLines = (filename, action) ->
\end_layout

\begin_layout Plain Layout

  ifFileExists filename, ->
\end_layout

\begin_layout Plain Layout

    fs.readFile filename, "utf8",
\end_layout

\begin_layout Plain Layout

      errorWrapper (content) ->
\end_layout

\begin_layout Plain Layout

        action content.split "
\backslash
n"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

saveFile = (filename, content) ->
\end_layout

\begin_layout Plain Layout

  fs.writeFile filename, content,
\end_layout

\begin_layout Plain Layout

    errorWrapper -> show "Saved #{filename}"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stripSolutions = (lines) ->
\end_layout

\begin_layout Plain Layout

  out = ""
\end_layout

\begin_layout Plain Layout

  inSolution = false
\end_layout

\begin_layout Plain Layout

  concat = (str) -> out += str + "
\backslash
n"
\end_layout

\begin_layout Plain Layout

  for line in lines
\end_layout

\begin_layout Plain Layout

    if line.contains "'--- Exercise 
\backslash

\backslash
d+ ---'"
\end_layout

\begin_layout Plain Layout

      inSolution = true
\end_layout

\begin_layout Plain Layout

      concat line
\end_layout

\begin_layout Plain Layout

      indent = leadingWhitespace line
\end_layout

\begin_layout Plain Layout

      concat "#{indent}process.exit()" +
\end_layout

\begin_layout Plain Layout

        " # Replace this line with your solution"
\end_layout

\begin_layout Plain Layout

    else if inSolution
\end_layout

\begin_layout Plain Layout

      if line.contains "'--- End of Exercise ---'"
\end_layout

\begin_layout Plain Layout

        concat line
\end_layout

\begin_layout Plain Layout

        inSolution = false
\end_layout

\begin_layout Plain Layout

      # else ignore line in solution
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

      concat line
\end_layout

\begin_layout Plain Layout

  # Remove trailing newline
\end_layout

\begin_layout Plain Layout

  out[...out.length-1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stripFile = (fromName, toName) ->
\end_layout

\begin_layout Plain Layout

  if fromName?
\end_layout

\begin_layout Plain Layout

    getFileAsLines fromName, (lines) ->
\end_layout

\begin_layout Plain Layout

      saveFile toName, stripSolutions lines
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    show "Expected a file name " +
\end_layout

\begin_layout Plain Layout

         "to strip for solutions"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},showstringspaces=false,string={[b]\&quot;},tabsize=2"
inline false
status open

\begin_layout Plain Layout

copyFile = (fromName, toName) ->
\end_layout

\begin_layout Plain Layout

  if fromName?
\end_layout

\begin_layout Plain Layout

    ifFileExists fromName, ->
\end_layout

\begin_layout Plain Layout

      fs.readFile fromName, "utf8",
\end_layout

\begin_layout Plain Layout

        errorWrapper (content) ->
\end_layout

\begin_layout Plain Layout

          saveFile toName, content,
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    show "Expected a file name to copy"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

toDir = "../src-no-solutions"
\end_layout

\begin_layout Plain Layout

fs.mkdir toDir, 0777, (err) ->
\end_layout

\begin_layout Plain Layout

  if err
\end_layout

\begin_layout Plain Layout

    throw err unless err.code is 'EEXIST'
\end_layout

\begin_layout Plain Layout

    show "Reusing"
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    show "Created"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fromDir = process.argv[2]
\end_layout

\begin_layout Plain Layout

if fromDir?
\end_layout

\begin_layout Plain Layout

  fs.readdir fromDir, errorWrapper (files) ->
\end_layout

\begin_layout Plain Layout

    for filename in files
\end_layout

\begin_layout Plain Layout

      if filename.contains "
\backslash

\backslash
w
\backslash

\backslash
w-
\backslash

\backslash
w+.coffee"
\end_layout

\begin_layout Plain Layout

        stripFile filename, "#{toDir}/#{filename}"
\end_layout

\begin_layout Plain Layout

      else
\end_layout

\begin_layout Plain Layout

        copyFile filename, "#{toDir}/#{filename}"
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

  show "Expected a directory with " +
\end_layout

\begin_layout Plain Layout

       "solutions to strip"
\end_layout

\end_inset


\end_layout

\begin_layout Part
Reference and Index
\end_layout

\begin_layout Chapter
Reference
\begin_inset Argument
status collapsed

\begin_layout Plain Layout
Reference
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:Indices"

\end_inset


\end_layout

\begin_layout Section*
Language Reference
\end_layout

\begin_layout Standard
Refer to 
\begin_inset CommandInset href
LatexCommand href
name "coffeescript.org"
target "http://coffeescript.org"

\end_inset

 for further reference material and examples.
\end_layout

\begin_layout Subsection*
General
\end_layout

\begin_layout Itemize
Whitespace is significant
\end_layout

\begin_layout Itemize
Ending a line will terminate expressions - no need to use semicolons
\end_layout

\begin_layout Itemize
Semicolons can be used to fit multiple expressions onto a single line
\end_layout

\begin_layout Itemize
Use indentation instead of curly braces 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ }
\end_layout

\end_inset

 to surround blocks of code in functions, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statements, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try/catch
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Comments starts with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

#
\end_layout

\end_inset

 and run to the end of the line
\end_layout

\begin_layout Subsection*
Embedded JavaScript
\end_layout

\begin_layout Itemize
Use backquotes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

``
\end_layout

\end_inset

 to embed JavaScript code within CoffeeScript
\end_layout

\begin_layout Subsection*
Functions
\end_layout

\begin_layout Itemize
Functions are defined by an optional list of parameters in parentheses,
 an arrow, and an optional function body.
 The empty function looks like: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mostly no need to use parentheses to invoke a function if it is passed arguments.
 The implicit call wraps forward to the end of the line or block expression.
\end_layout

\begin_layout Itemize
Functions may have default values for arguments.
 Override the default value by passing a non-null argument.
\end_layout

\begin_layout Subsection*
Objects and arrays
\end_layout

\begin_layout Itemize
Objects and arrays are similar to JavaScript
\end_layout

\begin_layout Itemize
When each property is listed on its own line, the commas are optional
\end_layout

\begin_layout Itemize
Objects may be created using indentation instead of explicit braces, similar
 to YAML
\end_layout

\begin_layout Itemize
Reserved words, like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

, can be used as properties of an object without quoting them as strings
\end_layout

\begin_layout Subsection*
Lexical Scoping and Variable Safety
\end_layout

\begin_layout Itemize
Variables are declared implicitly when used (no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

var
\end_layout

\end_inset

 keyword).
\end_layout

\begin_layout Itemize
The compiler ensures that variables are declared within lexical scope.
 An outer variable is not redeclared within an inner function when it is
 in scope
\end_layout

\begin_layout Itemize
Using an inner variable can not shadow an outer variable, only refer to
 it.
 So avoid reusing the name of an external variable in a deeply nested function
\end_layout

\begin_layout Itemize
CoffeeScript output is wrapped in an anonymous function, making it difficult
 to accidentally pollute the global namespace
\end_layout

\begin_layout Itemize
To create top-level variables for other scripts, attach them as properties
 on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

window
\end_layout

\end_inset

, or to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exports
\end_layout

\end_inset

 in CommonJS.
 Use: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exports ? this
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
If, Else, Unless, and Conditional Assignment
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 can be written without parentheses and curly braces
\end_layout

\begin_layout Itemize
Multi-line conditionals are delimited by indentation
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unless
\end_layout

\end_inset

 can be used in postfix form i.e.
 at the end of the statement
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 statements can be used as expressions.
 No need for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?:
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Splats
\end_layout

\begin_layout Itemize
Splats 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

...
\end_layout

\end_inset

 can be used instead of the variable number of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

arguments
\end_layout

\end_inset

 object and are available for both function definition and invocation
\end_layout

\begin_layout Subsection*
Loops and Comprehensions
\end_layout

\begin_layout Itemize
Comprehensions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for ...
 in
\end_layout

\end_inset

 work over arrays, objects, and ranges
\end_layout

\begin_layout Itemize
Comprehensions replace for loops, with optional guard clauses and the value
 of the current array index: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for value, index in array
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Array comprehensions are expressions, and can be returned and assigned
\end_layout

\begin_layout Itemize
Comprehensions may replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

each/forEach
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

select/filter
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use a range when the start and end of a loop is known (integer steps)
\end_layout

\begin_layout Itemize
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

by
\end_layout

\end_inset

 to step in fixed-size increments
\end_layout

\begin_layout Itemize
When assigning the value of a comprehension to a variable, CoffeeScript
 collects the result of each iteration into an array
\end_layout

\begin_layout Itemize
Return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 if a loop is only for side-effects
\end_layout

\begin_layout Itemize
To iterate over the key and value properties in an object, use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for own key, value of object
\end_layout

\end_inset

 to iterate over the keys that are directly defined on an object
\end_layout

\begin_layout Itemize
The only low-level loop is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

 loop.
 It can be used as an expression, returning an array containing the result
 of each iteration through the loop
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

until
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while not
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

loop
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while true
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

do
\end_layout

\end_inset

 keyword inserts a closure wrapper, forwards any arguments and invokes a
 passed function
\end_layout

\begin_layout Subsection*
Array Slicing and Splicing with Ranges
\end_layout

\begin_layout Itemize
Ranges can be used to extract slices of arrays
\end_layout

\begin_layout Itemize
With two dots 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[3..6]
\end_layout

\end_inset

, the range is inclusive (3, 4, 5, 6)
\end_layout

\begin_layout Itemize
With three dots 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[3...6]
\end_layout

\end_inset

, the range excludes the end (3, 4, 5)
\end_layout

\begin_layout Itemize
The same syntax can be used with assignment to replace a segment of an array
 with new values, splicing it
\end_layout

\begin_layout Itemize
Strings are immutable and can not be spliced
\end_layout

\begin_layout Subsection*
Everything is an Expression
\end_layout

\begin_layout Itemize
Functions return their final value
\end_layout

\begin_layout Itemize
The return value is fetched from each branch of execution
\end_layout

\begin_layout Itemize
Return early from a function body by using an explicit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Variable declarations are at the top of the scope, so assignment can be
 used within expressions, even for variables that have not been seen before
\end_layout

\begin_layout Itemize
Statements, when used as part of an expression, are converted into expressions
 with a closure wrapper.
 This allows assignment of the result of a comprehension to a variable
\end_layout

\begin_layout Itemize
The following are not expressions: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

continue
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Operators and Aliases
\end_layout

\begin_layout Itemize
CoffeeScript compiles 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

===
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!=
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!==
\end_layout

\end_inset

.
 There is no equivalent to the JavaScript 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 operator
\end_layout

\begin_layout Itemize
The alias 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

===
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isnt
\end_layout

\end_inset

 corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!==
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

not
\end_layout

\end_inset

 is an alias for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Logical operator aliases: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

and
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

&&
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

or
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

while
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch/when
\end_layout

\end_inset

 statements the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

then
\end_layout

\end_inset

 keyword can be used to keep the body on the same line
\end_layout

\begin_layout Itemize
Alias for boolean 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

on
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yes
\end_layout

\end_inset

 (as in YAML)
\end_layout

\begin_layout Itemize
Alias for boolean 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

off
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

no
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
For single-line statements, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unless
\end_layout

\end_inset

 can be used as the inverse of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@property
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this.property
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

in
\end_layout

\end_inset

 to test for array presence
\end_layout

\begin_layout Itemize
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

of
\end_layout

\end_inset

 to test for object-key presence
\end_layout

\begin_layout Subsection*
Existential Operator
\end_layout

\begin_layout Itemize
Use the existential operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?
\end_layout

\end_inset

 to check if a variable exists
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?
\end_layout

\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 unless a variable is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?=
\end_layout

\end_inset

 for safer conditional assignment than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

||=
\end_layout

\end_inset

 when handling numbers or strings
\end_layout

\begin_layout Itemize
The accessor variant of the existential operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?.
\end_layout

\end_inset

 can be used to soak up null references in a chain of properties
\end_layout

\begin_layout Itemize
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

?.
\end_layout

\end_inset

 instead of the dot accessor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.
\end_layout

\end_inset

 in cases where the base value may be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

null
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

.
 If all of the properties exist then the expected result is returned, if
 the chain is broken, then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

undefined
\end_layout

\end_inset

 is returned instead
\end_layout

\begin_layout Subsection*
Classes, Inheritance, and Super
\end_layout

\begin_layout Itemize
Object orientation as in most other object oriented languages
\end_layout

\begin_layout Itemize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

 structure allows to name the class, set the superclass with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extends
\end_layout

\end_inset

, assign prototypal properties, and define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

constructor
\end_layout

\end_inset

, in a single assignable expression
\end_layout

\begin_layout Itemize
Constructor functions are named as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

 name, to support reflection
\end_layout

\begin_layout Itemize
Lower level operators: The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extends
\end_layout

\end_inset

 operator helps with proper prototype setup.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

::
\end_layout

\end_inset

 gives access to an object
\begin_inset Quotes ers
\end_inset

s prototype.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

super()
\end_layout

\end_inset

 calls the immediate ancestor
\begin_inset Quotes ers
\end_inset

s method of the same name
\end_layout

\begin_layout Itemize
A class definition is a block of executable code, which may be used for
 meta programming.
\end_layout

\begin_layout Itemize
In the context of a class definition, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset

 is the class object itself (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

constructor
\end_layout

\end_inset

 function), so static properties can be assigned by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@property: value
\end_layout

\end_inset

, and functions defined in parent classes can be called with: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@inheritedMethodName()
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Destructuring Assignment
\end_layout

\begin_layout Itemize
To make extracting values from complex arrays and objects convenient, CoffeeScri
pt implements destructuring assignment
\end_layout

\begin_layout Itemize
When assigning an array or object literal to a value, CoffeeScript breaks
 up and matches both sides against each other, assigning the values on the
 right to the variables on the left
\end_layout

\begin_layout Itemize
The simplest case is parallel assignment 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[a,b] = [b,a]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
It can be used with functions that return multiple values
\end_layout

\begin_layout Itemize
It can be used with any depth of array and object nesting to get deeply
 nested properties and can be combined with splats
\end_layout

\begin_layout Subsection*
Function binding
\end_layout

\begin_layout Itemize
The fat arrow 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 can be used to define a function and bind it to the current value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This is helpful when using callback-based libraries, for creating iterator
 functions to pass to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

each
\end_layout

\end_inset

 or event-handler functions to use with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bind
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Functions created with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 are able to access properties of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

this
\end_layout

\end_inset

 where they are defined
\end_layout

\begin_layout Subsection*
Switch/When/Else
\end_layout

\begin_layout Itemize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset

 statement do not need a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

break
\end_layout

\end_inset

 after every case
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset

 is a returnable, assignable expression
\end_layout

\begin_layout Itemize
The format is: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset

 condition, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

when
\end_layout

\end_inset

 clauses, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 the default case
\end_layout

\begin_layout Itemize
Multiple values, comma separated, can be given for each 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

when
\end_layout

\end_inset

 clause.
 If any of the values match, the clause runs
\end_layout

\begin_layout Subsection*
Try/Catch/Finally
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

try/catch
\end_layout

\end_inset

 statements are as in JavaScript (although they are expressions)
\end_layout

\begin_layout Subsection*
String Interpolation, Heredocs, and Block Comments
\end_layout

\begin_layout Itemize
Single-quoted strings are literal.
 Use backslash for escape characters
\end_layout

\begin_layout Itemize
Double-quoted strings allow for interpolated values, using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

#{ ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Multiline strings are allowed
\end_layout

\begin_layout Itemize
A heredoc 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'''
\end_layout

\end_inset

 can be used for formatted or indentation-sensitive text (or to avoid escaping
 quotes and apostrophes)
\end_layout

\begin_layout Itemize
The indentation level that begins a heredoc is maintained throughout, so
 the text can be aligned with the body of the code
\end_layout

\begin_layout Itemize
Double-quoted heredocs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

"""
\end_layout

\end_inset

 allow for interpolation
\end_layout

\begin_layout Itemize
Block comments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

###
\end_layout

\end_inset

 are similar to heredocs, and are preserved in the generated code
\end_layout

\begin_layout Subsection*
Chained Comparisons
\end_layout

\begin_layout Itemize
Use a chained comparison 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

minimum < value < maximum
\end_layout

\end_inset

 to test if a value falls within a range
\end_layout

\begin_layout Subsection*
Extended Regular Expressions
\end_layout

\begin_layout Itemize
Extended regular expressions 
\begin_inset Quotes eld
\end_inset

heregexes
\begin_inset Quotes erd
\end_inset

 are delimited by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

///
\end_layout

\end_inset

 and are similar to heredocs and block comments
\end_layout

\begin_layout Itemize
Extended regular expressions ignore internal whitespace and can contain
 comments
\end_layout

\begin_layout Subsection*
Reserved Words
\begin_inset CommandInset label
LatexCommand label
name "sub:Reserved-Words"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Keywords
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

break             by                catch
\end_layout

\begin_layout Plain Layout

class             continue          debugger
\end_layout

\begin_layout Plain Layout

delete            do                else
\end_layout

\begin_layout Plain Layout

extends           false             finally
\end_layout

\begin_layout Plain Layout

for               if                in
\end_layout

\begin_layout Plain Layout

instanceof        loop              new
\end_layout

\begin_layout Plain Layout

null              of                return
\end_layout

\begin_layout Plain Layout

super             switch            then
\end_layout

\begin_layout Plain Layout

this              throw             true
\end_layout

\begin_layout Plain Layout

try               typeof            undefined
\end_layout

\begin_layout Plain Layout

unless            until             when
\end_layout

\begin_layout Plain Layout

while
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Aliases
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

and  :  &&        or   :  ||        not  :  !
\end_layout

\begin_layout Plain Layout

is   :  ==        isnt :  !=
\end_layout

\begin_layout Plain Layout

yes  :  true      no   :  false
\end_layout

\begin_layout Plain Layout

on   :  true      off  :  false
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Underscore
\begin_inset CommandInset label
LatexCommand label
name "sub:Underscore"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Functions
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

all               any               bind
\end_layout

\begin_layout Plain Layout

bindAll           breakLoop         clone
\end_layout

\begin_layout Plain Layout

compact           compose           contains
\end_layout

\begin_layout Plain Layout

defer             delay             detect
\end_layout

\begin_layout Plain Layout

each              every             extend
\end_layout

\begin_layout Plain Layout

filter            first             flatten
\end_layout

\begin_layout Plain Layout

foldl             foldr             forEach
\end_layout

\begin_layout Plain Layout

functions         head              identity
\end_layout

\begin_layout Plain Layout

include           indexOf           inject
\end_layout

\begin_layout Plain Layout

intersect         invoke            isArguments
\end_layout

\begin_layout Plain Layout

isArray           isBoolean         isDate
\end_layout

\begin_layout Plain Layout

isElement         isEmpty           isEqual
\end_layout

\begin_layout Plain Layout

isFunction        isNull            isNumber
\end_layout

\begin_layout Plain Layout

isRegExp          isString          isUndefined
\end_layout

\begin_layout Plain Layout

keys              last              lastIndexOf
\end_layout

\begin_layout Plain Layout

map               max               memoize
\end_layout

\begin_layout Plain Layout

methods           min               mixin
\end_layout

\begin_layout Plain Layout

noConflict        pluck             range
\end_layout

\begin_layout Plain Layout

reduce            reduceRight       reject
\end_layout

\begin_layout Plain Layout

rest              select            size
\end_layout

\begin_layout Plain Layout

some              sortBy            sortedIndex
\end_layout

\begin_layout Plain Layout

tail              tap               template
\end_layout

\begin_layout Plain Layout

templateSettings  times             toArray
\end_layout

\begin_layout Plain Layout

uniq              uniqueId          values
\end_layout

\begin_layout Plain Layout

without           wrap              zip
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
General call convention: 
\begin_inset listings
lstparams "showstringspaces=false,tabsize=2"
inline true
status open

\begin_layout Plain Layout

functional obj, iterator, context
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
Refer to 
\begin_inset listings
lstparams "language=bash"
inline true
status open

\begin_layout Plain Layout

src/docs/underscore.html
\end_layout

\end_inset

 for an annotated reference.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
\begin_inset Newpage clearpage
\end_inset

qc.js
\begin_inset CommandInset label
LatexCommand label
name "sub:qc.js"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Exported Definitions
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbChoose Generator that chooses uniformly among the given generators.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter generators\SpecialChar \ldots{}

\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbConst Generator that always returns one of the given constant values.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter values\SpecialChar \ldots{}

\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbBool Boolean value generator with 50:50 chance of true or false.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbNull Null generator that always generates 'null'.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbWholeNum Integer value generator for values ≥ 0.
 Supports shrinking.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbInt Integer value generator.
 Supports shrinking.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbFloatUnit Generator for a floating point value in between 0.0 and 1.0.
 Supports shrinking.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbRange Integer range value generator.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter minimum value
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter maximum value
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbNullOr Chooses null with 10% probability and the given generator with
 90%.
 Supports shrinking.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter another generator
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arrShrinkOne Array shrinking strategy that builds new Arrays by removing
 one element from a given array.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbArray Array generator.
 Generates an array of arbitrary length with the given generator.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter generator that creates the resulting array values.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter an optional shrinking strategy.
 Default is 
\begin_inset Quotes els
\end_inset

arrShrinkOne
\begin_inset Quotes ers
\end_inset

.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbDate Date value generator.
 Always generates a new Date object by calling 
\begin_inset Quotes els
\end_inset

new Date()
\begin_inset Quotes ers
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbMod Basis generator for arbChar and arbString.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbChar Character value generator for any character with character code
 in range 32-255.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbString String value generator.
 All characters in the generated String are in range 32-255.
 Supports shrinking.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbUndef Generator that always generates 'undefined'.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
arbUndefOr Chooses undefined with 10% probability and the given generator
 with 90%.
 Supports shrinking.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter another generator
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
expectException Property test function modifier.
 Using this modifier, it is assumed that the testing function will throw
 an exception and if not the property will fail.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
failOnException Property test function modifier.
 Instead of finishing testing when an unexpected exception is thrown, the
 offending property is marked as failure and 
\family typewriter
qc
\family default
 will continue.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Case Test case class generated every time a property is tested.
 An instance of Case is always passed as first argument to a property's
 testing function so it can control the test case
\begin_inset Quotes ers
\end_inset

s properties.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Case::assert Tests and notifies 
\family typewriter
qc
\family default
 if a property fails or not.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter pass false, if the property failed, true otherwise
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Case::guard Used to test if the input is good for testing the property.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter pass false to mark the property as invalid for the given input.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Case::classify Adds a tag to a test run.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter if true then the tag is added to the case, else not.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter tag value to add
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Case::collect Collect builds a histogram of all collected values for all
 runs of the property.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter value to collect
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Case::noteArg Adds the given value to the test case for reporting in case
 of failure.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter value to add
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Case::note Same as Case::noteArg but returning its argument so it can be
 used inline.
 Defined in prelude.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Case::noteVerbose Same as Case::note but also logs the noted args.
 Defined in prelude.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
declare Builds and registers a new property.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter the property
\begin_inset Quotes ers
\end_inset

s name
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter array of generators with a length equal to the arity of the body
 function.
 The entry at position i will drive the i-th argument of the body function.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter body function that test the property
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
return a new registered property object of type Prop.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
testPure Helper to declare a named test property for a pure function.
 Defined in prelude.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter function to test
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter array of generators matching argument types
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter a descriptive name
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter property function which is passed the test-case, the arguments
 and the result of calling the function being tested.
 Must return true if the property test succeeded, false otherwise.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Prop Creates a new property with a given array of argument generators and
 a testing function.
 For each generator a value is generated, so for testing a 2-ary function
 the array must contain 2 generators.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Prop::run Tests the property.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter configuration of type Config to test property with
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
return depending on test result a Pass, Fail or Invalid object
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
allProps Internal array of all declared/registered properties
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
resetProps Deletes all declared properties.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
runAllProps Tests all registered properties.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter configuration of type Config to test the properties with
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter listener of a subclass of ConsoleListener
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
test Test all known properties with a NodeListener and a configuration of
 100 pass and 1000 invalid tests.
 Defined in prelude.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Invalid Report class for invalid tested properties.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Pass Report class for successful tested properties.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Fail Report class for failed tested properties.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Stats Statistics class for counting number of pass/invalid runs, building
 histograms and other statistics for reporting on a property and its test
 results.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Config Testing Configuration.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter maximum passes per property
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter maximum invalid tests per property
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
parameter maximum number of shrinking steps per property
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
ConsoleListener Abstract class for building 
\begin_inset Quotes els
\end_inset

console
\begin_inset Quotes ers
\end_inset

 based listeners.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
NodeListener Listener with node compatible output in colors.
 Defined in prelude.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
FBCListener Listener for sending property results to FireBug
\begin_inset Quotes ers
\end_inset

s console
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
RhinoListener Listener for Rhino, sending property results to stdout.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Distribution Probability distributions
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
genvalue Draws a new value from a generator.
 A generator is either a function accepting a seed argument or an object
 with a method 'arb' accepting a seed argument.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
genshrinked Uses the generator specific shrinking method to shrink a value
 that the generator created earlier.
 If the generator is a function or has no method named 'shrink' or is an
 objects with a 'shrink' method set to null, then no shrinking will be performed.
 If a shrinking method is defined, then it is called with the original seed
 and the value the generator created.
 The shrinking method must return an array of 
\begin_inset Quotes els
\end_inset

shrinked
\begin_inset Quotes ers
\end_inset

 values or null, undefined, or an empty array if no 
\begin_inset Quotes els
\end_inset

shrinked
\begin_inset Quotes ers
\end_inset

 values could be created.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
justSize Passes the size 
\begin_inset Quotes els
\end_inset

seed
\begin_inset Quotes ers
\end_inset

 argument used to drive generators directly to the property test function.
\end_layout

\begin_layout Labeling
\labelwidthstring ConsoleListener
\noindent

\size footnotesize
Utilities A group of utilities that can be used to build generators: frequency,
 choose, randWhole, randInt, randRange, randFloatUnit
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
\begin_inset Newpage clearpage
\end_inset

Additional Words
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
Prelude definitions
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

show              globalize
\end_layout

\begin_layout Plain Layout

confirm           prompt            getServerURL
\end_layout

\begin_layout Plain Layout

viewURL           viewServer        stopServer
\end_layout

\begin_layout Plain Layout

fileExists        readTextFile      readBinaryFile
\end_layout

\begin_layout Plain Layout

_                 kup               qc
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Refer to 
\begin_inset listings
lstparams "language=bash"
inline true
status open

\begin_layout Plain Layout

src/docs/prelude.html
\end_layout

\end_inset

 for an annotated reference.
\end_layout

\end_inset


\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
CoffeeScript environment
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},showstringspaces=false,tabsize=2"
inline false
status open

\begin_layout Plain Layout

Buffer            clearInterval     clearTimeout
\end_layout

\begin_layout Plain Layout

console           global            GLOBAL
\end_layout

\begin_layout Plain Layout

process           root              setInterval
\end_layout

\begin_layout Plain Layout

setTimeout
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
View the interactive environment with: 
\begin_inset Formula $\rightarrow\!\mid$
\end_inset

 / 
\begin_inset Quotes els
\end_inset

Tab
\begin_inset Quotes ers
\end_inset

.
\end_layout

\end_inset


\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family sans
\size large
\emph on
JavaScript future words
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

abstract    boolean     byte        case
\end_layout

\begin_layout Plain Layout

char        const       default     double
\end_layout

\begin_layout Plain Layout

enum        export      final       float
\end_layout

\begin_layout Plain Layout

function    goto        implements  import
\end_layout

\begin_layout Plain Layout

int         interface   let         long
\end_layout

\begin_layout Plain Layout

native      package     private     protected
\end_layout

\begin_layout Plain Layout

public      short       static      synchronized
\end_layout

\begin_layout Plain Layout

throws      transient   var         void
\end_layout

\begin_layout Plain Layout

volatile    with        yield
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Index"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
